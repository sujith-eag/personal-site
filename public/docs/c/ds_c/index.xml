<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Data Structures Using C on Sujith&#39;s Library</title>
    <link>http://localhost:1313/personal-site/docs/c/ds_c/</link>
    <description>Recent content in Data Structures Using C on Sujith&#39;s Library</description>
    <generator>Hugo</generator>
    <language>en</language>
    <copyright>Copyright (c) 2020-2024 Thulite</copyright>
    <lastBuildDate>Wed, 01 Jan 2025 16:00:44 +0530</lastBuildDate>
    <atom:link href="http://localhost:1313/personal-site/docs/c/ds_c/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>01 - Tower of Hanoi</title>
      <link>http://localhost:1313/personal-site/docs/c/ds_c/01-tower-of-hanoi/</link>
      <pubDate>Wed, 01 Jan 2025 16:00:11 +0530</pubDate>
      <guid>http://localhost:1313/personal-site/docs/c/ds_c/01-tower-of-hanoi/</guid>
      <description>&lt;ul&gt;&#xA;&lt;li&gt;&lt;code&gt;n&lt;/code&gt; number of disks, three &lt;code&gt;char&lt;/code&gt; as poles. ( &lt;code&gt;n&lt;/code&gt; is declared, A B C need not be declared )&lt;/li&gt;&#xA;&lt;li&gt;Get the input, pass it to function along with the Poles. &lt;code&gt;n, A, B, C&lt;/code&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;Function with 4 parameters.&lt;/p&gt;</description>
    </item>
    <item>
      <title>02 - Stack Operations</title>
      <link>http://localhost:1313/personal-site/docs/c/ds_c/02-stack-operations/</link>
      <pubDate>Wed, 01 Jan 2025 16:00:28 +0530</pubDate>
      <guid>http://localhost:1313/personal-site/docs/c/ds_c/02-stack-operations/</guid>
      <description>&lt;h3 id=&#34;variables-logic&#34;&gt;Variables Logic&lt;/h3&gt;&#xA;&lt;p&gt;A Stack has to be declared, Needs a variable for size and pointer for the top of Stack.&#xA;&lt;code&gt;n, top = -1&lt;/code&gt; are declared globally, to be accessible in all functions for verification and increment.&lt;/p&gt;</description>
    </item>
    <item>
      <title>03 - Infix to Postfix Conversion</title>
      <link>http://localhost:1313/personal-site/docs/c/ds_c/03-infix-to-postfix-conversion/</link>
      <pubDate>Wed, 01 Jan 2025 16:00:34 +0530</pubDate>
      <guid>http://localhost:1313/personal-site/docs/c/ds_c/03-infix-to-postfix-conversion/</guid>
      <description>&lt;p&gt;&lt;code&gt;#include &amp;lt;ctype.h&amp;gt;&lt;/code&gt; to get the &lt;code&gt;isalnum()&lt;/code&gt; function to check alphabets and numbers which returns false for any special characters.&lt;/p&gt;&#xA;&lt;h3 id=&#34;logic-for-variables&#34;&gt;Logic for Variables&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;A &lt;code&gt;char stack[100]&lt;/code&gt; fixed size array stack (not by input) for pushing and popping characters during process of conversion.&lt;/li&gt;&#xA;&lt;li&gt;A &lt;code&gt;int top = -1&lt;/code&gt; to point at the top of this stack.&lt;/li&gt;&#xA;&lt;li&gt;In main function one more fixed size stack &lt;code&gt;char exp[100]&lt;/code&gt; to catch the expression entered by the user.&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;char *e&lt;/code&gt; to be the pointer to the &lt;code&gt;exp&lt;/code&gt; array, used for traversal and checking end of &lt;code&gt;exp&lt;/code&gt;.&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;char x&lt;/code&gt; to catch the popped element from the &lt;code&gt;stack&lt;/code&gt; and printing it.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;implementation-logic&#34;&gt;Implementation Logic&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Make a &lt;code&gt;stack[]&lt;/code&gt; of a fixed size and &lt;code&gt;top = -1&lt;/code&gt; for pointing at its top position. Both global.&lt;/li&gt;&#xA;&lt;li&gt;Main function, declare &lt;code&gt;exp[]&lt;/code&gt; and &lt;code&gt;*e&lt;/code&gt;. Taking input from user the expression and storing it in &lt;code&gt;exp[]&lt;/code&gt; as &lt;code&gt;scanf(&amp;quot;%s &amp;quot;, exp)&lt;/code&gt;.  &lt;code&gt;%s&lt;/code&gt; is used instead of &lt;code&gt;%c&lt;/code&gt; to get the full string.&lt;/li&gt;&#xA;&lt;li&gt;No need to pass &lt;code&gt;&amp;amp;exp&lt;/code&gt; as it is an array, it automatically passes the address of starting location of the array.&lt;/li&gt;&#xA;&lt;li&gt;Assign the location of the start of expression array &lt;code&gt;exp&lt;/code&gt; to the pointer &lt;code&gt;e&lt;/code&gt; as &lt;code&gt;e = exp&lt;/code&gt;&lt;/li&gt;&#xA;&lt;li&gt;Declare another &lt;code&gt;char x&lt;/code&gt; to hold popped values in main. (Can be done in while loop also?)&lt;/li&gt;&#xA;&lt;li&gt;The beginning and assigning part is done.&lt;/li&gt;&#xA;&lt;li&gt;Start a &lt;code&gt;while()&lt;/code&gt; loop to traverse the &lt;code&gt;exp&lt;/code&gt; by incrementing the pointer as &lt;code&gt;e++&lt;/code&gt; in iteration.&lt;/li&gt;&#xA;&lt;li&gt;Condition to termination of loop is reaching the end of the &lt;code&gt;exp&lt;/code&gt; array which will have &lt;code&gt;\0&lt;/code&gt; at the end, so the condition will be &lt;code&gt;while( *e != &#39;\0&#39; )&lt;/code&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;conversion-logic&#34;&gt;Conversion Logic&lt;/h3&gt;&#xA;&lt;p&gt;As the &lt;code&gt;while&lt;/code&gt; loop runs, &lt;code&gt;e&lt;/code&gt; is incremented and it traverses the &lt;code&gt;exp&lt;/code&gt; array elements.&lt;br&gt;&#xA;&lt;code&gt;e&lt;/code&gt; points at the location within the array and &lt;code&gt;*e&lt;/code&gt; is element in that array location.&lt;/p&gt;</description>
    </item>
    <item>
      <title>04 - Postfix Expression Evaluation</title>
      <link>http://localhost:1313/personal-site/docs/c/ds_c/04-postfix-expression-evaluation/</link>
      <pubDate>Wed, 01 Jan 2025 16:00:40 +0530</pubDate>
      <guid>http://localhost:1313/personal-site/docs/c/ds_c/04-postfix-expression-evaluation/</guid>
      <description>&lt;p&gt;&lt;code&gt;isdigit()&lt;/code&gt; is needed to check the numbers, which will be available in &lt;code&gt;&amp;lt;ctype.h&amp;gt;&lt;/code&gt;&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Iterate over the expression,&lt;/li&gt;&#xA;&lt;li&gt;Put the numbers in the stack (not the binary numbers of the characters)&lt;/li&gt;&#xA;&lt;li&gt;If operators are found, pop two &lt;code&gt;int&lt;/code&gt; from the stack&lt;/li&gt;&#xA;&lt;li&gt;Assign first pop and second pop into &lt;code&gt;int&lt;/code&gt; variables.&lt;/li&gt;&#xA;&lt;li&gt;Check the operator using &lt;code&gt;switch case&lt;/code&gt; or &lt;code&gt;if else&lt;/code&gt; and solve the operation separately and push the result to stack.&lt;/li&gt;&#xA;&lt;li&gt;The last value remaining in the stack will be the result.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;logic-for-variables&#34;&gt;Logic for Variables&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;code&gt;int stack[]&lt;/code&gt; to hold the numbers pushed and popped&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;int top = -1&lt;/code&gt; to point at the top of the stack&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;char exp[]&lt;/code&gt; array to hold the expression entered&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;char *e&lt;/code&gt; a pointer to the array and traversal pointer to get the value at location and to check the end of array.&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;int conv&lt;/code&gt; to hold the converted &lt;code&gt;int&lt;/code&gt; value to be pushed to &lt;code&gt;stack&lt;/code&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;int n1, n2, n3&lt;/code&gt; to hold the two popped values and the final result to be pushed to &lt;code&gt;stack&lt;/code&gt;.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;logic-for-implementation&#34;&gt;Logic for Implementation&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;A global &lt;code&gt;int stack[]&lt;/code&gt; of fixed size and &lt;code&gt;int top = -1&lt;/code&gt; to hold values and point to index of the stack.&lt;/li&gt;&#xA;&lt;li&gt;In main function Declaring &lt;code&gt;char exp[]&lt;/code&gt; and &lt;code&gt;char *e&lt;/code&gt; to hold the expression and location of current character in the array.&lt;/li&gt;&#xA;&lt;li&gt;Taking the expression from input and passing to array, &lt;code&gt;scanf(&amp;quot;%s&amp;quot;, exp)&lt;/code&gt;&lt;/li&gt;&#xA;&lt;li&gt;Assigning the address of array starting location to the pointer, &lt;code&gt;e = exp&lt;/code&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;/li&gt;&#xA;&lt;li&gt;Declaring &lt;code&gt;int conv&lt;/code&gt; to hold converted value of the character in &lt;code&gt;*e&lt;/code&gt;&lt;/li&gt;&#xA;&lt;li&gt;Declaring &lt;code&gt;int n1, n2, n3&lt;/code&gt; to hold the values in the popped values and new result.&lt;/li&gt;&#xA;&lt;li&gt;Starting a &lt;code&gt;while&lt;/code&gt; loop to traverse through the &lt;code&gt;exp&lt;/code&gt; array while incrementing &lt;code&gt;e&lt;/code&gt;&lt;/li&gt;&#xA;&lt;li&gt;Loop ending condition when &lt;code&gt;*e == &#39;\0&#39;&lt;/code&gt;, So runs when &lt;code&gt;while ( *e != &#39;\0&#39; )&lt;/code&gt;&lt;/li&gt;&#xA;&lt;li&gt;Within the loop checking if the &lt;code&gt;*e&lt;/code&gt; is a number by passing to &lt;code&gt;isdigit()&lt;/code&gt; from &lt;code&gt;&amp;lt;ctype.h&amp;gt;&lt;/code&gt;&lt;/li&gt;&#xA;&lt;li&gt;If it is a digit, convert to &lt;code&gt;int&lt;/code&gt; by subtracting its ASCII value with &lt;code&gt;48&lt;/code&gt; as number &lt;code&gt;0&lt;/code&gt; has value of &lt;code&gt;48&lt;/code&gt;, then storing it in &lt;code&gt;conv&lt;/code&gt;&lt;/li&gt;&#xA;&lt;li&gt;Pushing &lt;code&gt;conv&lt;/code&gt; to the &lt;code&gt;stack&lt;/code&gt;.&lt;/li&gt;&#xA;&lt;li&gt;If it is not a digit, then it is an operator, then two &lt;code&gt;int&lt;/code&gt; from the stack has to be popped and operated on.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;logic-for-operation&#34;&gt;Logic for operation&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;The popped values are stored in &lt;code&gt;n1&lt;/code&gt; and &lt;code&gt;n2&lt;/code&gt;&lt;/li&gt;&#xA;&lt;li&gt;The operator is a &lt;code&gt;char&lt;/code&gt; and direct operation cannot happen.&lt;/li&gt;&#xA;&lt;li&gt;Check the character in &lt;code&gt;*e&lt;/code&gt; using &lt;code&gt;switch case&lt;/code&gt; or &lt;code&gt;if else&lt;/code&gt; and perform the relevant operation on &lt;code&gt;n2&lt;/code&gt; and &lt;code&gt;n1&lt;/code&gt;. Store result in &lt;code&gt;n3&lt;/code&gt;&lt;/li&gt;&#xA;&lt;li&gt;The resultant &lt;code&gt;n3&lt;/code&gt; is pushed into the stack.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;Once the iteration of the &lt;code&gt;exp[]&lt;/code&gt; is done, the &lt;code&gt;stack&lt;/code&gt; will have the last value which will be the result. It can be accessed as &lt;code&gt;stack[top]&lt;/code&gt; as top will be &lt;code&gt;0&lt;/code&gt; or by using &lt;code&gt;pop()&lt;/code&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>05 - Queue</title>
      <link>http://localhost:1313/personal-site/docs/c/ds_c/05-queue/</link>
      <pubDate>Wed, 01 Jan 2025 16:00:44 +0530</pubDate>
      <guid>http://localhost:1313/personal-site/docs/c/ds_c/05-queue/</guid>
      <description>&lt;h3 id=&#34;basic-logic&#34;&gt;Basic Logic&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;An array where elements are added and the first element in the array is indicated by the &lt;code&gt;head&lt;/code&gt; pointer and &lt;code&gt;tail&lt;/code&gt; represents the next place available for insertion.&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
