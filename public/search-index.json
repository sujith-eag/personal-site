[{"content":"String Operations Mention the data types in Python with an example for each. Demonstrate slicing on strings. Also, explain the use of join() and split() string methods with examples. What is a string? Discuss the different ways of representing a string in Python. Write a Python program to count the frequency of words in a string using a dictionary. Write a Python function to return the number of palindrome words in a line of text. Write a Python function to check if a string is a palindrome. The function should take \u0026ldquo;MADAM\u0026rdquo; as the default argument. It should return a Boolean value. Predict the output of the following and justify your answer: # (i) s = \u0026#34;Vishweswaraiah\u0026#34; print(s[4:]) print(s[:5]) # (ii) str1 = \u0026#34;Bangalore\u0026#34; str1[1] = \u0026#34;e\u0026#34; str1[6] = str1[8] = \u0026#34;u\u0026#34; print(str1) # (iii) a = -45 print(--a) # (iv) a, b, c = True, False, False if a or b and c: print(\u0026#34;MSRIT\u0026#34;) else: print(\u0026#34;RNSIT\u0026#34;)\rWrite a Python script to generate the third-person singular form of verbs based on the following rules: If the verb ends in y, remove it and add ies. If the verb ends in o, ch, s, sh, x, or z, add es. Otherwise, add s. String Methods Explain the usage of the following methods with examples:\n(i) extend() (ii) pop() (iii) sort() (iv) split() (v) join() Explain the use of ord() and chr() functions. Write a function that converts all uppercase letters to lowercase and vice versa in a given string.\nExample Input: I love PyTHon\nExample Output: i LOVE pYthON\nData Structures Lists, Tuples, and Sets Compare and contrast lists, tuples, and sets. List and describe any five methods on tuples. Create a list of even numbers from 1 to 10 using both a loop and the filter method. Demonstrate any four functions of lists with examples. Write a Python program to print unique elements from a list. Dictionaries How do you create and access dictionaries in Python? Explain the operations len(), copy(), clear(), and items() on dictionaries. Write a Python program to count the occurrences of a letter in a string using dictionaries. Develop a Python program to print the intersection of two lists (without using list comprehension or sets). Implement a telephone directory using dictionaries. Demonstrate any three functions of dictionaries in Python with examples. Write a Python program to create a dictionary from a list where keys are elements and values are their frequencies. Data Structure Operations Store the following data in a list, a tuple, and a dictionary: India 91\rUSA 1\rUK 41\rJapan 9\rConsider the list scores = [5, 4, 7, 3, 6, 2, 1] and write Python instructions to perform the following operations: (i) Insert an element 9 at the beginning of the list. (ii) Insert an element 8 at index position 3 of the list. (iii) Delete an element at the end of the list. (iv) Delete an element at index position 3. Data Structure Properties What do you mean by mutable and immutable data structures? Explain with examples. When you use the + operator to concatenate two lists, does it make a copy or a reference of the arguments? Explain with the help of an example. Expressions and Evaluations Evaluations Evaluate the results of the following expressions: (i) not \u0026quot;True\u0026quot; (ii) -22 % 5 (iii) \u0026quot;99\u0026quot; + 1 (iv) dir(\u0026quot;python\u0026quot;) (v) ['H', 'He', 'Li'] + 'Be' Examine the following expressions. Predict the result and explain the type of each expression. If an expression is illegal, explain why: (i) 10 / 5 (ii) 5 / 10 (iii) 5.0 / 10 (iv) 10 % 4 + 8 / 4 (v) 3 ** 10 / 3 Control Flow and Logic Explain the significance of break, continue, and pass with a suitable example.\nPredict the output of the following code snippets and justify your answers:\ni) a = -45 print(--a) ii) str1 = \u0026#39;hello\u0026#39; print(str1[-1:]) iii) a = [1, 2, 3, 4, 5, 6, 7, 8, 9] a[::2] = 10, 30, 50, 50, 90 iv) a, b, c = True, False, False if a or b and c: print(\u0026#34;MSRIT\u0026#34;) else: print(\u0026#34;RNSIT\u0026#34;)\rPredict the output of the following code snippets and justify your answers: i) 22 \u0026lt; \u0026#34;A\u0026#34; ii) i = 5 print(\u0026#34;welcome\u0026#34;) if i \u0026gt; 5 else print(\u0026#34;bye\u0026#34;) iii) [1, 2] in [0, 1, 2, 3] iv) s = \u0026#34;programming\u0026#34; print(s[5:-2]) v) ls = [34, \u0026#39;hi\u0026#39;, -5] ls.sort()\rScope and Variables Explain (or Demonstrate) the scope of local and global variables. Explain the significance of the following concepts in Python: Local and global variables DOC strings map() and reduce() functions Operators Describe Arithmetic Operators, Assignment Operators, Comparison Operators, Logical Operators, and Bitwise Operators in detail with examples. Objects and Identicality What are identical objects and equivalent objects? Provide examples. Implementation and User Input Implement a Python program to reverse a number, count the number of digits, and calculate the sum of the digits in the reversed number. Prompt the user for input. Loops and Iterative Statements Iterative Structures Illustrate the different types of iterative statements available in Python. Write a program to count the total number of digits and the sum of digits in a number using a while loop. Develop a Python program to find the sum of even numbers and odd numbers in a given list. Develop a Python program to extract the indices of even elements from a list. For Loop Applications Use a for loop to perform the following tasks (give examples for): Process characters in a string Display values and keys of a dictionary Loop over a list of lists Using a for loop, print a table of Celsius/Fahrenheit equivalences. Let c be the Celsius temperatures ranging from 0 to 100. For each value of c, print the corresponding Fahrenheit temperature. Pattern Generation Define a function that takes a positive integer n and produces n lines of output in the following pattern: +\r+ +\r+ + +\r+ + + +\r+ + + + +\rIs it possible to get the same output using a single loop? Justify.\nSpecialized Loops Write a program to display only those numbers from a list that satisfy the following conditions: The number must be divisible by five. If the number is greater than 150, skip it and move to the next number. If the number is greater than 500, stop the loop. Creative Loops Develop a Python program that reads two integer values, n and m, from the user and produces a box of size n x m. Example: Enter a width: 5 Enter a height: 4 @@@@@ @ @ @ @ @@@@@\rWhat is the output of the following code segments? Explain the causes: for letter in \u0026#39;Python\u0026#39;: if letter == \u0026#39;h\u0026#39;: break print(\u0026#39;Current Letter:\u0026#39;, letter)\rfor letter in \u0026#39;Python\u0026#39;: if letter == \u0026#39;h\u0026#39;: continue print(\u0026#39;Current Letter:\u0026#39;, letter)\rfor letter in \u0026#39;Python\u0026#39;: if letter == \u0026#39;h\u0026#39;: pass print(\u0026#39;This is pass block\u0026#39;) print(\u0026#39;Current Letter:\u0026#39;, letter)\rSpecial Implementations Design a simple calculator with different mathematical operations using a Python script. Write a Python script that takes a list of words and returns the length of the longest word using tuples. Design a Python program to find the middle number among three input numbers. Develop a Python program that will accept, as input, a series of names and salaries. Use the name ‘End’ to mark the end of the sequence of values. After the values have been entered, print the average salary and the names and salaries of those individuals with the highest and lowest salaries. ","date":"2024-12-17","id":0,"permalink":"/personal-site/docs/python/0-unit-1-2-previous-questions/","summary":"\u003ch3 id=\"string-operations\"\u003e\u003cstrong\u003eString Operations\u003c/strong\u003e\u003c/h3\u003e\n\u003col\u003e\n\u003cli\u003eMention the data types in Python with an example for each.\u003c/li\u003e\n\u003cli\u003eDemonstrate slicing on strings. Also, explain the use of \u003ccode\u003ejoin()\u003c/code\u003e and \u003ccode\u003esplit()\u003c/code\u003e string methods with examples.\u003c/li\u003e\n\u003cli\u003eWhat is a string? Discuss the different ways of representing a string in Python.\u003c/li\u003e\n\u003cli\u003eWrite a Python program to count the frequency of words in a string using a dictionary.\u003c/li\u003e\n\u003cli\u003eWrite a Python function to return the number of palindrome words in a line of text.\u003c/li\u003e\n\u003cli\u003eWrite a Python function to check if a string is a palindrome.\n\u003cul\u003e\n\u003cli\u003eThe function should take \u0026ldquo;MADAM\u0026rdquo; as the default argument.\u003c/li\u003e\n\u003cli\u003eIt should return a Boolean value.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003ePredict the output of the following and justify your answer:\u003c/li\u003e\n\u003c/ol\u003e\n\r\n\r\n\r\n\u003cdiv class=\"expressive-code\"\u003e\r\n  \u003cfigure class=\"frame not-content\"\u003e\r\n  \u003cfigcaption class=\"header\"\u003e\r\n    \u003cspan class=\"title\"\u003e\u003c/span\u003e\r\n  \u003c/figcaption\u003e\r\n  \u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-python\" data-lang=\"python\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# (i)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"n\"\u003es\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"s2\"\u003e\u0026#34;Vishweswaraiah\u0026#34;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"nb\"\u003eprint\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003es\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"mi\"\u003e4\u003c/span\u003e\u003cspan class=\"p\"\u003e:])\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"nb\"\u003eprint\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003es\u003c/span\u003e\u003cspan class=\"p\"\u003e[:\u003c/span\u003e\u003cspan class=\"mi\"\u003e5\u003c/span\u003e\u003cspan class=\"p\"\u003e])\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# (ii)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"n\"\u003estr1\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"s2\"\u003e\u0026#34;Bangalore\u0026#34;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"n\"\u003estr1\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e]\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"s2\"\u003e\u0026#34;e\u0026#34;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"n\"\u003estr1\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"mi\"\u003e6\u003c/span\u003e\u003cspan class=\"p\"\u003e]\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003estr1\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"mi\"\u003e8\u003c/span\u003e\u003cspan class=\"p\"\u003e]\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"s2\"\u003e\u0026#34;u\u0026#34;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"nb\"\u003eprint\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003estr1\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# (iii)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"n\"\u003ea\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"o\"\u003e-\u003c/span\u003e\u003cspan class=\"mi\"\u003e45\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"nb\"\u003eprint\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"o\"\u003e--\u003c/span\u003e\u003cspan class=\"n\"\u003ea\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# (iv)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"n\"\u003ea\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003eb\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003ec\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"kc\"\u003eTrue\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"kc\"\u003eFalse\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"kc\"\u003eFalse\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"k\"\u003eif\u003c/span\u003e \u003cspan class=\"n\"\u003ea\u003c/span\u003e \u003cspan class=\"ow\"\u003eor\u003c/span\u003e \u003cspan class=\"n\"\u003eb\u003c/span\u003e \u003cspan class=\"ow\"\u003eand\u003c/span\u003e \u003cspan class=\"n\"\u003ec\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\u003cspan class=\"nb\"\u003eprint\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"s2\"\u003e\u0026#34;MSRIT\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"k\"\u003eelse\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\u003cspan class=\"nb\"\u003eprint\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"s2\"\u003e\u0026#34;RNSIT\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\r\n  \u003c/figure\u003e\r\n\u003c/div\u003e\r\n\u003col start=\"8\"\u003e\n\u003cli\u003eWrite a Python script to generate the third-person singular form of verbs based on the following rules:\n\u003cul\u003e\n\u003cli\u003eIf the verb ends in \u003ccode\u003ey\u003c/code\u003e, remove it and add \u003ccode\u003eies\u003c/code\u003e.\u003c/li\u003e\n\u003cli\u003eIf the verb ends in \u003ccode\u003eo\u003c/code\u003e, \u003ccode\u003ech\u003c/code\u003e, \u003ccode\u003es\u003c/code\u003e, \u003ccode\u003esh\u003c/code\u003e, \u003ccode\u003ex\u003c/code\u003e, or \u003ccode\u003ez\u003c/code\u003e, add \u003ccode\u003ees\u003c/code\u003e.\u003c/li\u003e\n\u003cli\u003eOtherwise, add \u003ccode\u003es\u003c/code\u003e.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch4 id=\"string-methods\"\u003e\u003cstrong\u003eString Methods\u003c/strong\u003e\u003c/h4\u003e\n\u003col start=\"9\"\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003eExplain the usage of the following methods with examples:\u003c/strong\u003e\u003c/p\u003e","tags":[],"title":"0 - Unit 1 \u0026 2 Previous Questions"},{"content":"","date":"2024-12-17","id":1,"permalink":"/personal-site/docs/python/1data-types/primitive-types/","summary":"","tags":[],"title":"Primitive Data Types"},{"content":"In languages like Java, C, and others, variables are directly tied to memory allocation. A specific memory \u0026ldquo;box\u0026rdquo; is created for the variable, and the value is stored within it. If the value changes, the box is updated with the new value.\nWhen one variable is assigned to another, the value is copied into a new memory \u0026ldquo;box.\u0026rdquo;\nVariables in Python In Python, a variable is more of a reference or label rather than a direct container for data. When you assign a value to a variable, the variable is essentially given a tag (or name) that points to a particular object (value) in memory. This means the variable doesn\u0026rsquo;t directly store the data itself; it points to a location in memory where the data is stored.\nIf the value associated with a variable changes (e.g., when you reassign a new value to the variable), the variable now points to a new object, and the old value becomes a referenced object. Once the reference to the old value is lost (i.e., no variable is pointing to it), the garbage collector will eventually remove the object from memory to free up space.\nThis behavior is crucial for understanding Python’s memory management, particularly how immutable and mutable objects are handled. For example:\nImmutable objects (e.g., integers, strings, tuples) cannot be changed after they are created. When you \u0026ldquo;change\u0026rdquo; an immutable object, Python creates a new object and points the variable to this new object. Mutable objects (e.g., lists, dictionaries) can be modified in place. If you assign a mutable object to a variable and change its contents, the variable still points to the same object in memory, and the changes will be reflected in all references to that object. In summary,\nit’s better to think of variables as labels that point to values or objects, rather than traditional storage containers. When you assign one variable to another, you are simply creating another label (variable) that points to the same memory location. Both variables now refer to the same object in memory.\nRules for Variable Names Python has specific rules regarding valid variable names: Variable names can contain:\nLetters (both uppercase and lowercase) Numbers (but not at the start of the name) The underscore character (_) Examples of valid variable names:\nmy_variable name1 user_age\rVariable names cannot:\nBegin with a number (e.g., 1variable is invalid) Contain spaces (e.g., my variable is invalid) Python is case-sensitive, meaning that myVariable and myvariable are considered different variables. Reserved keywords (such as if, else, for, etc.) cannot be used as variable names, as they have predefined meanings in the language. (Note: A \u0026ldquo;traceback\u0026rdquo; refers to the detailed report that Python generates when an error occurs during the execution of your program. It shows where the error happened in your code, making it easier to debug.)\nComments in Python # Single-line comment \u0026#39;\u0026#39;\u0026#39; Multiline comment \u0026#39;\u0026#39;\u0026#39; \u0026#34;\u0026#34;\u0026#34; Multiline comment \u0026#34;\u0026#34;\u0026#34;\rTriple quotes (''' or \u0026quot;\u0026quot;\u0026quot;) are not technically multiline comments, but rather string literals that can span multiple lines. These strings are only treated as comments if they are not assigned to a variable. When unused, they are removed from memory. If used at the beginning of a function, class, or method, they are called docstrings, which are useful for documentation purposes. Constants in Python Python does not have a built-in constant type, meaning that there is no special syntax for defining constants.\nNo Built-in Constant Type: Python doesn\u0026rsquo;t enforce constants, so you can still reassign a value to a \u0026ldquo;constant\u0026rdquo; if desired. Naming Convention: Constants are typically written in all uppercase with words separated by underscores (e.g., MAX_CONNECTION, PI, TOTAL_ITEMS). Immutability by Convention: While Python doesn’t enforce immutability, constants are meant to represent values that should not be changed during the program\u0026rsquo;s execution. The convention suggests that once assigned, the constant\u0026rsquo;s value should remain unchanged. MAX_CONNECTION = 5000 PI = 3.14159 TOTAL_ITEMS = 100\rEven though Python does not prevent you from reassigning values to these constants, it’s best practice to treat them as values that should not be modified.\nPython Keywords The following keywords have a specific meaning in Python. If you try to use any of them as variable names, you will encounter an error:\nFalse await else import pass None break except in raise True class finally is return and continue for lambda try as def from nonlocal while assert del global not with async elif if or yield\rPython Built-in Functions You can use the following built-in functions as variable names, but doing so will override their behavior:\nabs() complex() hash() min() slice() aiter() delattr() help() next() sorted() all() dict() hex() object() staticmethod() any() dir() id() oct() str() anext() divmod() input() open() sum() ascii() enumerate() int() ord() super() bin() eval() isinstance() pow() tuple() bool() exec() issubclass() print() type() breakpoint() filter() iter() property() vars() bytearray() float() len() range() zip() bytes() format() list() repr() __import__() callable() frozenset() locals() reversed() chr() getattr() map() round() classmethod() globals() max() set() compile() hasattr() memoryview() setattr()\r# \u0026gt;\u0026gt;\u0026gt; import this The Zen of Python, by Tim Peters Beautiful is better than ugly. Explicit is better than implicit. Simple is better than complex. Complex is better than complicated. Flat is better than nested. Sparse is better than dense. Readability counts. Special cases aren\u0026#39;t special enough to break the rules. Although practicality beats purity. Errors should never pass silently. Unless explicitly silenced. In the face of ambiguity, refuse the temptation to guess. There should be one-- and preferably only one --obvious way to do it. Although that way may not be obvious at first unless you\u0026#39;re Dutch. Now is better than never. Although never is often better than *right* now. If the implementation is hard to explain, it\u0026#39;s a bad idea. If the implementation is easy to explain, it may be a good idea. Namespaces are one honking great idea -- let\u0026#39;s do more of those!\r","date":"2024-12-17","id":2,"permalink":"/personal-site/docs/python/1data-types/primitive-types/01-pdt-01-variables/","summary":"\u003cp\u003eIn languages like Java, C, and others, variables are directly tied to memory allocation. A specific memory \u0026ldquo;box\u0026rdquo; is created for the variable, and the value is stored within it. If the value changes, the box is updated with the new value.\u003cbr\u003e\nWhen one variable is assigned to another, the value is copied into a new memory \u0026ldquo;box.\u0026rdquo;\u003c/p\u003e","tags":[],"title":"01 PDT - 01 Variables"},{"content":"","date":"2024-10-22","id":3,"permalink":"/personal-site/docs/python/","summary":"","tags":[],"title":"Python"},{"content":"A datatype represents the type of data stored in a variable or memory location.\nBuilt-in datatypes: These are the pre-defined data types provided by Python. User-defined datatypes: These are custom data types created by programmers. Built-in Data Types The built-in data types in Python can be broadly categorized into:\nNone type Numeric types Sequences Sets Mappings None Type The None type is used to represent the absence of a value or a null value.\nNone is an object that does not contain any value, referred to as the None object. It is commonly used as a default value in functions, especially when no value is passed. In boolean expressions, None is considered False. x = None\rNumeric Types Python supports three numeric data types:\nint: Integer numbers (whole numbers, no decimals) float: Floating-point numbers (numbers with decimals) complex: Complex numbers (numbers with both real and imaginary parts) int Datatype Represents integer numbers, which are whole numbers without any decimal or fractional part. There is no limit to the size of integers in Python (only limited by the system’s memory). x = 42\rfloat Datatype Represents numbers containing a decimal point. Scientific notation can also be used for floating-point numbers (e.g., 1.5e2 represents 150.0). y = 3.14\rcomplex Datatype A complex number has both a real part and an imaginary part, written in the form a + bj where a is the real part and b is the imaginary part. The imaginary unit is represented by j, which is the square root of -1. z = 2 + 3j\rType Conversion Python automatically assigns data types to variables based on the values assigned. However, you can explicitly convert one data type to another using type conversion.\nint(x) – Converts to an integer float(x) – Converts to a float complex(x) – Converts to a complex number complex(a, b) – Converts to a complex number with real part a and imaginary part b x = int(3.14) # Converts 3.14 to 3 y = float(3) # Converts 3 to 3.0 z = complex(1, 2) # Converts to 1 + 2j\rDetermining the Datatype of a Variable In Python, you can determine the datatype of a variable using the built-in type() function. This function returns the type of the object passed to it.\ntype(variable)\ra = 15 print(type(a)) # Output: \u0026lt;class \u0026#39;int\u0026#39;\u0026gt;\rch = \u0026#39;A\u0026#39; print(type(ch)) # Output: \u0026lt;class \u0026#39;str\u0026#39;\u0026gt;\rbool Datatype The bool datatype represents boolean values. It only has two possible values:\nTrue False Internally, True is represented as 1 and False as 0.\nAn empty string (\u0026quot;\u0026quot;) is also considered False. Other empty collections (like empty lists, dictionaries, etc.) are also considered False. is_active = True is_empty = False\rSequences in Python A sequence is a group of ordered elements or items. Sequences allow for storing multiple items in a single variable, and each item in a sequence can be accessed by its index (position in the sequence).\nA sequence can contain various types of elements, including integers, strings, or other objects. For example, a sequence of integers would look like this: [1, 2, 3, 4].\nPython provides six types of sequences:\nstr (string) bytes bytearray list tuple range 1. str (String) A string is a sequence of characters enclosed in quotes (either single or double quotes). Strings are immutable, meaning once created, their contents cannot be changed. s = \u0026#34;Hello, World!\u0026#34;\r2. bytes The bytes type is a sequence of immutable byte values. Used to represent binary data (e.g., when reading from files or network protocols). b = bytes([65, 66, 67]) # Represents the byte values for \u0026#39;A\u0026#39;, \u0026#39;B\u0026#39;, \u0026#39;C\u0026#39;\r3. bytearray Similar to bytes, but mutable, meaning you can change the values of its elements. Used when you need to manipulate binary data. ba = bytearray([65, 66, 67]) # A mutable sequence of bytes ba[0] = 90 # Modify first element (from 65 -\u0026gt; 90, i.e., \u0026#39;Z\u0026#39;)\r4. list A list is an ordered, mutable collection of elements. Lists can contain elements of different data types. Lists are very flexible, as you can add, remove, and change elements. lst = [1, 2, 3, \u0026#34;apple\u0026#34;, 5.5]\r5. tuple A tuple is an ordered, immutable collection of elements. Like lists, tuples can store multiple items of different types. Once a tuple is created, its values cannot be changed (no appending or removing elements). t = (1, 2, 3, \u0026#34;apple\u0026#34;, 5.5)\r6. range The range type is a special type of sequence used for generating a sequence of numbers, often used in for loops. It represents an immutable sequence of numbers, generated on demand (i.e., it doesn’t store all the values in memory). r = range(1, 5) # Generates numbers 1, 2, 3, 4 r = range(10) # Numbers from 0 to 9 r = range(30, 40, 2) # 30 to 39, step size 2\rlst = list( range(10)) # to make a list using range\rSets in Python A set is an unordered collection of unique elements. Unlike sequences (lists, tuples), sets are unordered and do not store duplicate elements. Since it is unordered, No slicing or Indexing to retrieve the values.\nMutable: You can add or remove elements from a set after it is created. Unordered: The elements in a set do not have a specific order. No duplicates: Sets automatically remove any duplicate elements. s = {1, 2, 3, 4}\rs.update() and s.remove() are used to add and remove any particular element.\nSet Operations: Union: set1 | set2 Intersection: set1 \u0026amp; set2 Difference: set1 - set2 Symmetric Difference: set1 ^ set2 a = {1, 2, 3} b = {3, 4, 5} print(a \u0026amp; b) # Intersection: {3} print(a | b) # Union: {1, 2, 3, 4, 5} print(a - b) # Difference: {1, 2}\rMappings in Python A mapping is a collection of key-value pairs. The most common mapping type in Python is the dictionary.\nDictionaries store data in key-value pairs, where each key is unique. Mutable: You can change the value associated with a key or add/remove key-value pairs. Unordered: The key-value pairs in a dictionary are unordered, although from Python 3.7 onward, insertion order is preserved. dict (Dictionary) A dictionary is a mapping type that stores key-value pairs. The keys must be immutable (e.g., strings, numbers, tuples), while the values can be of any data type.\nd = {\u0026#34;name\u0026#34;: \u0026#34;John\u0026#34;, \u0026#34;age\u0026#34;: 30, \u0026#34;city\u0026#34;: \u0026#34;New York\u0026#34;}\rAccessing values: You access values in a dictionary using keys.\nprint(d[\u0026#34;name\u0026#34;]) # Outputs: John\rAdding or updating values:\nd[\u0026#34;age\u0026#34;] = 31 # Update value for existing key d[\u0026#34;country\u0026#34;] = \u0026#34;USA\u0026#34; # Add new key-value pair\rRemoving items:\ndel d[\u0026#34;city\u0026#34;] # Removes the key \u0026#39;city\u0026#39;\rDictionary Operations:\nkeys() – Returns a view object of all keys values() – Returns a view object of all values items() – Returns a view object of key-value pairs Example:\nprint(d.keys()) # dict_keys([\u0026#39;name\u0026#39;, \u0026#39;age\u0026#39;, \u0026#39;country\u0026#39;]) print(d.values()) # dict_values([\u0026#39;John\u0026#39;, 31, \u0026#39;USA\u0026#39;]) print(d.items()) # dict_items([(\u0026#39;name\u0026#39;, \u0026#39;John\u0026#39;), (\u0026#39;age\u0026#39;, 31), (\u0026#39;country\u0026#39;, \u0026#39;USA\u0026#39;)])\rSummary of Sets and Mappings\nSets are useful for storing a collection of unique elements, and they provide various set operations (union, intersection, etc.). Dictionaries (mappings) are key-value pair collections that are ideal for situations where you need to quickly look up data based on a unique key. ","date":"2024-12-17","id":4,"permalink":"/personal-site/docs/python/1data-types/primitive-types/01-pdt-02-datatypes/","summary":"\u003cp\u003eA \u003cstrong\u003edatatype\u003c/strong\u003e represents the type of data stored in a variable or memory location.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eBuilt-in datatypes\u003c/strong\u003e: These are the pre-defined data types provided by Python.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eUser-defined datatypes\u003c/strong\u003e: These are custom data types created by programmers.\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003ch3 id=\"built-in-data-types\"\u003eBuilt-in Data Types\u003c/h3\u003e\n\u003cp\u003eThe built-in data types in Python can be broadly categorized into:\u003c/p\u003e","tags":[],"title":"01 PDT - 02 Datatypes"},{"content":"An operator is a symbol that performs an operation on one or more operands (variables or values). Operators can be classified based on the number of operands they work with (Unary, Binary and Ternary operator) and their functionality.\nClassification Based on Nature: Arithmetic Operators Assignment Operators Unary Operators Relational Operators Logical Operators Membership Operators Identity Operators Boolean Operators Bitwise Operators 1. Arithmetic Operators Arithmetic operators are used to perform basic arithmetic operations like addition, subtraction, multiplication, etc.\nOperators: +, -, *, /, %, **, //\n+: Addition -: Subtraction *: Multiplication /: Division (returns a float) %: Modulo (returns the remainder of division) //: Floor Division (returns the quotient without the remainder) **: Exponentiation (raises the left operand to the power of the right operand) a = 10 b = 3 print(a + b) # 13 (Addition) print(a - b) # 7 (Subtraction) print(a * b) # 30 (Multiplication) print(a / b) # 3.333... (Division) print(a % b) # 1 (Modulo) print(a // b) # 3 (Floor Division) print(a ** b) # 1000 (Exponentiation)\rNote: It\u0026rsquo;s always good practice to use parentheses () to suggest the order of operations, as Python follows standard operator precedence.\n2. Assignment Operators Assignment operators are used to assign values to variables, sometimes in a shorthand way.\nOperators: =, +=, -=, *=, /=, %=, **=, //=\n=: Simple assignment +=: Add and assign (e.g., x += 1 is the same as x = x + 1) -=: Subtract and assign *=: Multiply and assign /=: Divide and assign %=: Modulo and assign **=: Exponent and assign //=: Floor division and assign x = 5 x += 3 # x = x + 3 =\u0026gt; x = 8 x *= 2 # x = x * 2 =\u0026gt; x = 16\r3. Unary Operators A unary operator operates on a single operand (value).\nUnary Minus (-) The unary minus operator negates the value of a variable (changes a positive value to negative and vice versa).\nx = 10 y = -x # y = -10\r4. Relational Operators Relational (or comparison) operators are used to compare two values. They return a boolean value (True or False).\nOperators: \u0026gt;, \u0026lt;, ==, !=, \u0026lt;=, \u0026gt;=\n\u0026gt;: Greater than \u0026lt;: Less than ==: Equal to !=: Not equal to \u0026lt;=: Less than or equal to \u0026gt;=: Greater than or equal to x = 10 y = 20 print(x \u0026lt; y) # True print(x == y) # False print(x != y) # True\rNote: Relational operators can also be chained. If any condition is False, the result will be False.\n# Example of chaining: print(5 \u0026lt; 10 \u0026lt; 20) # True print(10 \u0026lt; 5 \u0026lt; 20) # False\r5. Logical Operators Logical operators are used to combine conditional statements. They are commonly used in if statements.\nOperators: and, or, not\nand: Returns True if both operands are True or: Returns True if at least one operand is True not: Reverses the boolean value (returns True if the operand is False, and vice versa) x = True y = False print(x and y) # False print(x or y) # True print(not x) # False\r6. Membership Operators Membership operators are used to check if a value is present in a sequence (like a string, list, tuple, etc.).\nOperators: in, not in\nin: Returns True if the value is found in the sequence not in: Returns True if the value is not found in the sequence fruits = [\u0026#39;apple\u0026#39;, \u0026#39;banana\u0026#39;, \u0026#39;orange\u0026#39;] print(\u0026#39;apple\u0026#39; in fruits) # True print(\u0026#39;grapes\u0026#39; not in fruits) # True\r7. Identity Operators Identity operators are used to compare the memory locations of two objects. These operators help check if two variables point to the same object in memory.\nOperators: is, is not\nis: Returns True if both operands refer to the same object in memory is not: Returns True if both operands do not refer to the same object x = [1, 2, 3] y = [1, 2, 3] z = x print(x is y) # False (different objects in memory) print(x is z) # True (same object in memory)\rYou can also use the id() function to get the memory address of an object.\nprint(id(x)) print(id(y))\r8. Bitwise Operators Bitwise operators are used to perform bit-level operations on integers. These operations work at the binary level.\nOperators: \u0026amp;, |, ^, ~, \u0026lt;\u0026lt;, \u0026gt;\u0026gt;\n\u0026amp;: Bitwise AND |: Bitwise OR ^: Bitwise XOR ~: Bitwise NOT \u0026lt;\u0026lt;: Left shift \u0026gt;\u0026gt;: Right shift x = 5 # (binary: 0101) y = 3 # (binary: 0011) print(x \u0026amp; y) # Bitwise AND: 1 (binary: 0001) print(x | y) # Bitwise OR: 7 (binary: 0111) print(x ^ y) # Bitwise XOR: 6 (binary: 0110) print(~x) # Bitwise NOT: -6 (binary: 1010)\rArithmetic: +, -, *, /, %, //, ** Assignment: =, +=, -=, *=, /=, %= , **=, //= Unary: - (negation) Relational: \u0026gt;, \u0026lt;, ==, !=, \u0026lt;=, \u0026gt;= Logical: and, or, not Membership: in, not in Identity: is, is not Bitwise: \u0026amp;, |, ^, ~, \u0026lt;\u0026lt;, \u0026gt;\u0026gt; ","date":"2024-12-17","id":5,"permalink":"/personal-site/docs/python/1data-types/primitive-types/01-pdt-03-operators/","summary":"\u003cp\u003eAn \u003cstrong\u003eoperator\u003c/strong\u003e is a symbol that performs an operation on one or more operands (variables or values). Operators can be classified based on the number of operands they work with (Unary, Binary and Ternary operator) and their functionality.\u003c/p\u003e","tags":[],"title":"01 PDT - 03 Operators"},{"content":"Int x = 1 y = 2 z = x + y print(z)\rMaking it interactive with input()\nx = input (\u0026#34;whats x? \u0026#34;) y = input (\u0026#34;whats y? \u0026#34;) z = x + y print (z)\rAny input from keyboard is treated as a string. For input 2 and 2, output will be 22 as + is concatenating both numbers because they are treated as strings.\nint isn\u0026rsquo;t just a data type but also a function which can convert 2 from str type to int type. int() can be used to correct by converting them to integers.\nx = int(input (\u0026#34;whats x? \u0026#34;)) y = int(input (\u0026#34;whats y? \u0026#34;)) print(x+y)\rArgument moves from inner function, becomes input to outer function\nprint ( int( input(\u0026#34;whats x? \u0026#34;)) + int(input(\u0026#34;whats y? \u0026#34;)))\rOne line but very complicated and clever for its own good.\nFloat 4.1 is a float float - is any number with a decimal point\nwhen two numbers are divided, even if the result is a whole number, program always gives a float (2.0). any operation b/w float and int will be a float. large numbers can be made more readable by using _ , (1_00_00_000) python will only print the digits. Round number to a nearest digit\nround(number[, ndigits]) # [] code in square brackets means optional\rround means just one number, but if more is needed then it can be specified.\nRounding to a nearest number\nx = float (input (\u0026#34;whats x? \u0026#34;)) y = float (input(\u0026#34;whats y? \u0026#34;)) z = round ( x + y ) print (z) print ( f\u0026#34; {z:,} \u0026#34; ) # creating a f-string argument and then applying {z:,} makes the number have comma # there isnt an upper bound on how large an int can be but float can get cut off into finite digits z = round(x / y, 2) # 2 in the argument of z allows rounding to nearest 2 decimals z = x/y print ( f\u0026#34;{z:.2f}\u0026#34; ) # by converting it into an f-strinf, format string i can round the result decimal to 2\r","date":"2024-12-17","id":6,"permalink":"/personal-site/docs/python/1data-types/primitive-types/01-pdt-04-int-float/","summary":"\u003ch2 id=\"int\"\u003eInt\u003c/h2\u003e\n\r\n\r\n\r\n\u003cdiv class=\"expressive-code\"\u003e\r\n  \u003cfigure class=\"frame not-content\"\u003e\r\n  \u003cfigcaption class=\"header\"\u003e\r\n    \u003cspan class=\"title\"\u003e\u003c/span\u003e\r\n  \u003c/figcaption\u003e\r\n  \u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-python\" data-lang=\"python\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"n\"\u003ex\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"mi\"\u003e1\u003c/span\u003e  \n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"n\"\u003ey\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"mi\"\u003e2\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"n\"\u003ez\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003ex\u003c/span\u003e \u003cspan class=\"o\"\u003e+\u003c/span\u003e \u003cspan class=\"n\"\u003ey\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"nb\"\u003eprint\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ez\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\r\n  \u003c/figure\u003e\r\n\u003c/div\u003e\r\n\u003cp\u003eMaking it interactive with \u003ccode\u003einput()\u003c/code\u003e\u003c/p\u003e\n\r\n\r\n\r\n\u003cdiv class=\"expressive-code\"\u003e\r\n  \u003cfigure class=\"frame not-content\"\u003e\r\n  \u003cfigcaption class=\"header\"\u003e\r\n    \u003cspan class=\"title\"\u003e\u003c/span\u003e\r\n  \u003c/figcaption\u003e\r\n  \u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-python\" data-lang=\"python\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"n\"\u003ex\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"nb\"\u003einput\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"s2\"\u003e\u0026#34;whats x? \u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"n\"\u003ey\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"nb\"\u003einput\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"s2\"\u003e\u0026#34;whats y? \u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"n\"\u003ez\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003ex\u003c/span\u003e \u003cspan class=\"o\"\u003e+\u003c/span\u003e \u003cspan class=\"n\"\u003ey\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"nb\"\u003eprint\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ez\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\r\n  \u003c/figure\u003e\r\n\u003c/div\u003e\r\n\u003cp\u003eAny input from keyboard is treated as a string.\nFor input 2 and 2, output will be 22 as + is concatenating both numbers because they are treated as strings.\u003c/p\u003e","tags":[],"title":"01 PDT - 04 int \u0026 float"},{"content":"The str datatype represents a string, which is a sequence of characters. Strings in Python are enclosed in single quotes ('), double quotes (\u0026quot;), or triple quotes (''' or \u0026quot;\u0026quot;\u0026quot;) for multi-line strings.\nA single character is treated the same as a string of length 1. Strings are immutable: once created, they cannot be changed. String Representation Anything inside single (') or double quotes (\u0026quot;) is a string. string1 = \u0026#34;Hello, World!\u0026#34; string2 = \u0026#39;Python is awesome\u0026#39;\rYou can use one type of quote inside the other without escaping:\nstring3 = \u0026#34;He said, \u0026#39;Hello!\u0026#39;\u0026#34; string4 = \u0026#39;She replied, \u0026#34;Good morning!\u0026#34;\u0026#39;\rFor multi-line strings, use triple quotes:\nmultiline_string = \u0026#39;\u0026#39;\u0026#39;This is a string that spans multiple lines.\u0026#39;\u0026#39;\u0026#39; print(multiline_string)\rAvoiding Syntax Errors with Strings To avoid errors when using quotes within strings, you can:\nUse different quote types inside and outside: print(\u0026#34;Hello, \u0026#39;friend\u0026#39;\u0026#34;) # Using double quotes for the string print(\u0026#39;Hello, \u0026#34;friend\u0026#34;\u0026#39;) # Using single quotes for the string\rEscape quotes with a backslash (\\): print(\u0026#34;Hello, \\\u0026#34;friend\\\u0026#34;\u0026#34;) # Escape double quotes print(\u0026#39;Hitchhiker\\\u0026#39;s Guide to the Galaxy\u0026#39;) # Escape single quote\rf-strings (Formatted Strings) An f-string (formatted string) allows embedding expressions inside string literals for formatting. To use an f-string, prefix the string with an f and include expressions inside curly braces ({}).\nname = input(\u0026#34;What\u0026#39;s your name? \u0026#34;) print(f\u0026#34;Hello, {name}!\u0026#34;) # Inserts the value of \u0026#39;name\u0026#39; inside the string\rfirst = \u0026#34;John\u0026#34; last = \u0026#34;Doe\u0026#34; print(f\u0026#34;Hello, {first} {last}!\u0026#34;) # Output: Hello, John Doe!\rname = \u0026#34;john\u0026#34; print(f\u0026#34;Hello, {name.title()}!\u0026#34;) # Output: Hello, John!\rBasic String manipulation Combining two strings / Concatenation \u0026ldquo;+\u0026rdquo; \u0026ldquo;+\u0026rdquo; concatenates the two strings like a text, its just one argument\nname = input (\u0026#34;wht is \u0026#34;) print(\u0026#34;hello \u0026#34;+ name) s = \u0026#34;hello\u0026#34; t = s + \u0026#34;, there\u0026#34;\r\u0026quot; , \u0026quot; creates two arguments. The default parameters of print function adds a space between arguments.\nprint(\u0026#34;hello\u0026#34;, name)\rsep=' ' is the space between the arguments and end=\u0026quot;\\n\u0026quot; is a new line at the end.\nprint(\u0026#34;hello\u0026#34;, name, sep=\u0026#34;\u0026#34;, end=\u0026#34;\\n\\n\\n\u0026#34;)\rThis has no space and 3 extra lines.\nAdding White Space White space refers to non printing characters. Adding white space to strings with tabs or newlines \\t to add tab to the text. \\n to add a new line in a string\nprint( \u0026#34;\\tpython\u0026#34;)\rpython\r\\n \\t tells python to move to new line and start with tab space.\nprint( \u0026#34;Languages:\\nPython\\nJava\\nJava Sricpt\u0026#34; )\rPython\rJava\rJava Sricpt\rprint(\u0026#34;Continue on the\u0026#34;, end = \u0026#34; \u0026#34; ) # no new line print(\u0026#34;same line\u0026#34;, end= \u0026#34;.\\n\u0026#34;) print(\u0026#34;Next line.\u0026#34;)\rContinue on the same line.\rNext line.\rGetting to individual characters str is a sequence or list of characters. Positions are 0, 1, 2, . .n-1 for string of length n. -5, -4, -3, -2, -1 to count backwards.\nS = \u0026#34;hello\u0026#34; S[1] = \u0026#34;e\u0026#34; S[-1] = \u0026#34;o\u0026#34; S[-2] = \u0026#34;l\u0026#34;\rs = \u0026#34;hello\u0026#34; t = \u0026#34;there\u0026#34; s+t = \u0026#34;hellothere\u0026#34; len(s) # returns length of s\rExtracting Sub-strings and Slices Slice is a segment of a string.\ns = \u0026#34;hello\u0026#34; s[1:4] # is \u0026#34;ell\u0026#34; as slice stops before the last number s[:j] # starts from 0 and ends at j-1 s[i:] # i onwards till the end\rModifying strings Strings are Immutable values, We cannot update a string in place.\nThey cannot be changed directly without creating another value.\ns = \u0026#34;hello\u0026#34; # to change it to \u0026#34;help\u0026#34; s[3] = \u0026#34;p\u0026#34; # will cause error # instead, use slices and cocatination s = \u0026#34;hello\u0026#34; s = s[0:3] + \u0026#34;p!\u0026#34; s = \u0026#34;help!\u0026#34;\rRemoving a letter from index and adding to new string Using += (reverse of =+ as in int)\nmerged = \u0026#34;\u0026#34; word1 = \u0026#34;abcdef\u0026#34; merged += word1[0] merged += word1[1] # merged = \u0026#34;ab\u0026#34;\rMaking a list of individual strings from a string word1 = \u0026#34;abcdef\u0026#34; ind = list(word1) print(ind) # [\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;, \u0026#39;d\u0026#39;, \u0026#39;e\u0026#39;, \u0026#39;f\u0026#39;]\rJoining a list of strings Recombining a list of strings using a separator\nseperator.join(list of strings) columns = [\u0026#39;6\u0026#39;, \u0026#39;7\u0026#39;, \u0026#39;8\u0026#39;] # has list of strings joiningstring = \u0026#34;,\u0026#34; # this will be the seperator csline = joiningstring.join(columns) # \u0026#34;,\u0026#34;.join(columns) date = \u0026#34;16\u0026#34; month = \u0026#34;08\u0026#34; year = \u0026#34;2016\u0026#34; # the seperator can be directly given as in \u0026#34;_\u0026#34; today = \u0026#34;_\u0026#34;.join( [date, month, year]) Using of set to have unique entries Set creates a list of only unique characters, no repeats.\nword1 = \u0026#34;abababab\u0026#34; ind = set(word1) print(ind) # {\u0026#39;b\u0026#39;, \u0026#39;a\u0026#39;} returns a dict? # set doesnt provide indexing!! or any order # make a list and pass or pass str directly, gives same result\r","date":"2024-12-17","id":7,"permalink":"/personal-site/docs/python/1data-types/primitive-types/01-pdt-05-string-manipulation/","summary":"\u003cp\u003eThe \u003ccode\u003estr\u003c/code\u003e datatype represents a \u003cstrong\u003estring\u003c/strong\u003e, which is a sequence of characters. Strings in Python are enclosed in \u003cstrong\u003esingle quotes\u003c/strong\u003e (\u003ccode\u003e'\u003c/code\u003e), \u003cstrong\u003edouble quotes\u003c/strong\u003e (\u003ccode\u003e\u0026quot;\u003c/code\u003e), or \u003cstrong\u003etriple quotes\u003c/strong\u003e (\u003ccode\u003e'''\u003c/code\u003e or \u003ccode\u003e\u0026quot;\u0026quot;\u0026quot;\u003c/code\u003e) for multi-line strings.\u003c/p\u003e","tags":[],"title":"01 PDT - 05 String Manipulation"},{"content":"Method is a function that is built into a function used to perform actions on a piece of data. They are followed by a () parenthesis, as they may need additional data to work. (need to check documentation for more)\nString Methods Covered: Case Modification:\nupper(): Converts all characters to uppercase. lower(): Converts all characters to lowercase. swapcase(): Swaps case (lower to upper and vice versa). title(): Converts the first character of each word to uppercase. capitalize(): Capitalizes the first character of the string. Cleaning Strings:\nrstrip(): Removes trailing whitespace. lstrip(): Removes leading whitespace. strip(): Removes both leading and trailing whitespace. removeprefix(): Removes a specified prefix from the string. removesuffix(): Removes a specified suffix from the string. Searching for Text:\nfind(): Returns the index of the first occurrence of a substring (returns -1 if not found). index(): Similar to find(), but raises an error if the substring isn\u0026rsquo;t found. Search and Replace:\nreplace(): Replaces occurrences of a substring with a new one. Splitting Strings:\nsplit(): Splits the string into a list at each occurrence of a specified delimiter (defaults to whitespace). splitlines(): Splits the string into a list at each newline character (\\n). Resizing Strings:\ncenter(): Centers the string within a given width, padding with spaces. ljust(): Left-aligns the string within a given width, padding with spaces. rjust(): Right-aligns the string within a given width, padding with spaces. Checking Character Types:\nisalpha(): Returns True if all characters are alphabetic. isnumeric(): Returns True if all characters are numeric. Other Utility:\njoin(): Joins elements of an iterable (e.g., a list) into a single string, using the string as a separator. Changing Case The title() method capitalizes the first letter of each word.\nvariable.title() print(variable.title())\rThe . after the variable tells Python to apply the title() method on it.\nvariable.upper() variable.lower() variable.swapcase()\rlower() is useful for handling user input data, while swapcase() changes uppercase to lowercase and vice versa.\nTo adjust mis-typed spacing and capitalization in a string:\nname = name.capitalize() # Capitalizes the first letter name = name.title() # Converts to title case name = name.title().strip() # Strips leading and trailing spaces name = name.strip() # Removes spaces on both sides\rEverything in one line:\nname = input(\u0026#34;What\u0026#39;s your name? \u0026#34;).title().strip() print(f\u0026#34;Hello, {name}\u0026#34;, name, sep=\u0026#39; \u0026#39;, end=\u0026#34;\\n\u0026#34;) name = input(\u0026#34;Please type your name: \u0026#34;).strip().title()\rStripping White Space / Removing Prefix When comparing two values, extra whitespace can lead to mismatches. It\u0026rsquo;s a good idea to handle whitespace before storing data:\nvariable.rstrip() variable.lstrip() variable.strip()\rTo remove prefixes:\nurl = \u0026#39;https://nostarch.com\u0026#39; url.removeprefix(\u0026#39;https://\u0026#39;) url.removesuffix(\u0026#39;.com\u0026#39;)\rSearching for Text find(): Returns the index of the first occurrence of a substring, or -1 if not found. s.find(pattern) s.find(pattern, start, end)\rindex(): Works like find(), but raises an error if the substring is not found. s.index(pattern) s.index(pattern, start, end)\rUsing find(): text = \u0026#34;Hello, welcome to the world of Python.\u0026#34; # Find the first occurrence of \u0026#39;welcome\u0026#39; position = text.find(\u0026#34;welcome\u0026#34;) print(position) # Output: 7 (index of \u0026#39;w\u0026#39; in \u0026#39;welcome\u0026#39;) # Find a substring within a slice position = text.find(\u0026#34;world\u0026#34;, 10, 30) # Searching in the range from index 10 to 30 print(position) # Output: 20 (index of \u0026#39;w\u0026#39; in \u0026#39;world\u0026#39;)\rIf the pattern is not found, find() will return -1:\nposition = text.find(\u0026#34;Java\u0026#34;) print(position) # Output: -1 (since \u0026#39;Java\u0026#39; isn\u0026#39;t in the string)\rUsing index(): # Using index to find \u0026#39;Python\u0026#39; position = text.index(\u0026#34;Python\u0026#34;) print(position) # Output: 33 (index of \u0026#39;P\u0026#39; in \u0026#39;Python\u0026#39;) # Using index with a slice position = text.index(\u0026#34;world\u0026#34;, 10, 30) print(position) # Output: 20 (index of \u0026#39;w\u0026#39; in \u0026#39;world\u0026#39;)\rIf the pattern is not found, index() will raise an error:\ntry: position = text.index(\u0026#34;Java\u0026#34;) except ValueError: print(\u0026#34;Pattern not found!\u0026#34;) # Output: Pattern not found!\rSearch and Replace Returns a copy of s with fromstr replaced by tostr:\ns.replace(fromstr, tostr) s.replace(fromstr, tostr, n) # Replaces at most n copies\rNote: Strings are immutable, so replace() returns a new string.\nSplitting a String Split a string into substrings. For example:\nfirst, last = name.split(\u0026#34; \u0026#34;) print(f\u0026#34;Hey, {first}, How are you?\u0026#34;)\rFor CSV-like data, use a delimiter like ,:\ncolumns = s.split(\u0026#34;,\u0026#34;) # Split by comma columns = s.split(\u0026#34; : \u0026#34;, n) # Split at most n parts\rExample:\ncsline = \u0026#34;6,7,8\u0026#34; csvline.split(\u0026#34;,\u0026#34;) # [\u0026#39;6\u0026#39;, \u0026#39;7\u0026#39;, \u0026#39;8\u0026#39;]\rResizing Strings Resize strings to a specified width, using padding:\ns.center(n) # Centers string s.center(n, \u0026#34;*\u0026#34;) # Centers with stars s.ljust(n) # Left justifies string s.ljust(n, \u0026#34;*\u0026#34;) # Left justify with stars s.rjust(n) # Right justifies string s.rjust(n, \u0026#34;*\u0026#34;) # Right justify with stars\rChecking Nature of Characters in a String Check if all characters in the string are alphabetic or numeric:\ns.isalpha() # Checks if all characters are alphabetic s.isnumeric() # Checks if all characters are numeric\rjoin(): Joins elements of an iterable (e.g., a list, tuple) into a single string, using the string that calls the method as the separator.\nwords = [\u0026#39;Hello\u0026#39;, \u0026#39;world\u0026#39;, \u0026#39;Python\u0026#39;] sentence = \u0026#39; \u0026#39;.join(words) # Joins with space print(sentence) # Output: \u0026#34;Hello world Python\u0026#34; # Join with a different separator sentence = \u0026#39;-\u0026#39;.join(words) # Joins with a hyphen print(sentence) # Output: \u0026#34;Hello-world-Python\u0026#34;\r","date":"2024-12-17","id":8,"permalink":"/personal-site/docs/python/1data-types/primitive-types/01-pdt-06-string-methods/","summary":"\u003cp\u003eMethod is a function that is built into a function used to perform actions on a piece of data.\nThey are followed by a \u003ccode\u003e()\u003c/code\u003e parenthesis, as they may need additional data to work.  (need to check documentation for more)\u003c/p\u003e","tags":[],"title":"01 PDT - 06 String Methods"},{"content":"","date":"2024-12-17","id":9,"permalink":"/personal-site/docs/python/1data-types/complex-types/","summary":"","tags":[],"title":"Complex Data Types"},{"content":"Lists are collections of items arranged in a particular order. They allow you to store multiple pieces of information in a single structure.\nKey Features of Lists: Flexibility: Lists are dynamic in size and can grow or shrink as needed, providing great flexibility for managing collections of elements. Non-contiguous Memory: The values in a list are not stored in contiguous memory locations, unlike arrays, where elements are stored next to each other. This allows lists to be more efficient in certain cases where resizing is frequent. Heterogeneous Data: Elements in a list can be of different data types (unlike arrays which store elements of the same type), allowing for more varied and complex data structures. Linked Structure: Each element points to the next, which allows the list to expand and contract without requiring contiguous memory, making it easier to manipulate. Ordered: The elements in a list are maintained in a specific order, meaning the position of each element matters and can be accessed by its index. Modifications: Lists support various operations such as adding, removing, or altering elements, providing flexibility in manipulating the data structure. Operations like appending, inserting, and deleting can be performed efficiently depending on the implementation (e.g., linked list or dynamic array). Lists are represented using square brackets [], and items are separated by commas.\nfactors = [1, 2, 3, 4, 10] # List of numbers names = [\u0026#34;Anand\u0026#34;, \u0026#34;Charles\u0026#34;] # List of strings mixed = [3, True, \u0026#34;Yellow\u0026#34;] # List with mixed data types\rIt’s a good practice to make the name of a list plural, as it typically contains more than one item.\nIndex of Concepts Covered: Creating Lists: Use list() to convert iterables (strings, tuples, ranges) into lists. Accessing Elements: Positive indexing (list[0]), Negative indexing (list[-1]). Nested Lists: Lists within lists for hierarchical structures. Mutable Lists: Lists are mutable and can be updated directly. Equality vs Identity: == compares values, is compares memory references. List Slicing: list[start:stop:step] to extract sublists. Supports reverse and step slicing. Copying Lists: Use slicing [:] to copy a list. Index Errors: Out-of-range slices return empty lists, and negative indexing avoids errors. Concatenation: Use + to combine lists. f-strings: Embed list elements into strings using f-strings. Creating a List The list() function in Python is a built-in function used to create a list from other iterable data types such as tuples, strings, or sets.\nIt provides a way to convert these iterables into a list, which can be useful when you need to manipulate the data in list form.\nlist(iterable)\riterable: Any iterable object (like a string, tuple, set, or range) that you want to convert into a list. Creating a list from a string: my_string = \u0026#34;hello\u0026#34; my_list = list(my_string) print(my_list) # Output: [\u0026#39;h\u0026#39;, \u0026#39;e\u0026#39;, \u0026#39;l\u0026#39;, \u0026#39;l\u0026#39;, \u0026#39;o\u0026#39;]\rCreating a list from a tuple: my_tuple = (1, 2, 3) my_list = list(my_tuple) print(my_list) # Output: [1, 2, 3]\rCreating a list from a range: my_range = range(5) my_list = list(my_range) print(my_list) # Output: [0, 1, 2, 3, 4]\rrange(0, 10) creates a range object, not a list. To convert it into a list, use the list() function.\nUseful for generating sequences where numbers are skipped, like even numbers or multiples of a number.\neven = list(range(2, 11, 2)) # Starts from 2, adds 2 to each value, stops at 11 print(even) # Output: [2, 4, 6, 8, 10]\rAccessing Elements in Lists Lists are ordered collections, meaning you can access their items using an index. Indexing starts from 0.\n# Accessing the first item in the list print(cycles[0].title()) # Negative indexing accesses elements from the end of the list print(cycles[-1]) # Accesses the last item in the list print(cycles[-2]) # Accesses the second-last item in the list\rNested Lists Lists in Python can contain other lists, allowing for a hierarchical structure.\nnested = [[2, [37]], 4, [\u0026#34;hello\u0026#34;]] # Accessing elements within the nested list nested[0] # [2, [37]] (first element of the main list) nested[1] # 4 (second element of the main list) nested[2][0][3] # \u0026#34;l\u0026#34; (third element of the third nested list) nested[0][1:2] # [[37]] (slice of the second element in the first list)\rUpdating Lists (Mutable) Unlike strings, lists in Python are mutable, meaning you can change their contents directly.\nnested = [[2, [37]], 4, [\u0026#34;hello\u0026#34;]] nested[1] = 7 # Changes the second element of the main list # Result: nested = [[2, [37]], 7, [\u0026#34;hello\u0026#34;]] nested[0][1][0] = 19 # Changes the first value in the nested list # Result: nested = [[2, [19]], 7, [\u0026#34;hello\u0026#34;]]\rMutable vs Immutable Types Immutable types: When you assign one variable to another, a fresh copy is created. Examples include integers, floats, booleans, and strings. Mutable types: When you assign one list to another, both variables point to the same list in memory. Example for Immutable: x = 5 y = x x = 7 y == 5 # True, because y remains 5 and is unaffected by changes to x\rExample for Mutable: list1 = [1, 3, 5, 7] list2 = list1 # Both list1 and list2 refer to the same list list1[2] = 4 # Changes list1 # Now, list1 and list2 both contain [1, 3, 4, 7]\rEquality vs Identity x == y checks if the values of x and y are the same. x is y checks if x and y refer to the same object in memory. list1 = [1, 3, 5, 7] list2 = [1, 3, 5, 7] list3 = list2 list1 == list2 # True, because their values are the same list2 == list3 # True, because their values are the same list1 is list2 # False, because they are two separate objects in memory list2 is list3 # True, because list2 and list3 refer to the same object\rList Slicing in Python Slicing is used to extract a subset (sublist) from a list, similar to string slicing. The syntax is:\nlist[start:stop:step]\rstart: The index where slicing begins (inclusive). stop: The index where slicing ends (exclusive). step: The number of elements to skip between selections. Slicing Examples: 1. Basic Slicing numbers = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] sliced = numbers[2:5] print(sliced) # Output: [2, 3, 4]\r2. Slice from Start to Specific Index sliced = numbers[:4] print(sliced) # Output: [0, 1, 2, 3]\r3. Slice from a Specific Index to the End sliced = numbers[5:] print(sliced) # Output: [5, 6, 7, 8, 9]\r4. Full List Slice sliced = numbers[:] print(sliced) # Output: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\r5. Slice with a Step Size sliced = numbers[::2] print(sliced) # Output: [0, 2, 4, 6, 8]\r6. Reverse the List sliced = numbers[::-1] print(sliced) # Output: [9, 8, 7, 6, 5, 4, 3, 2, 1, 0]\r7. Slice with Step and Start/Stop sliced = numbers[1:8:2] print(sliced) # Output: [1, 3, 5, 7]\rsliced = numbers[::3] print(sliced) # Output: [0, 3, 6, 9]\rsliced = numbers[8:0:-2] print(sliced) # Output: [8, 6, 4, 2]\rList vs String Slicing Although slicing is used both in lists and strings, the behavior of slicing differs slightly.\nString slicing: Slicing a string of length 1 returns the character itself. List slicing: Slicing a list always returns a list, even if you only want one element. 1. String Slicing h = \u0026#34;hello\u0026#34; print(h[0]) # Output: \u0026#34;h\u0026#34; print(h[0:1]) # Output: \u0026#34;h\u0026#34; (Slicing returns a string of length 1)\r2. List Slicing factors = [1, 2, 3, 4, 10] print(factors[1]) # Output: 2 (Accessing element directly) print(factors[0:1]) # Output: [1] (Slicing returns a list, not a value)\rCopying Lists Using Slicing When you assign a list to a new variable, both variables refer to the same list in memory. To create a new copy of the list, you can use slicing.\nlist1 = [1, 2, 3, 4, 5] # Simple assignment (does not copy the list) list2 = list1 list1[0] = 9 print(list2) # Output: [9, 2, 3, 4, 5] (list2 is the same as list1) # Copying a list with slicing list2 = list1[:] list1[0] = 10 print(list1) # Output: [10, 2, 3, 4, 5] print(list2) # Output: [9, 2, 3, 4, 5] (list2 is a separate copy)\rFull Slice You can use the full slice [:] to create a new list, which copies all the elements from the original list.\nlist1 = [1, 2, 3, 4, 5] # Full slice list2 = list1[:] print(list2) # Output: [1, 2, 3, 4, 5] # Equivalent full slice print(list1[0:len(list1)]) # Output: [1, 2, 3, 4, 5]\rIndex Error Handling When slicing a list, if you try to access an index that doesn’t exist, Python will not throw an error. Instead, it will return an empty list or the available elements, depending on the slice.\nnumbers = [0, 1, 2, 3, 4] # Accessing an out-of-range index print(numbers[10:]) # Output: [] (returns an empty list) # Negative indices handle reverse slices print(numbers[-1]) # Output: 4 print(numbers[-2:]) # Output: [3, 4]\rUsing Lists with f-strings You can easily access elements from a list and incorporate them into an f-string to format output.\ncycles = [\u0026#34;mountain\u0026#34;, \u0026#34;road\u0026#34;, \u0026#34;hybrid\u0026#34;] # Access and format list element using f-string message = f\u0026#34;My first cycle was a {cycles[0].title()}.\u0026#34; print(message) # Output: \u0026#34;My first cycle was a Mountain.\u0026#34;\rConcatenation of Lists You can concatenate lists using the + operator, which creates a new list.\nlist1 = [1, 3, 5, 7] list2 = [4, 5, 6, 8] list3 = list1 + list2 # Creates a new list with elements of both lists # Result: list3 = [1, 3, 5, 7, 4, 5, 6, 8]\rNote: Concatenating lists with + always creates a new list. If you assign a list to another variable, they will point to the same object in memory. list1 = [1, 3, 5, 7] list2 = list1 # list2 points to the same list as list1 list1 = list1 + [9] # Creates a new list, list1 changes, list2 stays the same\rAfter concatenation:\nlist1 = [1, 3, 5, 7, 9] list2 = [1, 3, 5, 7] # list2 is unchanged\rIndex Error Attempting to access an index outside the range of the list will result in an IndexError.\nbikes = [\u0026#34;mountain\u0026#34;, \u0026#34;road\u0026#34;, \u0026#34;hybrid\u0026#34;] print(bikes[3]) # This will raise an IndexError, as the list has only 3 items\rTo avoid errors when accessing elements from the end of the list, use negative indexing (-1 for the last element, -2 for the second-last element, etc.).\nprint(bikes[-1]) # Accesses the last item in the list\r","date":"2024-12-17","id":10,"permalink":"/personal-site/docs/python/1data-types/complex-types/02-cdt-01-lists/","summary":"\u003cp\u003eLists are collections of items arranged in a particular order. They allow you to store multiple pieces of information in a single structure.\u003c/p\u003e","tags":[],"title":"02 CDT - 01 Lists"},{"content":"Index and short summary of the list methods and functions in this page:\nBasic Statistics:\nmin(): Returns the smallest value in the list. max(): Returns the largest value in the list. sum(): Returns the sum of all values in the list. Adding Elements:\nlist.append(x): Adds x to the end of the list. list.extend(iterable): Adds all elements of an iterable (e.g., list) to the list. list.insert(index, value): Inserts value at the specified index. Assigning to slice: list[start:end] = [new values]. Removing Elements:\nlist.remove(x): Removes the first occurrence of x from the list. x in list: Checks if x is present in the list. del list[index]: Removes the element at the specified index. del list[start:end]: Removes a slice of the list. list.pop(index): Removes and returns the element at the specified index (or the last item if no index is given). while x in list: list.remove(x): Removes all occurrences of x from the list. Sorting:\nlist.sort(): Sorts the list in ascending order. list.sort(reverse=True): Sorts the list in descending order. sorted(list): Returns a new sorted list without changing the original. list.reverse(): Reverses the order of the elements in the list. Other List Functions:\nlist.reverse(): Reverses the order of the list in place. list.index(x): Returns the index of the first occurrence of x. list.rindex(x): Returns the index of the last occurrence of x. list.count(x): Returns the count of occurrences of x in the list. List Length:\nlen(list): Returns the number of elements in the list. Basic Statistics Simple Statistics with a List of Numbers using min(), max(), sum()\ndigits = [1, 4, 9, 16, 25, 36, 49] # Minimum value in the list min_value = min(digits) # Output: 1 # Maximum value in the list max_value = max(digits) # Output: 49 # Sum of all values in the list total_sum = sum(digits) # Output: 140 print(f\u0026#34;Min: {min_value}, Max: {max_value}, Sum: {total_sum}\u0026#34;) # Min: 1, Max: 49, Sum: 140\rlist.append() / list.extend() / list.insert() Adding elements to a list in place can be done using append(), extend(), or insert(). These methods modify the list directly without creating a new one.\nappend() adds a single element to the end of the list. extend() adds all elements from another iterable (like a list) to the end of the list. insert() allows you to add an element at any specified index. append() list1.append(x)\rAdds a single element x to the end of the list list1.\nlist1 = [1, 3, 5] list1.append(7) # Output: [1, 3, 5, 7]\rlist1 = [1, 3, 5, 6] list2 = list1 list1.append(22) # Both list1 and list2 will be updated to: # [1, 3, 5, 6, 22]\rextend() list1.extend(list2)\rAdds all elements from list2 to list1. This is similar to: list1 = list1 + list2.\nlist1 = [1, 3, 5] list2 = [7, 8] list1.extend(list2) # Output: [1, 3, 5, 7, 8]\rinsert() motorcycles.insert(index, value)\rInserts value at the specified index in the list, shifting the other elements to the right.\nmotorcycles = [\u0026#39;yamaha\u0026#39;, \u0026#39;honda\u0026#39;] motorcycles.insert(0, \u0026#39;ducati\u0026#39;) # Output: [\u0026#39;ducati\u0026#39;, \u0026#39;yamaha\u0026#39;, \u0026#39;honda\u0026#39;]\rAssigning values to a slice: list1 = [1, 3, 5, 6] list2 = list1 list1[2:] = [7, 8] # Both list1 and list2 will be updated to: # [1, 3, 7, 8]\rExpanding and Shrinking Lists: Replacing a slice of the list with new values, which can expand or shrink the list.\nlist1 = [1, 3, 7, 8] list1[2:] = [9, 10, 11, 12] # Output: [1, 3, 9, 10, 11, 12] # 7, 8 are replaced by 9, 10, 11, 12\rlist1[0:3] = [7] # Output: [7, 11, 12] # The first three elements are replaced with [7]\rlist.remove() / del / list.pop() Methods to remove elements from a list in Python. Removing by value, by index, or simply popping off an element from the end.\nremove(x): Removes the first occurrence of x from the list. pop(): Removes and returns the last element (or element at a specified index) from the list. del: Removes an element by index or removes a slice of the list. remove() - Removing Values from a List Removes the first occurrence of x in the list.\nlist.remove(x)\rIf x is not found, it raises a ValueError.\nBefore removing, check if the value exists to avoid a ValueError.\nChecking if a Value Exists in a List Using in to check if an element exists in the list. It returns True if the element is found.\nx in list # Returns True if x is in the list\rSafely Removing a Value\nif x in list: list.remove(x)\rRemoving All Occurrences of x\nUsing a while loop to remove all instances of x from the list. while x in list: list.remove(x)\rexpensive = \u0026#39;ducati\u0026#39; motorcycles = [\u0026#39;honda\u0026#39;, \u0026#39;yamaha\u0026#39;, \u0026#39;ducati\u0026#39;, \u0026#39;harley\u0026#39;] motorcycles.remove(\u0026#39;ducati\u0026#39;) # Removes the first occurrence of \u0026#39;ducati\u0026#39; motorcycles.remove(expensive) # Removes \u0026#39;ducati\u0026#39; again, as it\u0026#39;s stored in the variable print(f\u0026#34;\\nA {expensive.title()} is too expensive for me.\u0026#34;) # Output: A Ducati is too expensive for me.\rdel - Removing Items by Index The del statement removes an item by its index, and also delete entire slices of the list.\ndel list[index] # Removes the item at the specified index\rdel motorcycles[0] # Removes the first item from the list\rDeleting a Slice : deletes a range of elements using slicing.\ndel list[start:end] # Removes the slice from index start to index end-1\rpop() The pop() method removes and returns the last item in the list. This is useful to access the element after removing it.\nlast_item = list.pop()\rRemoving from a Specific Index\nIndex can be specified to pop an element from any position in the list. first_owned = motorcycles.pop(0) # Pops the first item from the list\rbikes = motorcycles.pop() # Pops the last item of \u0026#39;motorcycles\u0026#39; and assigns it to \u0026#39;bikes\u0026#39; print(f\u0026#34;Removed {bikes} from motorcycles\u0026#34;)\rSorting Sorting a List permanently with the sort() function, sorting them alphabetically.\ncars.sort() cars.sort(reverse=True) # reverse sorting\rSorting a list temporarily with sorted() function. sorted() function lets you display your list in a particular order but doesn\u0026rsquo;t affect the actual order of the list.\ncars = [\u0026#39;bmw\u0026#39;, \u0026#39;audi\u0026#39;, \u0026#39;toyota\u0026#39;, \u0026#39;subaru\u0026#39;] print(sorted(cars)) # values will be sorted print(cars) # the values will be in same order\rPrinting in reverse order. it doesn\u0026rsquo;t sort backward alphabetically, it just reverses the order of the list changes the order permanently.\ncars.reverse()\rFinding the Length of a List using len() function\nlen(cars) # 4\rOther List Functions l.reverse()\nReverses the order of elements in the list in place. l.reverse() # Reverses the list\rl.index(x)\nReturns the first index of the value x in the list. Raises ValueError if not found. l.index(x) # Finds the first occurrence of x in the list\rl.rindex(x)\nReturns the last index of the value x in the list. Raises ValueError if not found. l.rindex(x) # Finds the last occurrence of x in the list\rl.count(x)\nReturns the count of occurrences of x in the list. l.count(x) # Counts how many times x appears in the list\r","date":"2024-12-17","id":11,"permalink":"/personal-site/docs/python/1data-types/complex-types/02-cdt-02-list-methods/","summary":"\u003cp\u003eIndex and short summary of the list methods and functions in this page:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003eBasic Statistics:\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003emin()\u003c/code\u003e: Returns the smallest value in the list.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003emax()\u003c/code\u003e: Returns the largest value in the list.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003esum()\u003c/code\u003e: Returns the sum of all values in the list.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003eAdding Elements:\u003c/strong\u003e\u003c/p\u003e","tags":[],"title":"02 CDT - 02 List Methods"},{"content":"Operations on lists for x in l: x = f(x) def applylist(f,l): for x in l: x = f(x)\rmap( ) Built in function to apply something to all the elements of l. map(f, l) applies f to each element of l (entire list) output of map(f, l) is not a list but a sequence like range(i, j) and dict.keys( )\nSo for i in map(f, l): can be used for iterating it can be made into a list by using list() as list(map(f, l))\nfilter( ) filter(p, l) checks p property for each element of l, output will be a sub-list of values that satisfy p.\nSelecting a sub-list in a list using filter( )\nprimelist = [] for i in numberlist: if isprime(i): # checking if i is prime primelist.append(i) # appending if True return(primelist)\rIn general, def select(property, l): sublist = [] for x in l: if property(x): sublist.append(x) return(sublist) # property is a function that returns True or False for each element Combining map() and filter() # sum of squares of even numbers from 0 to 99 def square(x): return( x*x ) def is_even(x): return(x%2 == 0) list ( map( square, filter (is_even, range(100 ))))\rFilter even numbers from 0 to 100\rapply square to these numbers\rmade into a list\rsum can be made using the list\rList comprehension Pythagorean triple: x^2 + y^2 = z^2 All Pythagorean triples (x, y, z) with values below n\n{(x, y, z) | 1\u0026lt;= x, y, z \u0026lt;=n , x^2 + y^2 = z^2} in x, y, z (such that) x, y, z lie b/w 1 and n, and x^2 + y^2 = z^2. In set theory, this is called \u0026ldquo;set comprehension\u0026rdquo; building a new set from existing sets, this can be extended to lists\n# square of even numbers below 100 [square(x) for i in range(100) if is_even(x)] map generator filter\rthis is how a sub-list is made without using the words map or filter.\nPythagorean triples with x,y,z below 100\n[ (x,y,z) for x in range(100) for y in range (100) for z in range (100) if x*x + y*y = z*z] #Order of x,y,z is like a nested loop, so the generator can be for x in range(100): for y in range(100): for z in range(100): # this will produce copies (3,4,5) and (4,3,5) and values with 0 which isnt a triangle # Change the generator such that later generator depends on the earlier ones print ([ (x,y,z) for x in range(1,100) # x starts from 1 for y in range(x,100) # y is not less than x for z in range(y,100) # z is not less than y if x*x + y*y == z*z ] )\r(x, y, z) is mapping for x, y, z are generators if ___ is filter\noutput\r[(3, 4, 5), (5, 12, 13), (6, 8, 10), (7, 24, 25), (8, 15, 17), (9, 12, 15), (9, 40, 41), (10, 24, 26), (11, 60, 61), (12, 16, 20), (12, 35, 37), (13, 84, 85), (14, 48, 50), (15, 20, 25), (15, 36, 39), (16, 30, 34), (16, 63, 65), (18, 24, 30), (18, 80, 82), (20, 21, 29), (20, 48, 52), (21, 28, 35), (21, 72, 75), (24, 32, 40), (24, 45, 51), (24, 70, 74), (25, 60, 65), (27, 36, 45), (28, 45, 53), (30, 40, 50), (30, 72, 78), (32, 60, 68), (33, 44, 55), (33, 56, 65), (35, 84, 91), (36, 48, 60), (36, 77, 85), (39, 52, 65), (39, 80, 89), (40, 42, 58), (40, 75, 85), (42, 56, 70), (45, 60, 75), (48, 55, 73), (48, 64, 80), (51, 68, 85), (54, 72, 90), (57, 76, 95), (60, 63, 87), (65, 72, 97)]\rInitializing a matrix Shortcuts to make n x n matrix\n# 1st r = [[0] * n for _ in range(n)] # 2nd for _ in range(0,n): r.append([0]*n)\rmatrix of 4 x 3, 4 rows 3 columns\nl = [ [0 for i in range(3)] for j in range(4) ] # the outer (for) is for each row, the inner for is something that is done #output l = [ [0,0,0], [0,0,0], [0,0,0], [0,0,0] ]\rWrong method because, each first index got changed as each row is a same list (zerolist)\nzerolist = [0 for i in range(3)] l = [ zerolist for j in range(4)] l[1][1] = 7 l = [0,7,0],[0,7,0],[0,7,0],[0,7,0]\r","date":"2024-12-17","id":12,"permalink":"/personal-site/docs/python/1data-types/complex-types/02-cdt-03-list-operators/","summary":"\u003ch2 id=\"operations-on-lists\"\u003eOperations on lists\u003c/h2\u003e\n\r\n\r\n\r\n\u003cdiv class=\"expressive-code\"\u003e\r\n  \u003cfigure class=\"frame not-content\"\u003e\r\n  \u003cfigcaption class=\"header\"\u003e\r\n    \u003cspan class=\"title\"\u003e\u003c/span\u003e\r\n  \u003c/figcaption\u003e\r\n  \u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-python\" data-lang=\"python\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"k\"\u003efor\u003c/span\u003e \u003cspan class=\"n\"\u003ex\u003c/span\u003e \u003cspan class=\"ow\"\u003ein\u003c/span\u003e \u003cspan class=\"n\"\u003el\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"n\"\u003ex\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003ef\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ex\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"k\"\u003edef\u003c/span\u003e \u003cspan class=\"nf\"\u003eapplylist\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ef\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\u003cspan class=\"n\"\u003el\u003c/span\u003e\u003cspan class=\"p\"\u003e):\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"k\"\u003efor\u003c/span\u003e \u003cspan class=\"n\"\u003ex\u003c/span\u003e \u003cspan class=\"ow\"\u003ein\u003c/span\u003e \u003cspan class=\"n\"\u003el\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"n\"\u003ex\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003ef\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ex\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\r\n  \u003c/figure\u003e\r\n\u003c/div\u003e\r\n\u003ch3 id=\"map-\"\u003e\u003ccode\u003emap( )\u003c/code\u003e\u003c/h3\u003e\n\u003cp\u003eBuilt in function to apply something to all the elements of \u003ccode\u003el\u003c/code\u003e.\n\u003ccode\u003emap(f, l)\u003c/code\u003e applies \u003ccode\u003ef\u003c/code\u003e to each element of \u003ccode\u003el\u003c/code\u003e (entire list)\noutput of \u003ccode\u003emap(f, l)\u003c/code\u003e is not a list but a sequence like \u003ccode\u003erange(i, j)\u003c/code\u003e and \u003ccode\u003edict.keys( )\u003c/code\u003e\u003c/p\u003e","tags":[],"title":"02 CDT - 03 List Operators"},{"content":"Arrays vs. Lists in Python Python offers two primary ways to store a collection of data: arrays and lists. While they may seem similar, they have key differences in how they are implemented, how they behave, and their performance characteristics.\nArrays Arrays in Python are represented using the array module or more commonly, the numpy library, and they have distinct features:\nKey Characteristics: Fixed Size: The size of an array is fixed in advance. Once created, the number of elements cannot be changed unless the array is resized, which involves creating a new array.\nHomogeneous Elements: Arrays only store elements of the same type. This means they are much more memory-efficient than lists, as the data is tightly packed and does not require additional information for each element.\nMemory Layout: Arrays are stored in a continuous block of memory. This makes them very efficient for random access, as accessing any element by index takes constant time (O(1)), regardless of the element\u0026rsquo;s position in the array.\nInsertion and Deletion: Inserting or deleting elements in the middle of an array is expensive because the elements after the insertion or deletion point need to be shifted to accommodate the new element or close the gap. This takes linear time (O(n)).\nPerformance:\nAccessing an element: Accessing an element by index (arr[i]) takes constant time, as arrays provide random access. The time to access any element is the same, whether it\u0026rsquo;s the first or the last element. Insertion/Deletion: Inserting or deleting elements, especially in the middle, requires shifting elements, which results in a linear time complexity (O(n)). Example of Creating an Array: import array # Create an array of integers arr = array.array(\u0026#39;i\u0026#39;, [1, 2, 3, 4, 5]) print(arr[2]) # Output: 3 # Append an element to the end of the array arr.append(6) # Insert an element at a specific position arr.insert(2, 10) # Insert 10 at index 2\rLists Python lists are more flexible and commonly used in Python programming. However, their performance differs significantly from arrays in certain areas.\nKey Characteristics: Dynamic Size: Lists are dynamic, meaning they can grow or shrink in size as needed. This is achieved by allocating extra space in memory when the list is created.\nHeterogeneous Elements: Unlike arrays, lists can store elements of different types, including integers, strings, and even other lists. This provides more flexibility, but it comes at the cost of efficiency in memory storage.\nMemory Layout: Lists are not stored in a contiguous block of memory like arrays. Instead, they use pointers to the objects stored in memory, which allows for dynamic resizing but results in more overhead.\nPerformance:\nAccessing an element: Accessing an element by index (lst[i]) is constant time (O(1)), similar to arrays. Insertion/Deletion: While inserting or deleting at the end of the list is generally constant time (O(1)), inserting or deleting elements at other positions takes linear time (O(n)), as elements need to be shifted. Example of Creating a List: # Create a list with mixed types lst = [1, \u0026#34;hello\u0026#34;, 3.14, [1, 2, 3]] print(lst[1]) # Output: hello # Append an element to the end of the list lst.append(\u0026#34;world\u0026#34;) # Insert an element at a specific position lst.insert(2, \u0026#34;inserted\u0026#34;)\rPerformance Considerations When comparing the performance of lists and arrays, it\u0026rsquo;s important to understand their strengths and weaknesses:\n1. Access Time: Arrays: Accessing elements is constant time (O(1)), no matter where the element is in the array. Lists: Accessing elements is also constant time (O(1)), as the list maintains a dynamic structure, but it may have additional overhead due to the use of pointers. 2. Insertion/Deletion: Arrays: Inserting or deleting elements in an array, especially in the middle, is expensive. It requires shifting all subsequent elements, which results in linear time complexity (O(n)). Lists: Inserting or deleting elements at the end of a list is constant time (O(1)), but insertion/deletion at other positions takes linear time (O(n)), as elements need to be shifted. 3. Memory Usage: Arrays: More memory-efficient as they store elements of the same type in a contiguous block of memory. Lists: Lists are less memory-efficient because they store pointers to the actual objects, which adds overhead. When to Use Lists vs. Arrays Use Arrays when:\nYou need efficient memory usage and fast access to elements by index. You are working with numerical data and need to perform mathematical operations. You need a fixed-size collection of elements with a known type (e.g., numerical data). Use Lists when:\nYou need a flexible collection that can store mixed data types. You need dynamic resizing and frequent additions/removals of elements. You are not concerned with the performance of insertion or deletion at arbitrary positions. Feature Arrays Lists Size Fixed (in most cases) Dynamic (can grow or shrink) Element Type Homogeneous (all elements must be of the same type) Heterogeneous (different types allowed) Memory Layout Contiguous block of memory Pointers to objects in non-contiguous memory Access Time O(1) (constant time) O(1) (constant time) Insertion/Deletion O(n) (linear time) O(1) at the end, O(n) elsewhere Use Cases Numerical data, fixed-size collections Mixed data types, dynamic collections Numpy Arrays for More Complex Operations While Python\u0026rsquo;s built-in arrays are efficient for basic tasks, for more advanced operations like matrix manipulation or handling large datasets, the numpy library provides a powerful alternative.\nNumpy Array Features: Numpy arrays are homogeneous, just like Python arrays, and provide a more compact memory layout and efficient processing. Numpy supports vectorized operations, which allow you to perform operations on entire arrays or matrices without explicit loops. Example of Creating a Numpy Array: import numpy as np # Create a 3x3 matrix of zeros matrix = np.zeros((3, 3)) print(matrix) # Create a matrix from a nested list matrix = np.array([[0, 1], [1, 0]]) print(matrix) # Use arange to generate a range of values row2 = np.arange(5) # Output: [0 1 2 3 4] print(row2)\rMatrix Operations in Numpy: Numpy provides support for matrix operations such as multiplication and addition, which are optimized and more efficient than using nested lists.\nA = np.array([[1, 2], [3, 4]]) B = np.array([[5, 6], [7, 8]]) # Matrix addition C = A + B print(C) # Output: [[ 6 8] [10 12]] # Matrix multiplication C = np.dot(A, B) print(C) # Output: [[19 22] [43 50]]\rArrays are more useful for representing matrices (to represent graphs) In list notation, these are nested lists [ [0,1], [1,0] ]\n# list comprehension zeromatrix = [ [ 0 for i in range(3)] for j in range(3) ] # This is the way of making matrix using lists, no direct way\rThe Numpy library provides arrays as a basic type\nInport numpy as np zeromatrix = np.zero(shape = (3,3)) # can create an array from any sequence type newarray = np.array( [ [0,1], [1,0]]) # arange is the equivalent of range for lists row2 = np.arange(5) # can operate on a matrix as a whole C = 3*A + B C = np.matmu(A,B) # matmu is matrix multiplication\r","date":"2024-12-17","id":13,"permalink":"/personal-site/docs/python/1data-types/complex-types/02-cdt-04-list-vs-arrays/","summary":"\u003ch3 id=\"arrays-vs-lists-in-python\"\u003eArrays vs. Lists in Python\u003c/h3\u003e\n\u003cp\u003ePython offers two primary ways to store a collection of data: \u003cstrong\u003earrays\u003c/strong\u003e and \u003cstrong\u003elists\u003c/strong\u003e. While they may seem similar, they have key differences in how they are implemented, how they behave, and their performance characteristics.\u003c/p\u003e","tags":[],"title":"02 CDT - 04 List Vs Arrays"},{"content":"A tuple is similar to a list in that it contains a collection of elements, which can be of different types. However, unlike lists, tuples are immutable, meaning that once a tuple is created, its elements cannot be modified. This makes tuples read-only sequences, unlike lists, which are mutable.\nElements in a tuple are separated by commas and enclosed in parentheses (). tpl = (1, 2, 3, \u0026#34;apple\u0026#34;, 4.5)\rKey Characteristics of Tuples: Immutable: Once a tuple is created, you cannot change its elements. This makes it a read-only sequence. Example: tpl[0] = 10 would raise an error because you can\u0026rsquo;t modify a tuple\u0026rsquo;s elements. Heterogeneous Elements: A tuple can contain elements of different types, just like a list. tpl = (23, \u0026#34;Kamal\u0026#34;, [2, 3, 5, 7])\rAccessing Elements: You can access and extract values from a tuple using indexing (with square brackets) or slicing. tpl = (1, 2, 3, \u0026#34;apple\u0026#34;, 4.5) print(tpl[1]) # Output: 2 print(tpl[-1]) # Output: 4.5 (negative index counts from the end)\rSlicing: Just like lists, tuples support slicing to extract parts of the tuple. tpl = (1, 2, 3, \u0026#34;apple\u0026#34;, 4.5) print(tpl[1:3]) # Output: (2, 3) print(tpl[-2:]) # Output: (\u0026#34;apple\u0026#34;, 4.5)\rMultiplying Tuples: Tuples can be repeated using the multiplication operator *. tpl = (1, 2, 3) print(tpl * 2) # Output: (1, 2, 3, 1, 2, 3)\rSimultaneous Assignment: Tuples are often used in Python for simultaneous assignment, where multiple variables can be assigned values from a tuple in a single statement. age, name, primes = 23, \u0026#34;Kamal\u0026#34;, [2, 3, 5, 7]\rThis is very similar to using a list, but tuples are typically used when the values should remain constant.\nTuple of Values: You can assign a tuple of values to a variable, which is useful for grouping related data. point = (3.5, 4.8) # Tuple with two values date = (16, 7, 2023) # Tuple representing a date\rExtracting Values from Tuples: You can extract individual values or slices from a tuple. xcoordinate = point[0] # Output: 3.5 monthyear = date[1:] # Output: (7, 2023)\rUse Cases for Tuples: Data Integrity: Use tuples when you want to ensure that the data remains unchanged, as tuples cannot be modified once created. Multiple Return Values: Functions often use tuples to return multiple values. def get_coordinates(): return (3.5, 4.8) x, y = get_coordinates()\rPerformance: Since tuples are immutable, they are generally faster than lists for iteration and storage. ","date":"2024-12-17","id":14,"permalink":"/personal-site/docs/python/1data-types/complex-types/02-cdt-05-tuples/","summary":"\u003cp\u003eA \u003cstrong\u003etuple\u003c/strong\u003e is similar to a list in that it contains a collection of elements, which can be of different types. However, unlike lists, \u003cstrong\u003etuples are immutable\u003c/strong\u003e, meaning that once a tuple is created, its elements cannot be modified. This makes tuples \u003cstrong\u003eread-only\u003c/strong\u003e sequences, unlike lists, which are mutable.\u003c/p\u003e","tags":[],"title":"02 CDT - 05 Tuples"},{"content":"A set is an unordered collection of unique elements. Unlike sequences (such as lists or tuples), sets are unordered and do not store duplicate elements. Since sets are unordered, they do not support indexing, slicing, or other sequence-like behavior.\nKey Characteristics of Sets: Mutable: You can add or remove elements from a set after it is created. Unordered: The elements in a set do not have a specific order, and you cannot access elements by index. No duplicates: Sets automatically remove any duplicate elements, ensuring that all elements are unique. Example of creating a set:\ns = {1, 2, 3, 4}\rAdding and Removing Elements set.update() The update() method is used to add multiple elements to a set. You can pass any iterable (e.g., a list, tuple, or another set) to the update() method, and it will add all the elements from the iterable to the set.\nNote: update() does not add duplicates to the set, as sets do not allow duplicate elements.\nExample:\n# Creating a set s = {1, 2, 3} # Adding multiple elements using update s.update([4, 5, 6]) print(s) # Output: {1, 2, 3, 4, 5, 6} # Adding elements from another set s.update({7, 8}) print(s) # Output: {1, 2, 3, 4, 5, 6, 7, 8} # Adding elements from a tuple s.update((9, 10)) print(s) # Output: {1, 2, 3, 4, 5, 6, 7, 8, 9, 10}\rset.remove() The remove() method is used to remove a specific element from the set. If the element is not found, it raises a KeyError.\nExample:\n# Creating a set s = {1, 2, 3, 4, 5} # Removing an element using remove s.remove(3) print(s) # Output: {1, 2, 4, 5} # Trying to remove an element that does not exist raises an error # s.remove(10) # Uncommenting this will raise: KeyError: 10\rset.discard() The discard() method is similar to remove(), but it does not raise an error if the element does not exist in the set. This makes it a safer option if you\u0026rsquo;re unsure whether the element is in the set.\nExample:\n# Using discard to remove an element (does not raise an error if the element is not found) s.discard(10) # Does nothing since 10 is not in the set print(s) # Output: {1, 2, 4, 5}\rSummary of Methods: update(): Adds multiple elements to the set (from an iterable). Example: s.update([4, 5, 6]) remove(): Removes a specific element from the set. Raises a KeyError if the element doesn\u0026rsquo;t exist. Example: s.remove(3) discard(): Removes a specific element from the set, but does not raise an error if the element doesn\u0026rsquo;t exist. Example: s.discard(10) Set Operations Python provides a variety of operations to perform set-related tasks. Here are some of the most common set operations:\nUnion (|) : set1 | set2 Combines two sets, returning all unique elements from both sets. Intersection (\u0026amp;) : set1 - set2 Returns only the elements that are present in both sets. Difference (-) : set1 - set2 Returns the elements that are in the first set but not in the second set. Symmetric Difference (^) : set1 ^ set2 Returns elements that are in either of the sets, but not in both. a = {1, 2, 3} b = {3, 4, 5} # Intersection: Elements present in both sets print(a \u0026amp; b) # Output: {3} # Union: All unique elements from both sets print(a | b) # Output: {1, 2, 3, 4, 5} # Difference: Elements in \u0026#39;a\u0026#39; but not in \u0026#39;b\u0026#39; print(a - b) # Output: {1, 2} # Symmetric Difference: Elements in either \u0026#39;a\u0026#39; or \u0026#39;b\u0026#39;, but not both print(a ^ b) # Output: {1, 2, 4, 5}\rSets in Python are unordered collections of unique elements. They are useful when you need to ensure that no duplicates exist in your collection. You can add and remove elements using methods like update(), remove(), and discard(). Set operations such as union, intersection, and difference allow you to easily manipulate and compare sets. Sets are commonly used for operations like checking membership, removing duplicates, and performing mathematical set operations.\n","date":"2024-12-17","id":15,"permalink":"/personal-site/docs/python/1data-types/complex-types/02-cdt-06-sets/","summary":"\u003cp\u003eA \u003cstrong\u003eset\u003c/strong\u003e is an unordered collection of unique elements. Unlike sequences (such as lists or tuples), sets are \u003cstrong\u003eunordered\u003c/strong\u003e and do not store duplicate elements. Since sets are unordered, they do not support indexing, slicing, or other sequence-like behavior.\u003c/p\u003e","tags":[],"title":"02 CDT - 06 Sets"},{"content":"Dictionary is a collection of key-value pairs. each key is connected to a value, and key can be used to access a value. It is wrapped in {} , key connected to value by colon : , and each key-value pair is separated by , a = {\u0026quot;colour\u0026quot; : \u0026quot;green\u0026quot;, \u0026quot;points\u0026quot; : 5 }\nDictionary A list l = [13, 24, 54, 77, 33]\rValues are associated to positions {0,1,2,3,4}, so 0,1,2,3,4 are keys which can be used to access corresponding values. But no specific key can be defined other than these, which are auto assigned.\ntest1 = {} test1 [\u0026#34;dhawan\u0026#34;] = 84 test1 [\u0026#34;Pujara\u0026#34;] = 16\rDictionaries, allows keys other than range(0,n),\tKey could be any immutable values (int, float, bool, string, tuple), it cannot be (list, dict), they can be updated in place like lists. (called dictionaries in python, associative array in other languages)\nEmpty dictionary is {}, not [] which is a list, test1 = () is empty tuple\nAdding new key-value pairs. To add a new key-value pair, give the name of the dict folowed by new key in [] along with new value.\na[\u0026#34;x\u0026#34;] = 0 a[\u0026#34;y\u0026#34;] = 25 a = {\u0026#34;colour\u0026#34;:\u0026#34;green\u0026#34;, \u0026#34;points\u0026#34;:5, \u0026#34;x\u0026#34;:0, \u0026#34;y\u0026#34;:25} # starting with an empty dictionary and then adding each new item to it a = {}\rNested dictionaries\n# there can be multiple keys for a given value score = {} score[\u0026#34;Test1\u0026#34;] = {} score[\u0026#34;Test2\u0026#34;] = {} score[\u0026#34;Test1\u0026#34;][\u0026#34;Dhawan\u0026#34;] = 84 score[\u0026#34;Test1\u0026#34;][\u0026#34;Kohli\u0026#34;] = 200 score[\u0026#34;Test2\u0026#34;][\u0026#34;Dhawan\u0026#34;] = 50 print(score) # simplified score = { \u0026#34;Test1\u0026#34;: { \u0026#34;Dhawan\u0026#34;:84, \u0026#34;Kohli\u0026#34;:200}, \u0026#34;Test2\u0026#34;:{ \u0026#34;Dhawan\u0026#34;: 50 } }\rUsing get() to Access Value\nget() method can be used to set a default value if the requested key doesn\u0026rsquo;t exist. It requires a key as first argument, a second optional argument if key doesn\u0026rsquo;t exist.\nIf there is a chance that the value you might be asking doesn\u0026rsquo;t exist, use get() Even if second value is left blank, \u0026ldquo;None\u0026rdquo; will be returned, indicating absence of value\npoint = a.get(\u0026#39;points\u0026#39;, \u0026#39;No point value assigned\u0026#39;) Looping through a Dictionary items() Looping through all key-value pairs We can loop through all the dict key-value pairs through its keys or values. using for loop for dict, create two variables to store keys and values. with dict name followed by method items()\nuser = { k:v, k1:v1 } for key, value in user.items() user_0 = { \u0026#34;username\u0026#34;: \u0026#34;efron\u0026#34;, \u0026#34;first\u0026#34;: \u0026#34;enric\u0026#34;, \u0026#34;Last\u0026#34;: \u0026#34;fermi\u0026#34; } for key, value in user_0.items(): print(f\u0026#34;\\nKey: {key}\u0026#34;) print(f\u0026#34;Value: {value}\u0026#34;)\rfav_lang = { \u0026#34;jen\u0026#34;: \u0026#34;Python\u0026#34;, \u0026#34;sarah\u0026#34;: \u0026#34;C\u0026#34;, \u0026#34;edward\u0026#34;:\u0026#34;rust\u0026#34;, \u0026#34;phil\u0026#34;: \u0026#34;python\u0026#34;} for name, lang in fav_lang.items(): print(f\u0026#34;{name}\u0026#39;s favorite language is {lang}.\u0026#34;)\rkeys() Looping through all keys for name in fav_lang.keys(): is same as for name in fav_lang: because looping through keys is default when for is applied to a dict.\nfav_lang = { \u0026#34;jen\u0026#34;: \u0026#34;Python\u0026#34;, \u0026#34;sarah\u0026#34;: \u0026#34;C\u0026#34;, \u0026#34;edward\u0026#34;:\u0026#34;rust\u0026#34;, \u0026#34;phil\u0026#34;: \u0026#34;python\u0026#34;} for name in fav_lang: # for name in fav_lang.keys(): does same print(f\u0026#34;{name} took our survey.\u0026#34;)\rfav_lang = { \u0026#34;jen\u0026#34;: \u0026#34;Python\u0026#34;, \u0026#34;sarah\u0026#34;: \u0026#34;C\u0026#34;, \u0026#34;edward\u0026#34;:\u0026#34;rust\u0026#34;, \u0026#34;phil\u0026#34;: \u0026#34;python\u0026#34;} friends = [\u0026#34;phil\u0026#34;, \u0026#34;jen\u0026#34;] for name in fav_lang: print(f\u0026#34;Hi, {name}\u0026#34;) if name in friends: lang = fav_lang[name] # print(f\u0026#34;{name}, I see you love {fav_lang[name]}\u0026#34;) print(f\u0026#34;{name}, I see you love {lang}\u0026#34; )\rLooping through keys in a particular order Getting all the keys sorted by passing list to sorted.\nfor name in sorted(fav_lang.keys()): Looping through values in dict \u0026raquo;\u0026gt; for lang in fav_lang.values():\nfav_lang = { \u0026#34;jen\u0026#34;: \u0026#34;python\u0026#34;, \u0026#34;sarah\u0026#34;: \u0026#34;C\u0026#34;, \u0026#34;edward\u0026#34;:\u0026#34;rust\u0026#34;, \u0026#34;phil\u0026#34;: \u0026#34;python\u0026#34;} print(\u0026#34;The following languages have been mentioned\u0026#34;) for lang in fav_lang.values(): print(lang)\rset() is a collection in which each item must be unique, wrapping set() around a collection of values, python takes the unique items and forms a set.\nfav_lang = { \u0026#34;jen\u0026#34;: \u0026#34;python\u0026#34;, \u0026#34;sarah\u0026#34;: \u0026#34;C\u0026#34;, \u0026#34;edward\u0026#34;: \u0026#34;rust\u0026#34;, \u0026#34;phil\u0026#34;: \u0026#34;python\u0026#34;} print(\u0026#34;The following languages have been mentioned\u0026#34;) for lang in set(fav_lang.values()): print(lang) # wrapping set() around fav_lang.values() to get only uniqu values\rE = { \u0026#39;apple\u0026#39; : 10, \u0026#34;banana\u0026#34; : 5, \u0026#34;orange\u0026#34;:15, \u0026#34;grapes\u0026#34;:20 } # Find the fruit with the maximum key based on alphabetical order max_key = \u0026#34;\u0026#34; for fruit in E: if fruit \u0026gt; max_key: max_key = fruit max_value = E[fruit] print(\u0026#34;Max key:\u0026#34;, max_key) # Output: grapes print(\u0026#34;Max value:\u0026#34;, max_value) # Output: 20 # Check if 12 is a value in the dictionary print(12 in E.values()) # Output: False # Convert the dictionary values to a list and sort in descending order value_list = list(E.values()) value_list.sort(reverse=True) # Corrected reverse argument print(\u0026#34;Second largest value:\u0026#34;, value_list[1]) # Output: 15\rNesting Nesting is storing multiple dictionaries in a list, or list of items in dictionary, or dicts in dict.\nali_0 = {} ali_1 = {} ali_2 = {} alie = [ali_0, ali_1, ali_2] for ali in alie: print(ali) # will print each dictionary Making a empty list and populating it Using range() to create a fleet of 30 aliens\naliens = [] for ali in range(30): new_alien = {\u0026#34;colour\u0026#34;:\u0026#34;green\u0026#34;, \u0026#34;points\u0026#34;: \u0026#34;5\u0026#34;, \u0026#34;speed\u0026#34;:\u0026#34;slow\u0026#34; } aliens.append(new_alien)\rMaking 3 alien in the list change color, speed and points. Looping through only 3 and then changing all values for the keys\nfor a in aliens[:3]: if a[\u0026#34;colour\u0026#34;] == \u0026#34;green\u0026#34;: a[\u0026#34;colour\u0026#34;] = \u0026#34;yellow\u0026#34; a[\u0026#34;speed\u0026#34;] = \u0026#34;medium\u0026#34; a[\u0026#34;points\u0026#34;] = 10 # to make any yellow aliens to red, elif a[\u0026#34;colour\u0026#34;] == \u0026#34;yelow\u0026#34;: a[\u0026#34;colour\u0026#34;] = \u0026#34;red\u0026#34; a[\u0026#34;speed\u0026#34;] = \u0026#34;fast\u0026#34; a[\u0026#34;points\u0026#34;] = 15 for ali in aliens: print(ali)\rA list in a dictionary Pizza order\npizza = { \u0026#34;crust\u0026#34;:\u0026#34;thick\u0026#34;, \u0026#34;toppings\u0026#34;: [\u0026#34;mushroom\u0026#34;, \u0026#34;extra cheese\u0026#34;] } print(f\u0026#34;You have ordered a {pizza[\u0026#39;crust\u0026#39;]} crust pizza. \\nWith the following toppings \u0026#34; ) for top in pizza[\u0026#34;toppings\u0026#34;]: print(f\u0026#34;\\t{top}\u0026#34;) # print(top) would have worked but adding tab with \\t needs f string\rFavorite language\nfav_lang = { \u0026#39;jen\u0026#39;: [\u0026#39;python\u0026#39;, \u0026#39;rust\u0026#39;], \u0026#39;sarah\u0026#39;: [\u0026#39;c\u0026#39;], \u0026#39;edward\u0026#39;: [\u0026#39;rust\u0026#39;, \u0026#39;go\u0026#39;], \u0026#39;phil\u0026#39;: [\u0026#39;python\u0026#39;, \u0026#39;haskell\u0026#39;], } # i just divided getting the value for name in fav_lang: print(f\u0026#34;{name}\u0026#39;s favorite languages are:\u0026#34;) for lang in fav_lang[name]: # i used fav_lang.values, but it is a list there are no values or keys print(f\u0026#34;\\t{lang}\u0026#34;) # it could have been just at a time process for name, lang in fav_lang.items(): print(f\u0026#34;{name}\u0026#39;s favorite values are:\u0026#34;) for l in lang: print(f\u0026#34;\\t{l}\u0026#34;)\rRefining the singular plural grammar issue fav_lang = { \u0026#39;jen\u0026#39;: [\u0026#39;python\u0026#39;, \u0026#39;rust\u0026#39;], \u0026#39;sarah\u0026#39;: [\u0026#39;c\u0026#39;], \u0026#39;edward\u0026#39;: [\u0026#39;rust\u0026#39;, \u0026#39;go\u0026#39;], \u0026#39;phil\u0026#39;: [\u0026#39;python\u0026#39;, \u0026#39;haskell\u0026#39;], } for name, lang in fav_lang.items(): if len(lang) == 1: print( f\u0026#34;{name.title()}\u0026#39;s favorite language is:\u0026#34;) print(f\u0026#34;\\t{lang[0].title()}\u0026#34;) else: print(f\u0026#34;{name.title()}\u0026#39;s favorite languages are:\u0026#34;) for l in lang: print(f\u0026#34;\\t{l.title()}\u0026#34;)\rA dictionary in dictionary users = { \u0026#39;aeinstein\u0026#39;: {\u0026#39;first\u0026#39;: \u0026#39;albert\u0026#39;, \u0026#39;last\u0026#39;: \u0026#39;einstein\u0026#39;, \u0026#39;location\u0026#39;: \u0026#39;princeton\u0026#39;,} , \u0026#39;mcurie\u0026#39;: {\u0026#39;first\u0026#39;: \u0026#39;marie\u0026#39;, \u0026#39;last\u0026#39;: \u0026#39;curie\u0026#39;, \u0026#39;location\u0026#39;: \u0026#39;paris\u0026#39;,} , } for user, data in users.items(): print ( f\u0026#34;\\nUsername: {user}\u0026#34;) print ( f\u0026#34;\\tFull Name: {data[\u0026#39;first\u0026#39;].title()} {data[\u0026#39;last\u0026#39;].title()}\u0026#34;) print ( f\u0026#34;\\tLocation: {data[\u0026#39;location\u0026#39;].title()}\u0026#34;) # just another way for user, data in users.items(): print ( f\u0026#34;\\nUsername: {user}\u0026#34;) full_name = f\u0026#34;{data[\u0026#34;first\u0026#34;].title()} {data[\u0026#39;last\u0026#39;].title()}\u0026#34; location = f\u0026#34;{data[\u0026#39;location\u0026#39;].title()}\u0026#34; print(f\u0026#34;\\tFull Name: {full_name}\\n\\tLocation: {location}\u0026#34;)\rCS50 Associates a value with another value, like words and meanings in a dictionary. having multiple lists [] isn\u0026rsquo;t practical.\nstudents = { } # empty dictionary keys : values # : is the separator\rlist[] have numbers to index into them, but dict{} allows the actual words to be used as Indies to get their values. To get Draco values, we can use Draco as the key\nstudents = { \u0026#34;Harry\u0026#34; : \u0026#34;Gryffindor\u0026#34;, \u0026#34;Hermione\u0026#34; : \u0026#34;gryffindor\u0026#34;, \u0026#34;Draco\u0026#34; : \u0026#34;Slytherin\u0026#34; } print(students[\u0026#34;Hermione\u0026#34;]) print(students[\u0026#34;Draco\u0026#34;]) for student in students: print(student) # by default the dic{} only the keys are read so only names are displayed for student in students: print(student, students[student], sep=\u0026#34;, \u0026#34;) # students[student] is using the name as key to get the associated value\rList of Dict Keyword \u0026ldquo;None\u0026rdquo; with capital N, which represents absence of value, All dict{} are given same key words but different values, by design keys are standardized to find things easily.\nstudents = [ {\u0026#34;name\u0026#34;: \u0026#34;Hermione\u0026#34;, \u0026#34;house\u0026#34;: \u0026#34;Gryffindor\u0026#34;, \u0026#34;patronus\u0026#34;:\u0026#34;Otter\u0026#34; }, {\u0026#34;name\u0026#34;: \u0026#34;Harry\u0026#34;, \u0026#34;house\u0026#34;: \u0026#34;Gryffindor\u0026#34;, \u0026#34;patronus\u0026#34;: \u0026#34;Stag\u0026#34; }, {\u0026#34;name\u0026#34;: \u0026#34;Ron\u0026#34;, \u0026#34;house\u0026#34;: \u0026#34;Gryffindor\u0026#34;, \u0026#34;patronus\u0026#34;: \u0026#34;Terrier\u0026#34; }, {\u0026#34;name\u0026#34;: \u0026#34;Draco\u0026#34;, \u0026#34;house\u0026#34;: \u0026#34;Slytherin\u0026#34;, \u0026#34;patronus\u0026#34;: None} ] for student in students: print(student[\u0026#34;name\u0026#34;], student[\u0026#34;house\u0026#34;], student[\u0026#34;patronus\u0026#34;], sep=\u0026#34;, \u0026#34;) # using print(students[\u0026#34;name\u0026#34;]) will give a str, but it must be int # \u0026#34;for\u0026#34; will get first value which is dict{} 0, to student # print(student[\u0026#34;name\u0026#34;]) will get the value of key word \u0026#34;name\u0026#34;\rProcessing a Dictionary Extracting keys using d.keys() It returns sequence of keys in dictionary d ( in random order). d.key is not a list, it is similar to range. To make a list of keys, list(d.keys())\nfor k in d.keys(): # some process d[k] # d.keys() will not be in any perticular order for k in sorted(d.keys()): # returns in predictible order # process d[k] sorted(l) # returns a sorted copy of l, so doesnt modify l l.sort() # sorts l in place\rExtracting Values from dictionary\nd.values() # is a sequence of values in d total = 0 for s in test1.values(): total = total + s\rTesting if value is in dict uising \u0026ldquo;in\u0026rdquo; function. Assigning to an unknown key inserts an entry or updates if key already exists.\nd = {} d[0] = 7 # then d == {0:7} l = [] l[0] = 7 # causes IndexError\rCourse Implementing a dictionary A dictionary is implimented as a hash table an array plus a hash function The underlying storage is an array given an offset i, find A[i] in constant time keys have to be mapped to {0,1,. . ., n-1} given an key k, convert it to an offset i Hash function h: S--\u0026gt; X maps a set of values S to a small range of integers X = {0,1,..,n-1} typically |X|\u0026lt;\u0026lt;|S|, so there will be collisions, h(s) = h(s\u0026#39;), s != s\u0026#39; a good hash function will minimize collisions SHA-256 is an industry standatd hashing function whose range is 256 bits use to hash large files ","date":"2024-12-17","id":16,"permalink":"/personal-site/docs/python/1data-types/complex-types/02-cdt-07-dictinaries/","summary":"\u003cp\u003eDictionary is a collection of key-value pairs. each key is connected to a value, and key can be used to access a value.\nIt is wrapped in \u003ccode\u003e{}\u003c/code\u003e ,  key connected to value by colon \u003ccode\u003e:\u003c/code\u003e , and each key-value pair is separated by \u003ccode\u003e,\u003c/code\u003e\n\u003ccode\u003ea = {\u0026quot;colour\u0026quot; : \u0026quot;green\u0026quot;, \u0026quot;points\u0026quot; : 5 }\u003c/code\u003e\u003c/p\u003e","tags":[],"title":"02 CDT - 07 Dictinaries"},{"content":"Print() The print() function in Python is used to output data to the console. It can accept multiple arguments and display them in various formats.\nprint(*objects, sep=\u0026#39; \u0026#39;, end=\u0026#39;\\n\u0026#39;, file=sys.stdout, flush=False)\robjects: The values to be printed, separated by commas. sep: The separator between the objects. Default is a space ' '. end: The string appended at the end of the output. Default is a newline '\\n'. file: The output is directed to this file object (default is sys.stdout). flush: If True, the output is flushed immediately (default is False). Key Parameters sep (Separator) sep is used to specify a separator between multiple values in the print function. By default, it is a space ' ', but you can change it to any string you want. Example:\nprint(\u0026#34;apple\u0026#34;, \u0026#34;banana\u0026#34;, \u0026#34;cherry\u0026#34;, sep=\u0026#34;, \u0026#34;) # Output: apple, banana, cherry\rend end is used to append a string after the printed output. By default, it is '\\n' (a newline character), which means the next output will appear on a new line. You can modify this to print everything on the same line or add any custom string. Example:\nprint(\u0026#34;Hello\u0026#34;, end=\u0026#34; \u0026#34;) print(\u0026#34;world!\u0026#34;) # Output: Hello world!\rf-strings (Formatted Strings) f-strings (formatted string literals) allow embedding expressions inside string literals using curly braces {}. Introduced in Python 3.6, f-strings provide an easy and efficient way to embed variable values into strings. Example:\nname = \u0026#34;Alice\u0026#34; age = 30 print(f\u0026#34;My name is {name} and I am {age} years old.\u0026#34;) # Output: My name is Alice and I am 30 years old.\rYou can also apply formatting options to the variables inside f-strings:\nExample:\npi = 3.14159265358979 print(f\u0026#34;Pi to 2 decimal places: {pi:.2f}\u0026#34;) # Output: Pi to 2 decimal places: 3.14\rInput() The input() function is used to take input from the user via the console. It always returns a string, so if you need a different data type, you\u0026rsquo;ll need to explicitly cast the value.\nuser_input = input(\u0026#34;Prompt message: \u0026#34;)\rPrompt message: A message that is displayed to the user before waiting for input. Getting Multiple Inputs You can get multiple inputs from the user using split() to split the input string into a list based on a delimiter.\nExample:\n# Getting multiple inputs name, age = input(\u0026#34;Enter your name and age: \u0026#34;).split() print(f\u0026#34;Name: {name}, Age: {age}\u0026#34;)\rIn this case, the user would input a string like Alice 25, and the values would be split into the name and age variables.\nType Casting Since input() always returns a string, you might need to cast the input to another data type (like int, float, etc.).\nExample:\nage = int(input(\u0026#34;Enter your age: \u0026#34;)) # Convert the string to an integer print(f\u0026#34;Next year, you\u0026#39;ll be {age + 1} years old.\u0026#34;)\rSimilarly, for floating-point numbers:\nheight = float(input(\u0026#34;Enter your height in meters: \u0026#34;)) # Convert to float\rUsing eval() The eval() function can evaluate a string as a Python expression. It allows you to execute more complex expressions or mathematical formulas input by the user. Be cautious when using eval() since it can execute arbitrary code, which may be unsafe if you\u0026rsquo;re not in control of the input.\nExample:\nresult = eval(input(\u0026#34;Enter a mathematical expression: \u0026#34;)) print(f\u0026#34;The result is: {result}\u0026#34;)\rIf the user enters 5 + 3, the output would be The result is: 8.\nCommand-Line Arguments Python allows you to pass command-line arguments to your script, which can be accessed using the sys.argv list. This is useful for passing configuration or input data to your program when running it from the command line.\nUsing sys.argv Importing sys: To use sys.argv, you need to import the sys module.\nsys.argv: This is a list containing all the command-line arguments passed to the Python script, where sys.argv[0] is the script name itself.\nExample:\nimport sys # Print all arguments passed to the script print(f\u0026#34;Arguments passed to the script: {sys.argv}\u0026#34;) # Access individual arguments if len(sys.argv) \u0026gt; 1: print(f\u0026#34;First argument: {sys.argv[1]}\u0026#34;)\rCommand-Line Argument Example: Run the Python script from the terminal:\npython script.py arg1 arg2 arg3\rOutput:\nArguments passed to the script: [\u0026#39;script.py\u0026#39;, \u0026#39;arg1\u0026#39;, \u0026#39;arg2\u0026#39;, \u0026#39;arg3\u0026#39;]\rFirst argument: arg1\rlen(sys.argv) len(sys.argv) returns the number of arguments passed to the script, including the script name. This can be used to check if enough arguments are provided.\nExample:\nimport sys if len(sys.argv) \u0026lt; 2: print(\u0026#34;Usage: python script.py \u0026lt;arg1\u0026gt; \u0026lt;arg2\u0026gt; ...\u0026#34;) else: print(f\u0026#34;Received arguments: {sys.argv[1:]}\u0026#34;)\r","date":"2024-12-17","id":17,"permalink":"/personal-site/docs/python/03-print-and-input/","summary":"\u003ch2 id=\"print\"\u003e\u003cstrong\u003ePrint()\u003c/strong\u003e\u003c/h2\u003e\n\u003cp\u003eThe \u003ccode\u003eprint()\u003c/code\u003e function in Python is used to output data to the console. It can accept multiple arguments and display them in various formats.\u003c/p\u003e","tags":[],"title":"03 - Print and Input"},{"content":"","date":"2025-01-25","id":18,"permalink":"/personal-site/docs/python/4control_statements/","summary":"","tags":[],"title":"Python Control Statements"},{"content":"Control Flow Statements in Python if if...else if...elif...else These are the primary structures for controlling the flow of execution based on conditions.\nwhile – Used to repeat a block of code based on a condition. for – Used to repeat a block of code a fixed number of times. else – Executes code when the preceding condition is not true. break – Exits the loop immediately. continue – Skips the rest of the current loop iteration and moves to the next iteration. pass – Does nothing; used as a placeholder. assert – Used for debugging purposes to test if a condition is true. return – Exits a function and optionally returns a value. Note: Python does not have a switch case statement. but match case is introduced in python 3.10\nAltering Control Flow if, elif, else – Conditional execution of code blocks based on boolean expressions. for loop – Used to repeat code a fixed number of times, often iterating over a sequence (like a list or range). while loop – Repeats a block of code as long as a specified condition is true. Conditional Execution Python allows you to track conditions efficiently with boolean expressions (True or False). Some examples include:\nif m % n != 0: # This executes only if m % n != 0 is True (m, n) = (n, m % n)\rAlternating Execution (using else):\nif m % n != 0: (m, n) = (n, m % n) else: gcd = n # Optional else branch\rIn Python, certain values are treated as False in boolean contexts:\nNumeric value 0 Empty sequences: \u0026quot;\u0026quot;, [] For example, the expression if m % n will be True if there is a remainder, and False if the remainder is 0.\nChecking Membership You can check if a value is in or not in a sequence (like a list or string):\nCheck if a value is in a list: \u0026#34;Mushroom\u0026#34; in some_list\rCheck if a value is not in a list: if user not in banned_users: print(f\u0026#34;{user.title()}, you can post a response.\u0026#34;)\rTypes of if Statements Simple if statement – A single condition with one action when the condition is true: if condition: # action\rif...else statement – Takes one action if the condition is true, and a different one if it\u0026rsquo;s false: if condition: # action 1 else: # action 2\rif...elif...else chain – Used when more than two possible outcomes need to be considered. Python checks each condition in order, and once one condition is true, it skips the rest: if condition1: # action 1 elif condition2: # action 2 else: # action 3\rif...if...if chain – Checks all conditions, even if one of them is true. Each if is independent: if condition1: # action 1 if condition2: # action 2 if condition3: # action 3\rMulti-way Branching When you have multiple conditions to check, nested if statements can become hard to read. Here’s an example with nested if statements:\nif x == 1: y = f1(x) else: if x == 2: y = f2(x) else: if x == 3: y = f3(x) else: y = f4(x)\rThis is difficult to follow. A cleaner way is using elif to avoid unnecessary nesting:\nif x == 1: y = f1(x) elif x == 2: y = f2(x) elif x == 3: y = f3(x) else: y = f4(x)\rUsing if Statements with Lists You can check for special values and ensure that a list is not empty. When the name of a list is used in an if statement, Python returns True if the list contains at least one item.\nrequest = [] if request: for _ in request: print(f\u0026#34;Adding {_}.\u0026#34;) else: print(\u0026#34;You want something?\u0026#34;)\rUsing Multiple Lists: Checking and Comparing Two Lists You can compare two lists to check if items are present in both.\nhaving = [\u0026#34;apple\u0026#34;, \u0026#34;banana\u0026#34;, \u0026#34;cherry\u0026#34;] ordered = [\u0026#34;apple\u0026#34;, \u0026#34;grape\u0026#34;, \u0026#34;cherry\u0026#34;] for item in ordered: if item in having: print(f\u0026#34;Adding {item}\u0026#34;) else: print(f\u0026#34;Sorry, we don\u0026#39;t have {item}\u0026#34;)\rCS50 Conditionals Conditions allow you to take different paths based on boolean expressions (Yes or No).\nExample 1: Basic Comparison x = int(input(\u0026#34;What is x? \u0026#34;)) y = int(input(\u0026#34;What is y? \u0026#34;)) if x \u0026lt; y: print(\u0026#34;x is less than y\u0026#34;) if x \u0026gt; y: print(\u0026#34;x is greater than y\u0026#34;) if x == y: print(\u0026#34;x is equal to y\u0026#34;)\rEven if the first condition is true, Python will execute all the lines asking three questions.\nExample 2: Using elif to Avoid Unnecessary Checks Using elif helps avoid executing unnecessary conditions after one is found to be true:\nif x \u0026lt; y: print(\u0026#34;x is less than y\u0026#34;) elif x \u0026gt; y: print(\u0026#34;x is greater than y\u0026#34;) elif x == y: print(\u0026#34;x is equal to y\u0026#34;)\rUsing else with if The else statement is used to handle the case where none of the previous conditions were true.\nif x \u0026lt; y: print(\u0026#34;x is less than y\u0026#34;) elif x \u0026gt; y: print(\u0026#34;x is greater than y\u0026#34;) else: print(\u0026#34;x is equal to y\u0026#34;)\rUsing or for Multiple Conditions The or operator can be used to combine multiple conditions into one line:\nif x \u0026gt; y or x \u0026lt; y: print(\u0026#34;x is not equal to y\u0026#34;) else: print(\u0026#34;x is equal to y\u0026#34;)\rAlternatively, you can use != to simplify the condition:\nif x != y: print(\u0026#34;x is not equal to y\u0026#34;) else: print(\u0026#34;x is equal to y\u0026#34;)\rUsing Multiple if Statements When you use multiple if statements (instead of elif), each condition is checked independently, and all true conditions will result in executed code:\nscore = int(input(\u0026#34;Score: \u0026#34;)) if score \u0026gt;= 90: print(\u0026#34;Grade: A\u0026#34;) if score \u0026gt;= 80: print(\u0026#34;Grade: B\u0026#34;) if score \u0026gt;= 70: print(\u0026#34;Grade: C\u0026#34;) else: print(\u0026#34;Grade: F\u0026#34;)\rChecking for Even or Odd Numbers (Parity) You can use the modulus operator (%) to determine if a number is even or odd. An even number divided by 2 leaves a remainder of 0.\nExample: if x % 2 == 0: print(\u0026#34;x is even\u0026#34;) else: print(\u0026#34;x is odd\u0026#34;)\rUsing Boolean Functions A boolean function returns True or False and can be used in if statements for conditions.\nExample: def is_even(n): if n % 2 == 0: return True else: return False def main(): x = int(input(\u0026#34;What is x? \u0026#34;)) if is_even(x): # Calls the is_even function print(\u0026#34;Even\u0026#34;) else: print(\u0026#34;Odd\u0026#34;)\rAlternatively, you can simplify the function to return the result directly:\ndef is_even(n): return n % 2 == 0 def main(): x = int(input(\u0026#34;What is x? \u0026#34;)) if is_even(x): # Directly checks if the result is True print(\u0026#34;Even\u0026#34;) else: print(\u0026#34;Odd\u0026#34;)\rSimplifying Multiple if Conditions with or Instead of checking for multiple conditions with multiple if statements, you can combine conditions into one line using or:\nname = input(\u0026#34;What is your name? \u0026#34;) if name == \u0026#34;Harry\u0026#34; or name == \u0026#34;Hermione\u0026#34; or name == \u0026#34;Ron\u0026#34;: print(\u0026#34;Gryffindor\u0026#34;) elif name == \u0026#34;Draco\u0026#34;: print(\u0026#34;Slytherin\u0026#34;) else: print(\u0026#34;Who?\u0026#34;)\r","date":"2025-01-25","id":19,"permalink":"/personal-site/docs/python/4control_statements/04-control-flow-01-conditional-branching/","summary":"\u003ch3 id=\"control-flow-statements-in-python\"\u003eControl Flow Statements in Python\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e\u003ccode\u003eif\u003c/code\u003e\u003c/strong\u003e\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e\u003ccode\u003eif...else\u003c/code\u003e\u003c/strong\u003e\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e\u003ccode\u003eif...elif...else\u003c/code\u003e\u003c/strong\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThese are the primary structures for controlling the flow of execution based on conditions.\u003c/p\u003e","tags":[],"title":"04 Control-Flow - 01 Conditional Branching"},{"content":"match Statement in Python introduced in Python 3.10\nThe match statement allows you to compare a variable against different patterns and execute corresponding code blocks. much like the switch statement in other languages.\nmatch: Used to compare the variable against different patterns. case: Each potential pattern the variable could match. _: The wildcard pattern, acting as a default case if no other pattern matches. This feature is useful for matching complex data structures and handling various cases in a more readable way than using multiple if statements.\nSyntax: match variable: case pattern1: # block of code if pattern1 matches case pattern2: # block of code if pattern2 matches case _: # block of code if no pattern matches (default case)\rExample: name = input(\u0026#34;What is your name? \u0026#34;) match name: case \u0026#34;Harry\u0026#34;: print(\u0026#34;Gryffindor\u0026#34;) case \u0026#34;Hermione\u0026#34;: print(\u0026#34;Gryffindor\u0026#34;) case \u0026#34;Draco\u0026#34;: print(\u0026#34;Slytherin\u0026#34;) case _: # Default case print(\u0026#34;Who?\u0026#34;)\rGryffindor (if the name is Harry or Hermione)\rSlytherin (if the name is Draco)\rWho? (if the name is something else)\rUsing the | (OR) Operator in match Cases The | (vertical bar) can be used to match multiple patterns (like an \u0026ldquo;OR\u0026rdquo; operator).\nname = input(\u0026#34;What is your name? \u0026#34;) match name: case \u0026#34;Harry\u0026#34; | \u0026#34;Hermione\u0026#34; | \u0026#34;Ron\u0026#34;: print(\u0026#34;Gryffindor\u0026#34;) case \u0026#34;Draco\u0026#34;: print(\u0026#34;Slytherin\u0026#34;) case _: # Default case print(\u0026#34;Who?\u0026#34;)\rGryffindor (if the name is Harry, Hermione, or Ron)\rSlytherin (if the name is Draco)\rWho? (if the name is something else)\rMatching Complex Data Structures You can use match to handle complex data structures, such as tuples:\ndef describe_shape(shape): match shape: case (\u0026#34;circle\u0026#34;, radius): print(f\u0026#34;A circle with radius {radius}\u0026#34;) case (\u0026#34;rectangle\u0026#34;, width, height): print(f\u0026#34;A rectangle with width {width} and height {height}\u0026#34;) case _: print(\u0026#34;Unknown shape\u0026#34;) describe_shape((\u0026#34;circle\u0026#34;, 5)) describe_shape((\u0026#34;rectangle\u0026#34;, 4, 7)) describe_shape((\u0026#34;triangle\u0026#34;, 3)) # Output: # A circle with radius 5 # A rectangle with width 4 and height 7 # Unknown shape\r","date":"2025-01-25","id":20,"permalink":"/personal-site/docs/python/4control_statements/04-control-flow-02-match-case/","summary":"\u003cp\u003e\u003ccode\u003ematch\u003c/code\u003e Statement in Python introduced in \u003ccode\u003ePython 3.10\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003eThe \u003ccode\u003ematch\u003c/code\u003e statement allows you to compare a variable against different patterns and execute corresponding code blocks. much like the \u003ccode\u003eswitch\u003c/code\u003e statement in other languages.\u003c/p\u003e","tags":[],"title":"04 Control-Flow - 02 Match-Case"},{"content":"The range() function generates a sequence of numbers, commonly used for looping or generating lists with specific patterns.\nrange(i, j) Generates a sequence of numbers starting from i and ending before j. range(i, j) # Produces the sequence: i, i+1, ..., j-1\rrange(j) Starts from 0 and ends before j. This is equivalent to range(0, j). range(j) # Like slice(:j), starts from 0, ends at j-1\rIncrement with range(): range(i, j, k)\nAdds an optional third argument k for defining the step increment, useful for sequences with a specific pattern, like arithmetic progressions (AP). range(i, j, k) # Produces: i, i+k, i+2k, ..., i+nk\rReverse Counting: To count in reverse, use a negative value for k. Ensure i \u0026gt; j when using a negative step. range(i, j, -1) # i must be greater than j (i \u0026gt; j)\rThis can be useful for iterating over a list’s valid indices: range(0, len(l)) # Produces a valid range of indices for the list l\rConverting range() to a List: range() creates a range object, not a list. To convert it into a list, use the list() function: list(range(0, 5)) # Converts range to list: [0, 1, 2, 3, 4]\rSkipping Numbers in Sequences: Useful for generating sequences where numbers are skipped, such as even numbers or multiples: even = list(range(2, 11, 2)) print(even) # Output: [2, 4, 6, 8, 10]\rUsing range() to Generate Sequences range() can be particularly useful in a variety of contexts, such as repeating actions or generating specific number sequences.\nExample 1: Repeating a String Multiple Times # Repeating the string \u0026#34;meow\u0026#34; 3 times: print(\u0026#34;meow\u0026#34; * 3) # Output: meowmeowmeow\rExample 2: Using Newlines with range() # Using newline `\\n`: print(\u0026#34;meow\\n\u0026#34; * 3) # Output: meow (with new line after each \u0026#34;meow\u0026#34;)\rExample 3: Removing the Default Newline in print() # Removing the default newline after the print: print(\u0026#34;meow\\n\u0026#34; * 3, end=\u0026#34;\u0026#34;) # Output: meowmeowmeow (without extra newline)\rExample 4: Finding All Factors of a Number n You can use range() in a for loop to find all factors of a given number n:\ndef factors(n): flist = [] for i in range(1, n + 1): if n % i == 0: flist.append(i) # Can also use flist = flist + [i] return flist\r","date":"2025-01-25","id":21,"permalink":"/personal-site/docs/python/4control_statements/04-control-flow-03-range/","summary":"\u003cp\u003eThe \u003ccode\u003erange()\u003c/code\u003e function generates a sequence of numbers, commonly used for looping or generating lists with specific patterns.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e\u003ccode\u003erange(i, j)\u003c/code\u003e\u003c/strong\u003e Generates a sequence of numbers starting from \u003ccode\u003ei\u003c/code\u003e and ending before \u003ccode\u003ej\u003c/code\u003e.\u003c/li\u003e\n\u003c/ul\u003e\n\r\n\r\n\r\n\u003cdiv class=\"expressive-code\"\u003e\r\n  \u003cfigure class=\"frame not-content\"\u003e\r\n  \u003cfigcaption class=\"header\"\u003e\r\n    \u003cspan class=\"title\"\u003e\u003c/span\u003e\r\n  \u003c/figcaption\u003e\r\n  \u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-python\" data-lang=\"python\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"nb\"\u003erange\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ei\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003ej\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# Produces the sequence: i, i+1, ..., j-1\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\r\n  \u003c/figure\u003e\r\n\u003c/div\u003e\r\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e\u003ccode\u003erange(j)\u003c/code\u003e\u003c/strong\u003e Starts from \u003ccode\u003e0\u003c/code\u003e and ends before \u003ccode\u003ej\u003c/code\u003e. This is equivalent to \u003ccode\u003erange(0, j)\u003c/code\u003e.\u003c/li\u003e\n\u003c/ul\u003e\n\r\n\r\n\r\n\u003cdiv class=\"expressive-code\"\u003e\r\n  \u003cfigure class=\"frame not-content\"\u003e\r\n  \u003cfigcaption class=\"header\"\u003e\r\n    \u003cspan class=\"title\"\u003e\u003c/span\u003e\r\n  \u003c/figcaption\u003e\r\n  \u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-python\" data-lang=\"python\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"nb\"\u003erange\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ej\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# Like slice(:j), starts from 0, ends at j-1\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\r\n  \u003c/figure\u003e\r\n\u003c/div\u003e\r\n\u003ch4 id=\"increment-with-range\"\u003eIncrement with \u003ccode\u003erange()\u003c/code\u003e:\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e\u003ccode\u003erange(i, j, k)\u003c/code\u003e\u003c/strong\u003e\u003cbr\u003e\nAdds an optional third argument \u003ccode\u003ek\u003c/code\u003e for defining the step increment, useful for sequences with a specific pattern, like arithmetic progressions (AP).\u003c/li\u003e\n\u003c/ul\u003e\n\r\n\r\n\r\n\u003cdiv class=\"expressive-code\"\u003e\r\n  \u003cfigure class=\"frame not-content\"\u003e\r\n  \u003cfigcaption class=\"header\"\u003e\r\n    \u003cspan class=\"title\"\u003e\u003c/span\u003e\r\n  \u003c/figcaption\u003e\r\n  \u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-python\" data-lang=\"python\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"nb\"\u003erange\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ei\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003ej\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003ek\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# Produces: i, i+k, i+2k, ..., i+nk\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\r\n  \u003c/figure\u003e\r\n\u003c/div\u003e\r\n\u003ch4 id=\"reverse-counting\"\u003eReverse Counting:\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003eTo count in reverse, use a negative value for \u003ccode\u003ek\u003c/code\u003e. Ensure \u003ccode\u003ei \u0026gt; j\u003c/code\u003e when using a negative step.\u003c/li\u003e\n\u003c/ul\u003e\n\r\n\r\n\r\n\u003cdiv class=\"expressive-code\"\u003e\r\n  \u003cfigure class=\"frame not-content\"\u003e\r\n  \u003cfigcaption class=\"header\"\u003e\r\n    \u003cspan class=\"title\"\u003e\u003c/span\u003e\r\n  \u003c/figcaption\u003e\r\n  \u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-python\" data-lang=\"python\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"nb\"\u003erange\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ei\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003ej\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"o\"\u003e-\u003c/span\u003e\u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# i must be greater than j (i \u0026gt; j)\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\r\n  \u003c/figure\u003e\r\n\u003c/div\u003e\r\n\u003cul\u003e\n\u003cli\u003eThis can be useful for iterating over a list’s valid indices:\u003c/li\u003e\n\u003c/ul\u003e\n\r\n\r\n\r\n\u003cdiv class=\"expressive-code\"\u003e\r\n  \u003cfigure class=\"frame not-content\"\u003e\r\n  \u003cfigcaption class=\"header\"\u003e\r\n    \u003cspan class=\"title\"\u003e\u003c/span\u003e\r\n  \u003c/figcaption\u003e\r\n  \u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-python\" data-lang=\"python\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"nb\"\u003erange\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"nb\"\u003elen\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003el\u003c/span\u003e\u003cspan class=\"p\"\u003e))\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# Produces a valid range of indices for the list l\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\r\n  \u003c/figure\u003e\r\n\u003c/div\u003e\r\n\u003ch4 id=\"converting-range-to-a-list\"\u003eConverting \u003ccode\u003erange()\u003c/code\u003e to a List:\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e\u003ccode\u003erange()\u003c/code\u003e\u003c/strong\u003e creates a \u003ccode\u003erange\u003c/code\u003e object, not a list. To convert it into a list, use the \u003ccode\u003elist()\u003c/code\u003e function:\u003c/li\u003e\n\u003c/ul\u003e\n\r\n\r\n\r\n\u003cdiv class=\"expressive-code\"\u003e\r\n  \u003cfigure class=\"frame not-content\"\u003e\r\n  \u003cfigcaption class=\"header\"\u003e\r\n    \u003cspan class=\"title\"\u003e\u003c/span\u003e\r\n  \u003c/figcaption\u003e\r\n  \u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-python\" data-lang=\"python\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"nb\"\u003elist\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"nb\"\u003erange\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"mi\"\u003e5\u003c/span\u003e\u003cspan class=\"p\"\u003e))\u003c/span\u003e  \n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# Converts range to list: [0, 1, 2, 3, 4]\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\r\n  \u003c/figure\u003e\r\n\u003c/div\u003e\r\n\u003ch4 id=\"skipping-numbers-in-sequences\"\u003eSkipping Numbers in Sequences:\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003eUseful for generating sequences where numbers are skipped, such as even numbers or multiples:\u003c/li\u003e\n\u003c/ul\u003e\n\r\n\r\n\r\n\u003cdiv class=\"expressive-code\"\u003e\r\n  \u003cfigure class=\"frame not-content\"\u003e\r\n  \u003cfigcaption class=\"header\"\u003e\r\n    \u003cspan class=\"title\"\u003e\u003c/span\u003e\r\n  \u003c/figcaption\u003e\r\n  \u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-python\" data-lang=\"python\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"n\"\u003eeven\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"nb\"\u003elist\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"nb\"\u003erange\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"mi\"\u003e2\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"mi\"\u003e11\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"mi\"\u003e2\u003c/span\u003e\u003cspan class=\"p\"\u003e))\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"nb\"\u003eprint\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eeven\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e  \n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# Output: [2, 4, 6, 8, 10]\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\r\n  \u003c/figure\u003e\r\n\u003c/div\u003e\r\n\u003chr\u003e\n\u003ch3 id=\"using-range-to-generate-sequences\"\u003eUsing \u003ccode\u003erange()\u003c/code\u003e to Generate Sequences\u003c/h3\u003e\n\u003cp\u003e\u003ccode\u003erange()\u003c/code\u003e can be particularly useful in a variety of contexts, such as repeating actions or generating specific number sequences.\u003c/p\u003e","tags":[],"title":"04 Control-Flow - 03 Range"},{"content":"1. \u0026lsquo;for\u0026rsquo; Loop: Iterating Over a Collection The for loop is used to iterate over a sequence (like a list, tuple, or string) and execute a block of code for each item in the sequence.\nBasic Example 1: Iterating Over a List:\nfor i in [0, 1, 2]: print(\u0026#34;Meow\u0026#34;)\rBasic Example 2: Using range() to Repeat a Fixed Number of Times:\nfor i in range(3): # Iterates over a range of 3 numbers (0, 1, 2) print(\u0026#34;Meow\u0026#34;)\rExample 3: Using range() to Iterate Over a Sequence of Numbers:\nfor i in range(0, n): # Sequence from 0 to n-1 # Code to execute\r2. \u0026lsquo;while\u0026rsquo; Loop: Loops Based on Condition The while loop is useful when you don\u0026rsquo;t know how many times the loop should run in advance. It keeps executing as long as the condition evaluates to True.\nDecrementing Example:\ni = 3 while i != 0: print(\u0026#34;Meow\u0026#34;) i = i - 1\rIncrementing Example:\ni = 0 while i != 3: # Alternatively: while i \u0026lt; 3 print(\u0026#34;Meow\u0026#34;) i = i + 1 # or i += 1\rUsing while to Write Clear Prompts:\nprompt = \u0026#34;Type this message\\n\u0026#34; prompt += \u0026#34;Add \u0026#39;quit\u0026#39; to exit\\n:\u0026#34; message = \u0026#34;\u0026#34; while message != \u0026#34;quit\u0026#34;: message = input(prompt) print(message)\rExample of a counter with while loop:\nnumber = 1 while number \u0026lt;= 5: print(number) number += 1 # Can also be number *= 2 to double the value\r3. Using a Flag to Exit a Loop A flag is a variable that controls whether the loop continues or stops. It’s particularly useful when there are multiple conditions to consider.\nWhen many possible events might occur to stop the program, testing all these conditions in a single while statement can become complicated. Instead, we can use a flag to simplify this.\nThe flag acts as a signal to the program. The loop will run as long as the flag is set to True, and it will stop when any event sets the flag to False. This way, our while statement only needs to check one condition: whether the flag is True.\nOther conditions that could modify the flag can be handled separately in the rest of the program.\nprompt = \u0026#34;\\nType to have it repeated\u0026#34; prompt += \u0026#34;\\n: \u0026#34; active = True while active: # Loop continues while \u0026#39;active\u0026#39; is True message = input(prompt) if message == \u0026#34;quit\u0026#34;: active = False # When \u0026#34;quit\u0026#34; is entered, the flag is set to False, ending the loop else: print(message)\rThis approach keeps the program flow simple, only needing to check the flag condition in the while loop.\n4. Using \u0026lsquo;break\u0026rsquo; to Exit a Loop The break statement immediately exits the loop, regardless of the condition.\nprompt = \u0026#34;\\nEnter the city you have visited:\u0026#34; prompt += \u0026#34;\\nUse \u0026#39;quit\u0026#39; to exit. \u0026#34; while True: # This loop will run indefinitely until \u0026#39;break\u0026#39; is encountered city = input(prompt) if city == \u0026#34;quit\u0026#34;: break # Exits the loop when \u0026#39;quit\u0026#39; is entered else: print(f\u0026#34;\\n{city.title()} is lovely\u0026#34;)\r5. Using \u0026lsquo;continue\u0026rsquo; in a Loop The continue statement skips the current iteration of the loop and moves on to the next one.\nExample:\nnumber = 0 while number \u0026lt; 10: number += 1 if number % 2 == 0: # Skips even numbers continue else: print(number) # Prints only odd numbers\r6. Modifying Lists Inside Loops You can use a while loop to modify lists as you work through them. For example, you can move items from one list to another or remove specific values.\nExample 1: Moving Items Between Lists:\nunconfirmed_users = [\u0026#39;alice\u0026#39;, \u0026#39;brian\u0026#39;, \u0026#39;candace\u0026#39;] confirmed_users = [] while unconfirmed_users: # Continues as long as the list is not empty user = unconfirmed_users.pop() print(f\u0026#34;Verifying User: {user.title()}\u0026#34;) confirmed_users.append(user) print(\u0026#34;\\nThe following users have been verified:\u0026#34;) for user in confirmed_users: print(f\u0026#34;{user.title()}\u0026#34;)\rExample 2: Removing Specific Values from a List:\npets = [\u0026#39;dog\u0026#39;, \u0026#39;cat\u0026#39;, \u0026#39;dog\u0026#39;, \u0026#39;goldfish\u0026#39;, \u0026#39;cat\u0026#39;, \u0026#39;rabbit\u0026#39;, \u0026#39;cat\u0026#39;] print(pets) while \u0026#34;cat\u0026#34; in pets: pets.remove(\u0026#34;cat\u0026#34;) # Removes the first instance of \u0026#34;cat\u0026#34; print(pets)\r7. Filling a Dictionary with User Input A while loop can be used to collect multiple user inputs and store them in a dictionary.\nresponses = {} polling = True while polling: name = input(\u0026#34;\\nWhat\u0026#39;s your name: \u0026#34;) response = input(\u0026#34;What mountain would you like to climb someday? \u0026#34;) responses[name] = response # Add user response to dictionary repeat = input(\u0026#34;\\nWould you like another to take this poll? (y/n): \u0026#34;) if repeat == \u0026#34;n\u0026#34;: polling = False # Ends the loop when \u0026#39;n\u0026#39; is entered print(\u0026#34;\\n-- Poll Results --\u0026#34;) for name, response in responses.items(): print(f\u0026#34;{name.title()} wants to climb {response.title()}.\u0026#34;)\r8. Functions with Loops You can define functions that use loops to perform repetitive tasks.\ndef main(): number = get_number() meow(number) def get_number(): while True: n = int(input(\u0026#34;What\u0026#39;s n? \u0026#34;)) if n \u0026gt; 0: break # Ensures that n is positive return n def meow(n): for _ in range(n): # Repeats n times print(\u0026#34;Meow\u0026#34;) main()\r9. Simulating a \u0026lsquo;for\u0026rsquo; Loop with a \u0026lsquo;while\u0026rsquo; Loop Sometimes you may want to simulate a for loop using a while loop.\nExample 1: Simulating for with a Range:\nn = i while n \u0026lt; j: statement n += 1\rExample 2: Simulating Iterating Over a List:\ni = 0 while i \u0026lt; len(l): n = l[i] statement i += 1\r","date":"2025-01-25","id":22,"permalink":"/personal-site/docs/python/4control_statements/04-control-flow-04-loops/","summary":"\u003ch3 id=\"1-for-loop-iterating-over-a-collection\"\u003e1. \u0026lsquo;for\u0026rsquo; Loop: Iterating Over a Collection\u003c/h3\u003e\n\u003cp\u003eThe \u003ccode\u003efor\u003c/code\u003e loop is used to iterate over a sequence (like a list, tuple, or string) and execute a block of code for each item in the sequence.\u003c/p\u003e","tags":[],"title":"04 Control-Flow - 04 Loops"},{"content":"Well-thought-through product announcements will help increase feature awareness and engage users with new functionality. Just like sharing your public roadmap.\nRead How to announce product updates and features ","date":"2023-09-07","id":23,"permalink":"/personal-site/blog/first-blog-post/","summary":"Nothing important to announce, just figuring out things.","tags":[],"title":"First Blog Post"},{"content":"","date":"2023-09-07","id":24,"permalink":"/personal-site/blog/","summary":"","tags":[],"title":"Blog"},{"content":"","date":"2025-01-01","id":25,"permalink":"/personal-site/docs/c/kr_c_book/","summary":"","tags":[],"title":"The C Programming Language by Kernighan and Ritchie"},{"content":"Introduction to C Language C is a powerful, procedural programming language that provides a straightforward and efficient way to write system-level software.\nIt is a lower-level language than modern high-level languages, allowing direct access to memory and hardware, and is known for its efficiency and flexibility.\nProcedural Language: C is procedural, meaning that the program is typically divided into functions that can be called in sequence. The language does not emphasize objects or data structures like object-oriented programming languages (e.g., C++ or Java).\nLow-Level Access: C allows direct manipulation of memory and hardware, making it ideal for system-level programming but requiring careful management to avoid issues like buffer overflows and pointer errors.\nBasic Characteristics of C No built-in I/O statements: C does not have built-in input/output functions like high-level languages. All input and output operations need to be explicitly handled by the functions provided by libraries (such as printf(), scanf()).\nNo file access methods: File manipulation must be done manually using file handling functions like fopen(), fclose(), fread(), and fwrite().\nControl Flow Constructs: C provides simple, single-threaded control flow mechanisms such as:\nTests: Conditional statements (if, else, switch)\nLoops: Iteration structures (for, while, do-while)\nGrouping/Sub-grouping: Blocks of code enclosed in {} to group statements\nC does not have built-in support for:\nMulti-programming (running multiple programs simultaneously)\nParallel operations\nSynchronization\nCo-routines (functions that can be paused and resumed)\nMemory Management in C Dynamic Memory Allocation:\nC provides the functions malloc() and free() to manually allocate and deallocate memory on the heap during runtime.\nmalloc(size_t size): Allocates a block of memory of the specified size and returns a pointer to the first byte of this memory block. free(void *ptr): Frees previously allocated memory, making it available for reuse. The heap refers to the region of memory managed dynamically during the execution of a program. It is separate from the stack (used for function call management) and static memory.\nMemory Leaks:\nIf memory allocated via malloc() is not freed with free(), it leads to memory leaks. Over time, if this happens repeatedly, the program may run out of available memory, causing crashes or slowdowns.\nMemory Fragmentation:\nContinuous allocation and deallocation of memory blocks can cause the heap to become fragmented, making it harder to find contiguous blocks of memory. This requires garbage collection or memory management techniques to clean up fragmented areas.\nGarbage Collection in C C does not have automatic garbage collection like higher-level languages (e.g., Java or Python). The programmer is responsible for managing memory allocation and deallocation. Poor memory management leads to memory leaks or fragmented memory.\nWhile C does not provide automatic garbage collection, developers can use tools or libraries to check for memory leaks or to help with memory management.\nLint Checking Lint: A static code analysis tool that examines C source code to identify potential errors or areas of concern without executing the program.\nIt can catch a variety of issues, such as:\nPossible typos or misuses of variables Unused variables or functions Suspicious expressions Possible memory allocation failures Lint vs Compiler: Linting is separate from the compiler. While the compiler checks for syntax and types, linting looks for logical or potential runtime problems in code. Using both linting tools and a compiler helps ensure more robust and error-free code.\n","date":"2024-12-18","id":26,"permalink":"/personal-site/docs/c/kr_c_book/kr-chapter-0-introduction-to-c-language/","summary":"\u003ch3 id=\"introduction-to-c-language\"\u003e\u003cstrong\u003eIntroduction to C Language\u003c/strong\u003e\u003c/h3\u003e\n\u003cp\u003eC is a powerful, procedural programming language that provides a straightforward and efficient way to write system-level software.\u003cbr\u003e\nIt is a lower-level language than modern high-level languages, allowing direct access to memory and hardware, and is known for its efficiency and flexibility.\u003c/p\u003e","tags":[],"title":"K\u0026R - Chapter 0 - Introduction to C language"},{"content":"","date":"2024-12-18","id":27,"permalink":"/personal-site/docs/c/","summary":"","tags":[],"title":"C Language"},{"content":"Python and C Comparison Python C Whitespace is essential Whitespace is ignored Very object-oriented Not object-oriented at all Data structures like list, dict struct, pointers Auto memory management Manual memory management High-level language Low-level language Similarities Between Python and C Arithmetic Operators: +, -, *, /, %\nComparison Operators: \u0026lt;, \u0026gt;, \u0026lt;=, \u0026gt;=, !=\nVariable Naming Rules:\nCase matters (e.g., myVar is different from myvar). Can use letters, numbers, and underscores in variable names, but they cannot start with a number. Control Flow:\nWhile Loops: Both languages have while loops and support the break and continue statements.\ni = 0 while i \u0026lt; 5: if i == 3: break print(i) i += 1\rint i = 0; while (i \u0026lt; 5) { if (i == 3) { break; } printf(\u0026#34;%d\\n\u0026#34;, i); i++; }\rConstants:\nBoth Python and C allow defining constants.\nWhile Python has a convention for constants (uppercase variable names),\nC uses #define or const to define constants.\nMAX_VALUE = 100\r#define MAX_VALUE 100\rData Types:\nIntegers and Floats: Both languages support integer and floating-point types.\nIn C, the int and float types exist, while in Python, all numbers are represented as int or float (and Python\u0026rsquo;s float is equivalent to C\u0026rsquo;s double).\nCharacters:\nC has char for single characters, while Python uses strings,\nbut a single character in Python is a string of length 1.\nKey Differences Between Python and C Boolean Operators:\nIn Python, and, not, or are used for boolean operations.\nIn C, \u0026amp;\u0026amp; (and), ! (not), || (or) are used.\na = True b = False if a and b: print(\u0026#34;Both are true\u0026#34;)\rint a = 1, b = 0; if (a \u0026amp;\u0026amp; b) { printf(\u0026#34;Both are true\\n\u0026#34;); }\rFor Loops:\nPython has a for..in loop for iterating over elements of a list or other iterable objects.\nfor i in range(5): print(i)\rC does not have a for..in loop. Instead, you need to specify a loop variable, condition, and update manually:\nfor (int i = 0; i \u0026lt; 5; i++) { printf(\u0026#34;%d\\n\u0026#34;, i); }\rBoolean Values:\nPython has predefined constants True and False as boolean values.\nIn C, there are no predefined True or False values;\ntypically, 1 is used for true and 0 for false.\nif True: print(\u0026#34;True\u0026#34;)\rif (1) { printf(\u0026#34;True\\n\u0026#34;); }\rNone vs NULL:\nNone in Python is a special object that represents the absence of a value. It is its own type. NULL in C is a null pointer constant, typically represented as 0 or ((void*)0).\nIt represents a pointer that does not point to any memory address. x = None if x is None: print(\u0026#34;x is None\u0026#34;)\rint* x = NULL; if (x == NULL) { printf(\u0026#34;x is NULL\\n\u0026#34;); }\rStrings and Character Arrays:\nStrings in Python are immutable and can be treated as objects with many built-in methods. C strings are arrays of characters, terminated by a null character ('\\0'). String manipulation in C is less intuitive and requires careful handling of memory. s = \u0026#34;Hello\u0026#34; print(s.upper())\rchar s[] = \u0026#34;Hello\u0026#34;; printf(\u0026#34;%s\\n\u0026#34;, strupr(s)); // Requires external string manipulation functions like `strupr()` Data Structures:\nPython comes with built-in data structures like list and dict, which are high-level and flexible.\nIn C, you must manually define data structures using struct, and dynamic data structures often require the use of pointers for manipulation.\nmy_list = [1, 2, 3] my_dict = {\u0026#34;key\u0026#34;: \u0026#34;value\u0026#34;}\rstruct Point { int x; int y; }; struct Point p = {1, 2};\rMemory Management:\nPython has automatic memory management with garbage collection, meaning memory is allocated and freed automatically.\nC requires manual memory management using functions like malloc() for allocation and free() for deallocation.\na = [1, 2, 3] # Memory management handled by Python\rint* arr = (int*) malloc(3 * sizeof(int)); // Manual allocation free(arr); // Manual deallocation No double in Python:\nPython uses float for both single-precision and double-precision floating-point numbers, while C has both float (single precision) and double (double precision) types.\na = 3.14159 # Python float (equivalent to C\u0026#39;s double)\rdouble a = 3.14159; // C double ","date":"2024-12-18","id":28,"permalink":"/personal-site/docs/c/kr_c_book/kr-chapter-0-introduction-using-python-part-1/","summary":"\u003ch2 id=\"python-and-c-comparison\"\u003e\u003cstrong\u003ePython and C Comparison\u003c/strong\u003e\u003c/h2\u003e\n\u003ctable\u003e\n  \u003cthead\u003e\n      \u003ctr\u003e\n          \u003cth\u003e\u003cstrong\u003ePython\u003c/strong\u003e\u003c/th\u003e\n          \u003cth\u003e\u003cstrong\u003eC\u003c/strong\u003e\u003c/th\u003e\n      \u003c/tr\u003e\n  \u003c/thead\u003e\n  \u003ctbody\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eWhitespace is essential\u003c/td\u003e\n          \u003ctd\u003eWhitespace is ignored\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eVery object-oriented\u003c/td\u003e\n          \u003ctd\u003eNot object-oriented at all\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eData structures like \u003ccode\u003elist\u003c/code\u003e, \u003ccode\u003edict\u003c/code\u003e\u003c/td\u003e\n          \u003ctd\u003e\u003ccode\u003estruct\u003c/code\u003e, pointers\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eAuto memory management\u003c/td\u003e\n          \u003ctd\u003eManual memory management\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eHigh-level language\u003c/td\u003e\n          \u003ctd\u003eLow-level language\u003c/td\u003e\n      \u003c/tr\u003e\n  \u003c/tbody\u003e\n\u003c/table\u003e\n\u003chr\u003e\n\u003ch3 id=\"similarities-between-python-and-c\"\u003e\u003cstrong\u003eSimilarities Between Python and C\u003c/strong\u003e\u003c/h3\u003e\n\u003cp\u003e\u003cstrong\u003eArithmetic Operators\u003c/strong\u003e:   \u003ccode\u003e+\u003c/code\u003e, \u003ccode\u003e-\u003c/code\u003e, \u003ccode\u003e*\u003c/code\u003e, \u003ccode\u003e/\u003c/code\u003e, \u003ccode\u003e%\u003c/code\u003e\u003c/p\u003e","tags":[],"title":"K\u0026R - Chapter 0 - Introduction using Python (Part 1)"},{"content":"Comparing Python and C Code Printing Output in Python vs. C print(\u0026#39;Hello world\u0026#39;) print(\u0026#39;Answer\u0026#39;, 42) print(\u0026#39;Name\u0026#39;, \u0026#39;Sarah\u0026#39;) print(\u0026#39;x\u0026#39;, 3.5, \u0026#39;i\u0026#39;, 10) # A comment\r#include \u0026lt;stdio.h\u0026gt; int main() { printf(\u0026#34;Hello world\\n\u0026#34;); printf(\u0026#34;Answer %d\\n\u0026#34;, 42); printf(\u0026#34;Name %s\\n\u0026#34;, \u0026#34;Sarah\u0026#34;); printf(\u0026#34;x %.1f i %d\\n\u0026#34;, 3.5, 100); } /* A comment */ // Another comment Output (for both Python and C)\nHello world Answer 42 Name Sarah x 3.5 i 100\r#include \u0026lt;stdio.h\u0026gt;: Read as \u0026ldquo;Pound include standard I O\u0026rdquo;\nThis tells the C compiler to include the standard input/output library, allowing the use of printf() and other I/O functions.\nEvery C program must have a main() function, where execution starts.\nint main() specifies the return type as int, indicating the program’s exit status (usually 0 for success).\nprintf(\u0026quot;Hello world\\n\u0026quot;) Prints text to the screen.\n\\n adds a newline, moving the cursor to the next line.\nThere cannot be single quotes used in a string, '' means a single characters and \u0026quot;\u0026quot; are character array (not a string).\nIn C, format codes (like %d, %s, %f) are used inside the string to indicate where values should be inserted.\n%d is used for integers, %s for strings, and %.1f for floating-point numbers with one decimal precision.\nprintf(\u0026quot;Answer %d\\n\u0026quot;, 42);\nThe %d is replaced with the integer 42.\nprintf(\u0026quot;x %.1f i %d\\n\u0026quot;, 3.5, 100);\n%.1f prints 3.5 with one decimal, and %d prints 100.\nprintf(\u0026quot;Name %s\\n\u0026quot;, \u0026quot;Sarah\u0026quot;);\n%s finds the string (character array) which will have to have a proper terminating \\0 character at the end.\nNumber Input print(\u0026#39;Enter US Floor\u0026#39;) usf = int(input()) euf = usf - 1 print(\u0026#39;EU Floor\u0026#39;, euf)\r#include \u0026lt;stdio.h\u0026gt; int main() { int usf, euf; printf(\u0026#34;Enter US Floor\\n\u0026#34;); scanf(\u0026#34;%d\u0026#34;, \u0026amp;usf); euf = usf - 1; printf(\u0026#34;EU Floor %d\\n\u0026#34;, euf); }\rOutput\nEnter US Floor 2 EU Floor 1\rint usf, euf; declares two integer variables, usf and euf.\nscanf() Function:\nIn C, scanf(\u0026quot;%d\u0026quot;, \u0026amp;usf) works similarly to Python’s input().\nThe %d format specifier tells scanf to expect an integer.\nThe \u0026amp; symbol means \u0026ldquo;pass the address of usf\u0026rdquo; allowing scanf to directly modify usf by storing the input value in its memory location (this is called call by reference).\nWithout the \u0026amp;, it would be call by value, and scanf would not update the variable correctly.\nCall by reference and call by value\nIn python int(input()) comes back as a function return so it is easy to assign it to usf.\nIn C without \u0026amp; on parameter it becomes call by value, where value of usf is given to scanf.\n\u0026amp;usf says to give the value coming from the scanf to the address of the usf variable instead of the value of usf, so the data can be stored.\nSo \u0026amp; is the way C to call by reference for int and floats.\nString Input print(\u0026#39;Enter name\u0026#39;) name = input() print(\u0026#39;Hello\u0026#39;, name)\r#include \u0026lt;stdio.h\u0026gt; int main() { char name[100]; printf(\u0026#34;Enter name\\n\u0026#34;); scanf(\u0026#34;%100s\u0026#34;, name); printf(\u0026#34;Hello %s\\n\u0026#34;, name); }\rOutput\nEnter name Sarah Hello Sarah\rDeclaring Character Arrays in C:\nIn C, char name[100]; defines an array to hold up to 100 characters (no strings in C, just arrays of characters).\nThis array has a fixed size and cannot dynamically grow like Python strings.\nIn Python, strings are objects and have dynamic sizes.\nUsing scanf for String Input:\nscanf(\u0026quot;%100s\u0026quot;, name); reads up to 100 characters into the name array.\n%100s format specifier limits the input to 100 characters.\nIn C, arrays are passed by reference, so there’s no need for \u0026amp; with name. Simply passing the array variable provides the address of the first element.\nIn C character array size has to be predefined, which can lead to buffer overflow issues if not managed carefully.\nReading a Full Line of Input print(\u0026#39;Enter line\u0026#39;) line = input() print(\u0026#39;Line:\u0026#39;, line)\r#include \u0026lt;stdio.h\u0026gt; int main() { char line[1000]; printf(\u0026#34;Enter line\\n\u0026#34;); scanf(\u0026#34;%[^\\n]1000s\u0026#34;, line); printf(\u0026#34;Line: %s\\n\u0026#34;, line); }\rOutput\nEnter line Hello world - have a nice day Line: Hello world - have a nice day\rReading Until Newline:\nchar line[1000] Pre-defining a character array with space for 1000 characters.\nscanf(\u0026quot;%[^\\n]1000s\u0026quot;, line); reads all characters until a newline (\\n) is encountered.\nThe ^[\\n] format specifier is a regular expression that means \u0026ldquo;match any character except a newline.\u0026rdquo;\nThis allows to capture a full line of input (or up to 1000 characters).\nUsing fgets for Reading Input #include \u0026lt;stdio.h\u0026gt; int main() { char line[1000]; printf(\u0026#34;Enter line\\n\u0026#34;); fgets(line, 1000, stdin); printf(\u0026#34;Line: %s\\n\u0026#34;, line); }\rfgets() for Safer Input:\nfgets(line, 1000, stdin); reads up to 1000 characters from the standard input (stdin) and stores them in the line array.\nfgets can read a file, the third parameter is a file handle, (there are 3 predefined file handles like stdin)\nUnlike scanf, fgets does not stop at whitespace, so it can read the entire line, including spaces.\nfgets is generally safer than scanf because it limits the number of characters to avoid buffer overflows.\nC’s standard I/O library works with three standard file streams:\nstdin for input stdout for output stderr for error messages Read a File hand = open(\u0026#39;romeo.txt\u0026#39;) for line in hand: print(line.strip())\r#include \u0026lt;stdio.h\u0026gt; int main() { char line[1000]; FILE *hand; hand = fopen(\u0026#34;romeo.txt\u0026#34;, \u0026#34;r\u0026#34;); while( fgets(line, 1000, hand) != NULL ) { printf(\u0026#34;%s\u0026#34;, line); } }\rFile Handling in C:\nFILE is a type defined in stdio.h.\nFILE *hand; declares a pointer to a FILE object, which is used to handle file operations. fopen(\u0026quot;romeo.txt\u0026quot;, \u0026quot;r\u0026quot;); opens the file in read mode (\u0026quot;r\u0026quot;). fgets(line, 1000, hand); reads a line from the file into the line array. It reads up to 1000 characters or until it encounters a newline. The while loop continues until fgets returns NULL, which indicates the end of the file (EOF). Key Differences:\nPython’s open() function is simpler and automatically handles file objects, while C requires you to manage the file pointer manually. In C, fgets() is used to read lines, while Python uses a loop directly over the file object. Counted Loop for i in range(5): print(i)\r#include \u0026lt;stdio.h\u0026gt; int main() { int i; for (i = 0; i \u0026lt; 5; i++) { printf(\u0026#34;%d\\n\u0026#34;, i); } }\rOutput:\n0 1 2 3 4\rC For Loop: The syntax in C is similar to Python but requires explicit initialization, condition, and increment.\nfor (i = 0; i \u0026lt; 5; i++) initializes i to 0, continues while i is less than 5, and increments i by 1 on each iteration. Python uses range(5) to generate numbers, while C requires manual control over the loop variables.\nMax / Min maxval = None minval = None while True: line = input() line = line.strip() if line == \u0026#34;done\u0026#34;: break ival = int(line) if (maxval is None or ival \u0026gt; maxval): maxval = ival if (minval is None or ival \u0026lt; minval): minval = ival print(\u0026#39;Maximum\u0026#39;, maxval) print(\u0026#39;Minimum\u0026#39;, minval)\rInput:\n5, 2, 9, done\rOutput:\nMaximum 9 Minimum 2\r#include \u0026lt;stdio.h\u0026gt; int main() { int first = 1; int val, maxval, minval; while(scanf(\u0026#34;%d\u0026#34;, \u0026amp;val) != EOF) { if (first || val \u0026gt; maxval) maxval = val; if (first || val \u0026lt; minval) minval = val; first = 0; } printf(\u0026#34;Maximum %d\\n\u0026#34;, maxval); printf(\u0026#34;Minimum %d\\n\u0026#34;, minval); }\rInput:\n5, 2, 9 (EOF)\rOutput:\nMaximum 9 Minimum 2\rIn Python, maxval and minval are initially None, and values are updated based on comparisons.\nIn C, the first flag ensures that the maxval and minval are initialized on the first iteration.\nscanf(\u0026quot;%d\u0026quot;, \u0026amp;val) is used to read integers from the user, updating the val variable.\nGuessing Game while True: try: line = input() except: # if we get to EOF break line = line.strip() guess = int(line) if guess == 42: print(\u0026#39;Nice work\u0026#39;) elif guess \u0026lt; 42: print(\u0026#39;Too low - guess again\u0026#39;) else: print(\u0026#39;Too high - guess again\u0026#39;) #include \u0026lt;stdio.h\u0026gt; int main() { int guess; while(scanf(\u0026#34;%d\u0026#34;, \u0026amp;guess) != EOF) { if (guess == 42) { printf(\u0026#34;Nice work!\\n\u0026#34;); break; } else if (guess \u0026lt; 42) { printf(\u0026#34;Too low - guess again\\n\u0026#34;); } else { printf(\u0026#34;Too high - guess again\\n\u0026#34;); } } }\rPython uses a try-except block to handle EOF or input errors, while C uses scanf to read input and checks for EOF.\nIn C, the code must use curly braces {} for each block of statements within if, else if, and else.\nIn python, if elif and else is True multi-way if.\n{} is needed in C if there are more than one statement.\nIn C, if else if else is not a true multi-way if,\nit checks the if, when not true it will go to else,\nwithin the else there are two more if else nested inside so not part of a single block of code.\nThe indentation is done in a way that it looks like a multi-way if but it is not and the indentation doesn\u0026rsquo;t represent the nesting.\nFunctions (Call by Value) def mymult(a, b): c = a * b return c retval = mymult(6, 7) print(\u0026#39;Answer:\u0026#39;, retval)\r#include \u0026lt;stdio.h\u0026gt; int main() { int mymult(int, int); // function declaration int retval; retval = mymult(6, 7); printf(\u0026#34;Answer: %d\\n\u0026#34;, retval); } int mymult(int a, int b) { // function definition int c = a * b; return c; }\rFunction Definition and Declaration in C:\nint mymult(int, int); declares the function signature, specifying it takes two int parameters and returns an int. The function body in C needs to explicitly declare types for the parameters, unlike Python where types are inferred. C is statically typed, requiring explicit type declarations for variables and function parameters.\n","date":"2024-12-18","id":29,"permalink":"/personal-site/docs/c/kr_c_book/kr-chapter-0-introduction-using-python-part-2/","summary":"\u003ch2 id=\"comparing-python-and-c-code\"\u003eComparing Python and C Code\u003c/h2\u003e\n\u003ch3 id=\"printing-output-in-python-vs-c\"\u003e\u003cstrong\u003ePrinting Output in Python vs. C\u003c/strong\u003e\u003c/h3\u003e\n\r\n\r\n\r\n\u003cdiv class=\"expressive-code\"\u003e\r\n  \u003cfigure class=\"frame not-content\"\u003e\r\n  \u003cfigcaption class=\"header\"\u003e\r\n    \u003cspan class=\"title\"\u003e\u003c/span\u003e\r\n  \u003c/figcaption\u003e\r\n  \u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-python\" data-lang=\"python\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"nb\"\u003eprint\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"s1\"\u003e\u0026#39;Hello world\u0026#39;\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"nb\"\u003eprint\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"s1\"\u003e\u0026#39;Answer\u0026#39;\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"mi\"\u003e42\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"nb\"\u003eprint\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"s1\"\u003e\u0026#39;Name\u0026#39;\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"s1\"\u003e\u0026#39;Sarah\u0026#39;\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"nb\"\u003eprint\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"s1\"\u003e\u0026#39;x\u0026#39;\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"mf\"\u003e3.5\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"s1\"\u003e\u0026#39;i\u0026#39;\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"mi\"\u003e10\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# A comment\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\r\n  \u003c/figure\u003e\r\n\u003c/div\u003e\r\n\r\n\r\n\r\n\u003cdiv class=\"expressive-code\"\u003e\r\n  \u003cfigure class=\"frame not-content\"\u003e\r\n  \u003cfigcaption class=\"header\"\u003e\r\n    \u003cspan class=\"title\"\u003e\u003c/span\u003e\r\n  \u003c/figcaption\u003e\r\n  \u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-c\" data-lang=\"c\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cp\"\u003e#include\u003c/span\u003e \u003cspan class=\"cpf\"\u003e\u0026lt;stdio.h\u0026gt;\u003c/span\u003e\u003cspan class=\"cp\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cp\"\u003e\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"kt\"\u003eint\u003c/span\u003e \u003cspan class=\"nf\"\u003emain\u003c/span\u003e\u003cspan class=\"p\"\u003e()\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"nf\"\u003eprintf\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;Hello world\u003c/span\u003e\u003cspan class=\"se\"\u003e\\n\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"nf\"\u003eprintf\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;Answer %d\u003c/span\u003e\u003cspan class=\"se\"\u003e\\n\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"mi\"\u003e42\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"nf\"\u003eprintf\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;Name %s\u003c/span\u003e\u003cspan class=\"se\"\u003e\\n\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"s\"\u003e\u0026#34;Sarah\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"nf\"\u003eprintf\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;x %.1f i %d\u003c/span\u003e\u003cspan class=\"se\"\u003e\\n\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"mf\"\u003e3.5\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"mi\"\u003e100\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e/* A comment */\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e// Another comment\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\r\n  \u003c/figure\u003e\r\n\u003c/div\u003e\r\n\u003cp\u003e\u003cstrong\u003eOutput\u003c/strong\u003e (for both Python and C)\u003c/p\u003e","tags":[],"title":"K\u0026R - Chapter 0 - Introduction using Python (Part 2)"},{"content":"The C Programming Language by Kernighan and Ritchie\nChapter 1-4 - Mostly syntax, Arrays, Strings (Character arrays)\nChapter 5 - Pointers and Arrays\nChapter 6 - Structures\nChapter 7-8 - Detailed C features\nCharacter Arrays We must carefully understand the \u0026lsquo;size\u0026rsquo; of the character array and not exceed it. In C nothing is \u0026lsquo;auto extended\u0026rsquo;.\nx = \u0026#34;\u0026#34; for i in range(1000): x += \u0026#34;*\u0026#34; print (x)\rThis will not cause any problem as memory allocation is flexible.\n#include \u0026lt;stdio.h\u0026gt; int main() { char x[10]; int i; for( i=0; i\u0026lt;1000; i++) x[i] = \u0026#39;*\u0026#39;; printf(\u0026#34;%s\\n\u0026#34;, x); } $ a.out Segmentation falult: 11\rThe size of the string has been exceeded.\nThis is the reason why C is not used to write programs.\n\u0026ldquo;Buffer Overrun Errors\u0026rdquo;\n90% all security holes are due to C code.\nString / Character Constants In C single quotes '' are a character and double quotes \u0026quot;\u0026quot; are a character array (neither are string) with a 0 character at the end of it.\nA \u0026quot;\u0026quot; with one character in it is actually 2 bytes.\nA Character is a byte - a short(8-bit) integer.\n#include \u0026lt;stdio.h\u0026gt; int main() { char x[3] = \u0026#34;Hi\u0026#34;; char y[3] = { \u0026#39;H\u0026#39;, \u0026#39;i\u0026#39;}; printf(\u0026#34;x %s\\n, x\u0026#34;); printf(\u0026#34;y %s\\n, y\u0026#34;); printf(\u0026#34;%s\\n\u0026#34;, \u0026#34;Hi\u0026#34;); printf(\u0026#34;%c%c\\n\u0026#34;, \u0026#39;H\u0026#39;, \u0026#39;i\u0026#39;); }\r$ a.out\rx Hi\ry Hi\rHi\rHi\rCharacter Sets The C char type is just a number (8-bits long) usually ASCII.\nModern characters include multi-byte sequences using Unicode and UTF-8\n#include \u0026lt;stdio.h\u0026gt; int main() { print(\u0026#34;%c %d\\n\u0026#34;, \u0026#39;A\u0026#39;, \u0026#39;A\u0026#39;); }\r$ a.out\rA 65\rA character is more similar to an int than to a string.\nTerminating a String #include \u0026lt;stdio.h\u0026gt; int main() { char x[6]; x[0] = \u0026#39;H\u0026#39;; x[1] = \u0026#39;e\u0026#39;; x[2] = \u0026#39;l\u0026#39;; x[3] = \u0026#39;l\u0026#39;; x[4] = \u0026#39;o\u0026#39;; x[5] = \u0026#39;\\0\u0026#39;; printf(\u0026#34;%s\\n\u0026#34;, x); x[2] = \u0026#39;L\u0026#39;; printf(\u0026#34;%s\\n\u0026#34;, x); x[3] = \u0026#39;\\0\u0026#39;; printf(\u0026#34;%s\\n\u0026#34;, x); }\r$ a.out\rHello\rHeLlo\rHeL\rThere are no strings, they are \u0026ldquo;arrays of characters\u0026rdquo;, there is no length.\nThe size of the \u0026ldquo;string\u0026rdquo; stored in C array is not the length of the array.\nC Uses a special character \\0 that marks the string end by convention.\nSo character arrays need to allocate extra byte to store the line end character.\nTerminating a string is very important to think before creating a new string and scanning through a string, if something is appended to a \u0026ldquo;character array\u0026rdquo; then the end character has to be moved.\nManipulation: String manipulation in C involves careful management of the null terminator, where the null terminator is moved or altered.\nchar x[6]; x[0] = \u0026#39;H\u0026#39;; x[1] = \u0026#39;e\u0026#39;; x[2] = \u0026#39;l\u0026#39;; x[3] = \u0026#39;l\u0026#39;; x[4] = \u0026#39;o\u0026#39;; x[5] = \u0026#39;\\0\u0026#39;; printf(\u0026#34;%s\\n\u0026#34;, x); // prints \u0026#34;Hello\u0026#34; String length In C string \u0026ldquo;length\u0026rdquo; must be computed in a loop that scans for a zero character.\nThere the strlen() function in string.h computes string length.\nx = \u0026#39;Hello\u0026#39; print(x, len(x)) # Hello 5 in python x is an object and len is an attribute of that object.\n#include \u0026lt;stdio.h\u0026gt; int main() { char x[] = \u0026#34;Hello\u0026#34;; int py_len(); printf(\u0026#34;%s %d\\n\u0026#34;, x, py_len(x)); } int py_len(self) char self(); { int i; for(i=0; self[i]; i++); /* when string gets over it turns false */ return i; } // a.out // Hello 5 int py_len(char self[]) { int i; for (i = 0; self[i]; i++); return i; }\rReverse a String in place in C Exercise 1-19 in K\u0026amp;R\nReversing a string in place involves swapping characters from the start and end of the string until the middle is reached.\n#include \u0026lt;stdio.h\u0026gt; int main() { char x[]= \u0026#34;Hello\u0026#34;; char reverse(); printf(\u0026#34;%s \u0026#34; ) }\rChapter 1 1.1 Getting started int main() {}\nprintf()\n\\n is the only way of adding a new line.\n\\t for tab, \\b for backspace, \\\u0026quot; for double quotes, \\\\ for back slash itself.\n1.2 Variables and Arithmetic Comments\nDeclaring variables\n(when there is an error a Diagnostic message containing type and list of variables will be shown.)\nInt and float have size difference. 16bit signed number, 32 bit quantity with 7 significant bits.\nOther basic data types,\nint\rfloat char - character, a single byte, short - short integer, long - long integer,\rdouble - double-precision floating point\rassignment operator to assign values =\nterminating statements using ;\n#include \u0026lt;stdio.h\u0026gt; /* Print Farenheit-Celsius table for f =0, 20, ..., 300 */ int main() { int lower, upper, step; float fahr, celsius; lower = 0; // lower limit of the temperature upper = 300; // uppr limit step = 20; // step size fahr = lower; while (fahr \u0026lt;= upper) { celsius = (5.0/9.0) * (fahr-32.0); printf(\u0026#34;%4.0f %6.1f\\n\u0026#34;, fahr, celsius); fahr = fahr + step; } }\rwhile loop while (fahr\u0026lt;= upper) {...}\nIndentation and white space is for readability, any position is permissible.\nUsing (5.0/9.0) instead of 5/9 to prevent truncating of numbers and additional numbers are discarded. i.e 5/9 will be 0 which means everything will be zero.\nprintf() is a general purpose format conversion function. It is not part of C, but the standard library.\nprintf(\u0026quot;%4.0f %6.1f\\n\u0026quot;, fahr, celsius);\n%4.0f states that a floating point number is to be printed in a space at least four character wide, with no digits after the decimal point.\n%6.1f describes a floating point number in 6 character space, with one digit after the decimal.\nParts of a specification may be omitted, %6f at least six characters wide.\n%.2f requests two place after the decimal place, but width is not constrained.\n%f says print the number as a floating point number.\nprintf also recognizes %d for decimal integer, %o for octal, %x for hexadecimal, %c for character, %s for character string and %% for % itself.\nEach % constraint in first argument should pair with its corresponding second, third arguments, they must line up properly by number and type.\nIf you have to input numbers, then consider function scanf which reads input instead of writing output like printf\n1.3 The For Statement for (initialization; condition; increment) { // loop body }\r#include \u0026lt;stdio.h\u0026gt; main() { int fahr; for (fahr = 0; fahr \u0026lt;=300; fahr = fahr + 20) printf(\u0026#34;%4d %6.1f\\n\u0026#34;, fahr, (5.0/9.0)*(fahr-32)); }\rFirst part is done once, second part is the condition that is checked each iteration, and last is re-initialization step.\nWhile and for loops are in-determinant loops structure because they must be read closely to make sure they are properly constructed and not unintentionally a \u0026ldquo;infinite loop\u0026rdquo;.\nfor loop in python and foreach in PHP are determinant loops. They iterate over all of the elements in a collection which is not finite.\n1.4 Symbolic Constants To avoid magic numbers like 300, 20 which are buried inside the code which might not convey any information while reading as to what they are.\nWith #define construction, at the beginning of the program a symbolic name or symbolic constant to be a particular string of characters.\nThe compiler will replace the unquoted occurrences of the name by corresponding string.\n#include \u0026lt;stdio.h\u0026gt; #define LOWER 0 #define UPPER 300 #define STEP 20 main() { int fahr; for (fahr = LOWER; fahr \u0026lt;= UPPER; fahr = fahr+STEP) printf(\u0026#34;%4d %6.1f\\n\u0026#34;, fahr, (5.0/9.0)*(fahr-32)); }\rThe LOWER, UPPER, STEP are constants so they do not appear in declarations.\nTo separate them from lower case variable names they are made Fully upper.\nThere are no ; after the definition because the whole line after the define will be copied, so to avoid too many semicolons in the for.\n1.5 Collection of Useful Programs Family of related programs for doing simple operations in character data.\ngetchar() and putchar() which are provided by the library.\nFile Copying\n#include \u0026lt;stdio.h\u0026gt; main() /* copy input to output*/ { int c; c = getchar(); while (c != EOF) { putchar(c); c = getchar(); } }\rFor the end of file is, the common convention is -1 when the program has run out of input. The symbolic name EOF is a symbolic name. (The EOF is defined in stdio.h so should never be defined in code.)\n#include \u0026lt;stdio.h\u0026gt; main() { int c; while ( (c=getchar()) !=EOF ) putchar(c); }\rThe program gets a character, assigns it to c and tests whether the character was the end of file signal. If it was not, the body of the while is executed, printing the character.\nWhen end input is reached, while terminates.\nCharacter Counting\n#include \u0026lt;stdio.h\u0026gt; main() { long nc; nc = 0; while (getchar() != EOF) ++nc; printf(\u0026#34;%ld\\n\u0026#34;, nc); }\r++nc means increment by one. also --nc\nsimilar to nc = nc + 1\nPrefix operators ++nc and postfix operators nc++ both increment but have different values in expressions.\n%ld signals that corresponding argument is a long integer.\nTo cope with even bigger numbers double(double length float) can be used.\n#include \u0026lt;stdio.h\u0026gt; main() { double nc; for (nc = 0; getchar() != EOF; ++nc) ; printf(\u0026#34;%.0f\\n, nc\u0026#34;); }\r; in the middle is an empty statement to show there is nothing in the body of for loop. but grammatically it should have a body.\n%.0f suppresses printing of the non-existent fraction part.\nLine Counting Input lines are assumed to be terminated by the newline character \\n\n#include \u0026lt;stdio.h\u0026gt; main() { int c, nl; nl = 0; while ( (c = getchar()) != EOF) if (c == \u0026#39;\\n\u0026#39;) ++nl; printf(\u0026#34;%d\\n\u0026#34;, nl); }\rIf statement inside the while controls the increment if line is found.\nAny character written between a '' to produce a value equal to numerical value of the character.\n'A' is 65\n'\\n' is a single character and is equivalent to a single integer,\non the other hand \u0026quot;\\n\u0026quot; is a character string which happens only one character.\nWord Counting A loose definition of word that does not contain blank, tab or newline.\n#include \u0026lt;stdio.h\u0026gt; #define YES 1 #define NO 0 main() { /* count lines, words, characters in input*/ int c, nl, nw, nc, inword; inword = NO; nl = nw = nc = 0; while ( (c=getchar()) != EOF ) { ++nc; if (c == \u0026#39;\\n\u0026#39;) ++nl; if (c == \u0026#39; \u0026#39; || c == \u0026#39;\\n\u0026#39; || c == \u0026#39;\\t\u0026#39;) inword = NO; else if ( inword == NO ) { inword = YES; ++nw; } } printf(\u0026#34;%d %d %d\\n\u0026#34;, nl, nw, nc); }\rThe variable inword records if the program is in a word or not, initially \u0026rsquo;not in a word\u0026rsquo; .\nThe else is an alternative action to be done if the condition part of if is false.\nif (epression)\rstatement-1\relse\rstatement-2\rOne and only one of the two statements associated with if-else is done, not both.\n1.6 Arrays The number of elements in an array declaration must be constant at compile time, and the size of the array cannot be adjusted using an array declaration while program is running.\nThis leads to security flaws referred to as \u0026ldquo;buffer overflow\u0026rdquo; where a program reads mode data than it can fit into an array where it may overwrite the data or compromise the application.\n#include \u0026lt;stdio.h\u0026gt; main() /*count digits, white space and other*/ { int c, i, nwhite, nother; int ndigit[10]; nwhite = nother = 0; for (i=0; i\u0026lt;10; ++i) ndigit[i] = 0; while ( (c = getchar()) != EOF ) if (c \u0026gt;= \u0026#39;0\u0026#39; \u0026amp;\u0026amp; c\u0026lt;= \u0026#39;9\u0026#39;) ++ndigit[c-\u0026#39;0\u0026#39;]; else if ( c == \u0026#39;\u0026#39; || c == \u0026#39;\\n\u0026#39; || c == \u0026#39;\\t\u0026#39;) ++nwhite; else ++nother; printf(\u0026#34;digits =\u0026#34;); for (i=0; i\u0026lt;10; ++i) printf(\u0026#34; %d\u0026#34;, ndigit[i]); printf(\u0026#34;\\nwhite space = %d, other = %d\\n\u0026#34;, nwhite, nother); }\rint ndigit[10]; is an array of 10 integers.\nif (c \u0026gt;= '0' \u0026amp;\u0026amp; c\u0026lt;= '9') checks if the character in c is a digit.\nIf it is, then c-'0' is the digit.\nBy definition, arithmetic involving char and int converts everything to int before proceeding. so c-'0' is an integer expression.\n1.7 Functions In C, a function is equivalent to a subroutine or function, Encapsulate in a back box.\n#include \u0026lt;stdio.h\u0026gt; main() { int i; for (i = 0; i\u0026lt;10; ++i) printf(\u0026#34;%d %d %d\\n\u0026#34;, i, power(2,i), power(-3,i)); } power(x, n) /* raise x to nth power; n\u0026gt;0 */ int x, n; { int i, p; p = 1; for (i = 1; i\u0026lt;=n; ++i) p = p * x; return (p); }\rEach function has the same form:\nname (argument list, if any) argument declarations, if any declarations statements\r1.8 Arguments - Call by Value In C, function arguments are passed by value. This means the function is given the value of it\u0026rsquo;s arguments in temporary variables (on a stack) rather than on their address.\nPassing \u0026lsquo;by value\u0026rsquo; has become the norm after C as it doesn\u0026rsquo;t allow the called code to mess with the arguments and create side effects.\nThe call stack that made it possible to pass by value also made it possible for the function to call itself recursively.\nIn python, simple variables like integers and strings are passed by value while Structured data like Dict and list are passed by reference.\npower(x, n) int x, n; { int i, p; for (p = 1; n\u0026gt;0; --n) p = p*x; return (p); }\rThe argument n is used as a temporary variable which counts down till it becomes 0. So no need of i.\n1.9 Character Arrays #include \u0026lt;stdio.h\u0026gt; #define MAXLINE 1000 /* max input line size*/ main() /* find longest line */ { int len; /* current line length */ int max; /* Max length seen so far */ char line[MAXLINE]; /* current input line */ char save[MAXLINE]; /* longest line, saved */ max = 0; while ((len = get_line(line, MAXLINE)) \u0026gt; 0 ) if (len \u0026gt; max) { max = len; copy(line, save); } if (max \u0026gt; 0) /* there was a line */ printf(\u0026#34;%s\u0026#34;, save); } get_line(s, lim) /* get line into s, return length */ char s[]; int lim; { int c, i; for (i=0; i\u0026lt;lim-1 \u0026amp;\u0026amp; (c=getchar()) != EOF \u0026amp;\u0026amp; c!=\u0026#39;\\n\u0026#39;; ++i ) s[i] = c; if (c == \u0026#39;\\n\u0026#39;) { s[i] = c; ++i; } s[i] = \u0026#39;/0\u0026#39;; return(i); } copy(s1, s2) /* copy s1 to s2; assume s2 big enough */ char s1[], s2[]; { int i; i = 0; while ((s2[i] = s1[i]) != \u0026#39;\\0\u0026#39; ) ++i; }\r1.10 Scope; External Variable The variables in main(line, save) are private or local to main as they are declared within main. No other functions have direct access to them.\nThe variable in a routine comes to life only if the function is called and disappears when the function exists.\nGlobal variables which are declared outside can be accessed by any function. They retain their value as they do not disappear.\nThe variable must also be declared in each function that wants to access it. this maybe done wither by explicit extern declaration or implicitly by context.\n#include \u0026lt;stdio.h\u0026gt; #define MAXLINE 1000 /* max input line size*/ char line[MAXLINE]; /* current input line */ char save[MAXLINE]; /* longest line, saved */ int max; /* Max length seen so far */ main() /* find longest line */ { int len; /* current line length */ extern int max; extern char save[];\tmax = 0; while ((len = get_line()) \u0026gt; 0 ) if (len \u0026gt; max) { max = len; copy(); } if (max \u0026gt; 0) /* there was a line */ printf(\u0026#34;%s\u0026#34;, save); } get_line() /* get line into s, return length */ { int c, i; extern char line[]; for (i=0; i\u0026lt;MAXLINE-1 \u0026amp;\u0026amp; (c=getchar()) != EOF \u0026amp;\u0026amp; c!=\u0026#39;\\n\u0026#39;; ++i ) line[i] = c; if (c == \u0026#39;\\n\u0026#39;) { line[i] = c; ++i; } line[i] = \u0026#39;\\0\u0026#39;; return(i); } copy() /* copy s1 to s2; assume s2 big enough */ { int i; extern char line[], save[]; i = 0; while ((save[i] = line[i]) != \u0026#39;\\0\u0026#39; ) ++i; }\rThe external variables are there even when you don\u0026rsquo;t want them.\n","date":"2024-12-18","id":30,"permalink":"/personal-site/docs/c/kr_c_book/kr-chapter-1-basic-syntax/","summary":"\u003cp\u003eThe C Programming Language by Kernighan and Ritchie\u003c/p\u003e\n\u003cp\u003eChapter 1-4 - Mostly syntax, Arrays, Strings (Character arrays)\u003cbr\u003e\nChapter 5 - Pointers and Arrays\u003cbr\u003e\nChapter 6 - Structures\u003cbr\u003e\nChapter 7-8 - Detailed C features\u003c/p\u003e","tags":[],"title":"K\u0026R - Chapter 1 - Basic Syntax"},{"content":"Section 2.2 - Data types and storage allocation - Character, integer, short, long. Section 2.7 - Type conversion Section 2.9 - Bit-wise Logical operations\nChapter 2 - Types, Operators and Expressions Declaration lists the variables being used, along with their type and perhaps their initial value.\nOperators specify what is to be done to them.\nExpressions combine Variables and constants to produce new values.\nThere are signed and unsigned forms of all integer types.\n2.1 Variable names Naming conventions\u0026hellip;\nlower case for variable names and all upper case for symbolic constants.\nSignificant characters of a name (31), Uniqueness for\n2.2 Data types and sizes char, int, float, double\nQualifiers that can be applied to these basic types are,\nshort, long here int can be omitted also.\nshort int sh; long int sh;\rQualifiers signed, unsigned can be used for char or any integer.\nunsigned char numbers are positive or zero, between 0 and 255,\nsigned char has values b/w -128 127.\nlong double specifies extended-precision floating point.\n2.3 Constants Integer constant\nlong constants with terminal l\nunsigned constants with terminal u\nsuffixes, ul - unsigned double, f - float, l - long double\nLeading 0 in an integer constant meas octal, decimal 31 can be written as 037 leading 0x means hexadecimal 31 becomes 0x1f\nA Character constant is an integer, 0 is 48 in ASCII\nthese participate in numeric operations just as any other integers, although they are mostly used in comparison with other characters.\nEscape sequences which looks like 2 character but is only one. \\n \\v \\0\nA constant expression involves only constants and are evaluated during compilation time rather than runtime.\n#define MAXLINE 1000 char line[MAXLINE+1]; #define LEAP 1 int days[31+28+LEAP+31];\rstring constant/literal is sequence of zero or more characters surrounded by double quotes \u0026quot;\u0026quot;.\nTechnically it is an array of characters.\nThe strings internal representation has a null character \\0 at the end. So the physical storage is one one more than number of characters.\nstrlen and other string functions are declared in the standard header \u0026lt;string.h\u0026gt;. It returns length of character string excluding \\0\nint strlen(char s[]) { int i; while (s[i] != \u0026#39;\\0\u0026#39;) ++i; return i; }\r'x' \u0026quot;x\u0026quot; are not the same.\nOne is a an integer representing x, and other is array of characters containing x and \\0\nenumeration constant is a list of constant integer values.\nThe first name in enum has value 0, next 1 so on. Unless explicit values are specified.\nIf not all values are specified, unspecified values continue the progression from the last specified.\nenum boolean (NO, YES); enum escapes (BELL = \u0026#39;\\a\u0026#39;, BACKSPACE = \u0026#39;\\b\u0026#39;, TAB = \u0026#39;\\t\u0026#39;); enum months ( JAN = 1, FEB, MAR, APR, MAY); /* FEB = 2, MAR = 3 etc*/\rNames of enum have to be distinct but values need not be.\nThis can be an alternative to #define\n2.4 Declarations All variables must be declared before use,\ncertain declarations can be made implicitly by content.\nint lower, upper, step; char c, line[1000];\rCan be done individually which allows for adding comments.\nA variable can also be initialized during its declaration.\nchar esc = \u0026#39;\\\\\u0026#39;; int i = 0; int limit = MAXLINE+1; float eps = 1.0e-5;\rThe initializer must be a constant expression as initialization is done only once before the program execution.\nAn explicitly initialized automatic variable is initialized each time the function or block it is in is entered; the initializer may be an expression.\nThe qualifier const can be applied to the declaration of any variable to specify the value will not change. It can be used with any arguments.\nconst double e = 2.7182818;\nconst char msg[] = \u0026quot;warning: \u0026quot;;\nint strlen (const char[]);\nThe result is implementation defined if an attempt is made to change a const\n2.5 Arithmetic Operators + - * / %\nif ((year % 4 == 0 \u0026amp;\u0026amp; year % 100 != 0) || year % 400 == 0) printf(\u0026#34;%d is a leap year\\n\u0026#34;, year); else printf(\u0026#34;%d is not a leap year\\n\u0026#34;, year);\r% cannot be applied to float or double.\n2.6 Relational and Logical Operators Relational operators \u0026gt; \u0026gt;= \u0026lt; \u0026lt;=\nEquality operators == !=\nThese have lower precedence than arithmetic operators.\n\u0026amp;\u0026amp; || is evaluated left to right\nfor (i=0; i \u0026lt; lim-1 \u0026amp;\u0026amp; ( c=getchar()) != \u0026#39;\\n\u0026#39; \u0026amp;\u0026amp; c != EOF; ++i ) s[i] = c;\rBefore reading a new character it is necessary to check that there is room to store it in the array s, so the test i \u0026lt; lim-1 must be made first. If failed, must go to read another character.\n2.7 Type Conversion When an operator has operands of different types, they are converted to a common type according to a small number of rules.\nConverting int to float that happens automatically as there is no loss in information f + i.\nWhere information might loose info, like long to short, or float to int may draw a warning but are not illegal.\nIn arithmetic operator like + * which take two operands, if they are of different type the lower type is promoted to higher type.\nString to numeric equivalent\nint atoi(char s[]) { int i, n; n = 0; for (i=0; s[i] \u0026gt;= \u0026#39;0\u0026#39; \u0026amp;\u0026amp; s[i] \u0026lt;= \u0026#39;9\u0026#39;; ++i) n = 10 * n + (s[i]-\u0026#39;0\u0026#39;); return n; }\rs[i] - '0' gives the numeric value of the character stored in s[i]\n2.8 Increment and Decrement Operators ++ adds one, -- subtracts one.\nBoth can be used as prefix or suffix, both does the job but prefix increments before its values is used, while suffix increments after the value has been used.\nx = n++ x = ++n\n/* squeeze: delete all c from s */ void squeeze(char s[], int c) { int i, j; for (i = j = 0; s[i] != \u0026#39;\\0\u0026#39;; i++) if (s[i] != c) s[j++] = s[i]; s[j] = \u0026#39;\\0\u0026#39;; }\rEach time a non-c occurs, it is copied into the current j position, and only then is j incremented to be ready for the next character. This is equivalent to\nif (s[i] != c) { s[j] = s[i]; j++; }\ralso\nif (c == \u0026#39;\\n\u0026#39;) { s[i] = c; ++i; }\rIn more compact way\nif ( c == \u0026#39;\\n\u0026#39;) { s[i++] = c; }\rTo concatenate a string to end of another string.\nvoid strcat(char s[], char t[]) { int i, j; i = j = 0; while ( s[i] != \u0026#39;\\0\u0026#39; ) /* find end of s */ i++; while ( (s[i++] = t[j++] ) != \u0026#39;\\0\u0026#39; ) ; }\rAs each member is copied from t to s, the postfix ++ is applied to both to make sure they are in position for the next pass through the loop.\ns[i++] = t[j++] i will be in right position!!\nThe check of != '\\0' is odd !!!\n2.9 Bitwise Operators \u0026amp; | ^ \u0026lt;\u0026lt; \u0026gt;\u0026gt; ~\r2.10 Assignment Operators and Expressions i = i + 2 is i += 2\nHere += is the assignment operator.\nMost binary operators have a corresponding assignment operator op= where op is one of + - * / % \u0026lt;\u0026lt; \u0026gt;\u0026gt; \u0026amp; ^ |\nx *= y + 1 is x = x * (y + 1)\nAssignment statement has a value and can occur in expression;\nwhile ((c=getchar()) != EOF)\n2.11 Conditional Expressions To get Z as max(a, b)\nif (a \u0026gt; b) z = a; else z = b;\rThe alternate is using ternary operator ? :\nz = (a \u0026gt; b) ? a : b;\rIf (a \u0026gt; b) is true, then z = a, otherwise z = b\nexpr1 ? expr2 : expr3\nIf 1 is true then 2 is evaluated, if false then 3 is evaluated.\nTo print n elements from an array, 10 per line, with each separated by one blank line including the terminating newline.\nfor (i = 0; i \u0026lt; n; i++) printf( \u0026#34;%6d%c\u0026#34;, a[i], (i%10==9 || i==n-1) ? \u0026#39;\\n\u0026#39; : \u0026#39; \u0026#39; );\r2.12 Precedence and Order of Evaluation Left to right and Right to left associativity.\nWriting code that depends on order of evaluation is a bad programming practice as the order might change depending on the compiler and machine run on.\n","date":"2024-12-18","id":31,"permalink":"/personal-site/docs/c/kr_c_book/kr-chapter-2-types-operators-expressions/","summary":"\u003cp\u003eSection 2.2 - Data types and storage allocation - Character, integer, short, long.\nSection 2.7 - Type conversion\nSection 2.9 - Bit-wise Logical operations\u003c/p\u003e","tags":[],"title":"K\u0026R - Chapter 2 - Types, Operators, Expressions"},{"content":"Section 3.1 - Semicolon across languages\nC, JAVA, PHP use ; as terminator for every statement.\nPython, JavaScript, Shell script use ; as separator, : is terminator.\nSection 3.3 - else if across languages\nIn python elif is a real keyword, while in C, else if is just bad indentation.\nSection 3.4 - Never use the switch statement\nIn exceedingly a rare situation, we might use a \u0026ldquo;jump table\u0026rdquo; where a small integer was used to look up an address \u0026ldquo;Where to go next\u0026rdquo;.\nThis could save a few repeating \u0026ldquo;else if\u0026rdquo; evaluation when computers were slow.\nSection 3.5 - Using comma\nIn C, , is like light version of ;\nWe use it when we are already using a semicolon for something but need two or more statements.\nfor ( i = 0, j = strlen(s)-1; i\u0026lt; j; i++, j++)\nSection 3.5 - Excessive Succinctness / brevity\nwhile ( (c = getchar()) == \u0026#39; \u0026#39; || c == \u0026#39;\\n\u0026#39; || c == \u0026#39;\\t\u0026#39;) ;\rHere Value is accessed, stored in a variable c, compared to see if it is ' ',\nalso compared to see if it is \\n or \\t.\nAll the work has been done in the loop termination test. There is nothing to do in the body of the loop so just a ;\nChapter 3 - Control Flow The control flow statements of a language specify the order in which computations are done.\n3.1 Statements and Blocks An expression followed by a semicolon ; becomes a statement. ; is the statement terminator.\n{} braces are used to group declarations and statements together into a compound statement or block so they are syntactically equal to single statement.\nBecause of this, space and line ends do not matter to C and C-like languages. It is used just to communicate our intent to humans.\n3.2 If-Else if (expression) statement1; else statement2;\rif tests the numeric value of the expression, its true if the value is non zero.\nTo avoid moving a else statement to the inner if\nif (n\u0026gt;0) if (a\u0026gt;b) z = a; else z = b;\rTo avoid this, braces can be used to separate it\nif (n\u0026gt;0) { if (a\u0026gt;b) z = a; } else z = b;\rThe indentation is good to see but compiler doesn\u0026rsquo;t go with that so better to separate using braces.\n3.3 Else-If if (expression) statement else if (expression) statement else statement\rBinary search\nTo find x in a sorted array v with increasing order. Returns position of number in array\nint binarysearch (int x, int v[], int n) { int low, high, mid; low = 0; high = n-1; while ( low \u0026lt;= high) { mid = (low + high)/2; if (x \u0026lt; v[mid]) high = mid +1; else if (x \u0026gt; v[mid]) low = mid + 1; else /* match found */ return mid; } return -1 /* No match */ }\r3.4 Switch switch (expression) { case const_expr: statements case const_expr: statements default: statements }\rThe switch statement is a multi-way decision that tests whether an expression matches one of a number of constatnt integer values, and branches accordingly.\nThe execution starts from the case that matches. default executes if nothing matches, its optional like the else.\nbreak causes an immediate exit from the switch.\nIf there is no explicit break, or return the execution falls through to the next level.\nfall through can be used by attaching multiple cases to a single action. which should be used sparingly.\nIts best defensive programming to add break to each case and include default.\n3.5 Loops - While and For while (expression) statement\rif expression evaluation gives non-zero value, the statement is evaluated.\nThis continues till the expression evaluates to zero.\nfor (expr1; expre2; expre3) statement for (i=0; i\u0026lt;10; i++) statement\rThis is equivalent to\nexpre1; while (expre2) { statement expre3; }\rAny three part can be omitted but the semicolon must remain.\nDropping the second one makes it forever true so break and return can be used.\nIt is better to use while when there is no re-initialization and increment.\nwhile ( (c = getchar()) == \u0026#39; \u0026#39; || c ==\u0026#39;\\n\u0026#39; || c == \u0026#39;\\t\u0026#39; ) ; /* Skip white space characters*/\rfor loop is preferable when there is a simple initialization and increment. It keeps the loop control visible at the top of the loop.\nfor ( i = 0; i\u0026lt;n; i++) ...\rShell sort Far apart elements are compared rather than adjacent ones as in simple interchange sort.\nvoid shellsort (int v[], int n) { int gap, i, j, temp; for (gap = n/2; gap \u0026gt; 0; gap /= 2) for (i = gap; i \u0026lt; n; i++) for (j = i-gap; j \u0026gt;= 0 \u0026amp;\u0026amp; v[j] \u0026gt; v[j+gap]; j -= gap) { temp = v[j]; v[j] = v[j+gap]; v[j+gap] = temp; } }\rUsing , to put multiple expressions which are evaluated left to right. The type and value of the result are the type and value of the right operand.\nvoid reverse(char s[]) { int c, i, j; for (i=0, j = strlen(s)-1; i \u0026lt; j; i++, j--) { c = s[i]; s[i] = s[j]; s[j] = c; } }\r3.6 Loops - Do-While do-while tests at the bottom, after making each pass through the loop of the body; the body is always executed at least once.\ndo statement while (expression);\r3.7 Breaks and Continue break gives a way to exit the loops early without the tests at the top or bottom.\nremoving trailing blanks, tabs, newlines\nint trim(char s[]) { int n; for ( n = strlen(s)-1; n \u0026gt;= 0; n--) if ( s[n] != \u0026#39; \u0026#39; \u0026amp;\u0026amp; s[n] != \u0026#39;/t\u0026#39; \u0026amp;\u0026amp; s[n] != \u0026#39;\\n\u0026#39;) break; s[n+1] = \u0026#39;\\0\u0026#39;; return n; }\rstrlen returns the length of the string. The for loop starts at the end and scans backwards looking for the first character that is not a blank or tab or newline.\ncontinue causes next iteration of the enclosing loop to begin.\nIt doesn\u0026rsquo;t apply to switch.\nfor (i = 0; i \u0026lt; n; i++) if (a[i] \u0026lt; 0) /* skips negative values */ continue; ... /* do positive elements */\r3.8 Goto and Labels goto is used sometime to break out of multiple deeply nested loops at once.\nbreak only exists from the inner most loop. ( goto is never used, exceptions, throw catch is preferred )\nfor ( ... ) for ( ... ) { ... if (disaster) goto error; } ... error: /* clean up the mess */\rA label has same form as a variable name and is followed by a colon.\nIt can be attached to any statement in the same function as the goto.\nThe scope of the label is the entire function.\n","date":"2024-12-18","id":32,"permalink":"/personal-site/docs/c/kr_c_book/kr-chapter-3-control-flow/","summary":"\u003cp\u003e\u003cstrong\u003eSection 3.1 - Semicolon across languages\u003c/strong\u003e\u003cbr\u003e\nC, JAVA, PHP use \u003ccode\u003e;\u003c/code\u003e as terminator for every statement.\u003cbr\u003e\nPython, JavaScript, Shell script use \u003ccode\u003e;\u003c/code\u003e as separator, \u003ccode\u003e:\u003c/code\u003e is terminator.\u003c/p\u003e","tags":[],"title":"K\u0026R - Chapter 3 - Control Flow"},{"content":"Section 4.1 - Automatic variables, parameters and stack\nStack - last in first out implementation\nCall by value says within a function, parameter can be changed but doesn\u0026rsquo;t affect the variable in main. Parameters are \u0026ldquo;isolated\u0026rdquo; within the function. This is accomplished using stack.\nstack frames were used to the variables of function and removed when it is exited.\nSection 4.3 - Why arrays pass by reference\nA string in python passed as argument to function acts like a cal by value, not changing things outside of function.\ndef zap(y): print (\u0026#39;Y start zap:\u0026#39;, y) y = \u0026#39;CHANGED\u0026#39; print ( \u0026#39;Y end zap:\u0026#39;, y) x = \u0026#39;ORIGINAL\u0026#39; print(\u0026#39;X before zap:\u0026#39;, x) zap(x) print(\u0026#39;X after zap:\u0026#39;, x) # X before zap: ORIGINAL # Y start zap: ORIGINAL # Y end zap: CHANGED # X after zap: ORIGINAL\rThis happens as value Y was a pointer to it, when it changed in zap it did not affect the pointer of X in main.\nIn C, string is a character array, where array passes by reference.\nSimilar code as above will result in\n// X before zap: ORIGINAL // Y start zap: ORIGINAL // Y end zap: CHANGED // X after zap: CHANGED The array \u0026rsquo;location\u0026rsquo; is passed by \u0026lsquo;value\u0026rsquo; ( a copy made into the stack frame of location) but no copy is made of the data in the array. (so it is pass by location)\nSince function knows where the data is, it can change the data.\nSection 4.7 - Register variables\nRegister variables are from assembly language which was necessary for performance.\nThere is no way to get the \u0026ldquo;memory address\u0026rdquo; of a variable declared as register.\nLikely completely ignored in modern compilers.\nregister int x;\nregister char c;\nSection 4.10 - Recursion\nWhen a function calls itself it is called \u0026ldquo;recursion\u0026rdquo;\nUsed for writing good code in special situations like parsing expressions like\n(5 * 2) + ( (6 + 5) * 9) or traversing tree like structures. Uses call stack which can be inefficient as new stack frames get added to the stack with variables and automatic variables.\nSection 4.11 - Pre-processor - Compiler architecture\nThere has been many evolution in language, library, hardware and operating system. C always operates in an environment, even though the language has changed\nThe Pre-processor allowed for adjusting to these changes without breaking backwards compatibility.\nIt is not a compiler, it is a C source code to C source code translator. It expands the include files, also many # sign.\n#include \u0026lt;stdio.h\u0026gt; #ifdef USE_LONG #define INT_32 long #else #define INT_32 int #endif\rChapter 4 - Function and Program Structure Functions break large computing tasks into smaller ones and enables others to build upon what others have done instead of starting over from scratch.\n4.1 Basics of Functions Each function definition has the form\nreturn-type function-name (argument-declarations) { declarations and statements }\rIf the return type is omitted, int is assumed.\nCommunication between the function is through arguments and and values returned by the functions, and through external variables.\nFunction can be in any order and in multiple files.\nreturn expression, the expression will be converted to the return-type if necessary.\nControl returns to the caller even when there is no expression.\nCompiling and Running\ncc command compiles the mentioned file or files.\ncc main.c getline.c strindex.c , this compiles the source files into object files\nmain.o getline.o strindex.o and loads them all into an executable file called a.out\n4.2 Functions Returning Non-integers If a name which has not been previously declared occurs in an expression and followed by a left parenthesis, it is declared by context to be a function name.\nwhile (get_line(line, MAXLINE) \u0026gt; 0)\nA type has to be declared to a function as to what it returns,\nvoid type was invented to show a function which returns nothing.\nTo convert a string to a double precision floating point number using atof, it should be preceded by the type of it.\ndouble atof (char s[]) {}\ndouble sum, atof (char s[]) multiple declarations.\nSecond, the calling routine must know that atof returns a non-int value by declaring atof explicitly.\nIf the function takes arguments, declare them; If it takes no arguments, use void\nint atoi (char s[]) { double atof(char s[]); return (int) atof(s); }\rHere the the return of atof which is a double is converted to int and returned from atoi\n4.3 External Variables Internal which describes the arguments and automatic variables defined inside functions. External variables are globally accessible, they provide an alternative to function arguments and returned values for communicating data between functions. Any function can access this by referring to its name.\nC does not allow functions to be defined inside other functions, so functions are always external.\nAny function may access an eternal variable by referring to it by name.\nIf a large number of variables have to be shared between functions, then external variables are more convenient than a long argument lists.\nExternal variables are also more useful because of their greater scope and lifetime.\nAutomatic variables are internal to a function which come into existence when the function is entered and disappears when it is left.\n4.4 Scope Rules The scope of a name is the part of the program over which the name is defined.\nFor an automatic variable declared at the beginning of a function, the scope is the function in which the name is declared.\nVariables of the same name in different functions are unrelated. Same is true for the arguments of a function.\nIf an external variable is to be referred before it is defined, or if it is defined in a different source file from the one where it is being used, then an extern declaration is mandatory.\nA declaration announces the property of a variable (primarily its type, size);\nA definition also cases storage to be set aside.\nint sp; double val[MAXVAL];\rappear outside any function, they define the external variables int and val, causes storage to be set aside, and also serve as the declarations for the rest of the source file.\nextern int sp; extern double val[];\rdeclare for the rest of the source file that sp is an int and val is a double array (size to be determined and allocated elsewhere) but they do not create the variables or reserve storage for them.\nThere must be only one definition of an external variable among all files that make up the source program;\nother files must contain extern declaration to access it.\nThere maybe a extern declaration within the file having the definition.\nAny initialization of an external variable goes only with the definition. Array size must be specified with the definition, but are optional with extern declaration.\n// in file 1: extern int sp; extern double val[]; void push (double f) { ... } double pop(void) { ... } // in file 2: int sp = 0; double val[MAXVAL];\rSince extern declaration lies outside the function in file one, they apply to all functions; one set of declarations suffice for all file one.\n4.5 Header Files It is probably best to have one header file that contains everything that is to be shared between any two parts of the program like definitions and declarations; So that there will be only one copy to get and keep right as the program evolves.\nThese common material are placed in a header file calc.h which will be included as necessary in other files.\n// calc.h #define NUMBER \u0026#39;0\u0026#39; void push(double); double pop(void); int getop(char[]); int getch(void); void ungetch(int);\r// main.c #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h? #include \u0026#34;calc.h\u0026#34; #define MAXOP 100 main() { ... }\r4.6 Static Variables The static declaration, applied to an external variable or function, limits the scope of that object to the rest of the source file being compiled only.\nSo it provides a way to hide names which must be external but yet should not be visible to users of other files.\nstatic char buf[BUFSIZE]; static int bufp = 0; int getch(void) { ... } void ungetch(int c) { ... }\rNo other routines will be able to access buf bufp and those names will not conflict with the same names in other files of the same program.\nFunctions are global, visible to any part of the entire program. If a function is declared static, its name is invisible outside the file in which is declared.\nInternal static variables are local to a particular function just as automatic variables, but they remain in existence rather than coming and going each time the function is activated. This means that the internal static variables provide private, permanent storage within a single function.\n4.7 Register Variables register variables are to be placed in the machine registers which may result in faster programs. Which means register declaration advises the compiler that the variable will be heavily used.\nBut compilers are free to ignore the advice.\nregister int x; register char c;\rregister variables can only be applied to automatic variables and parameters of a function.\nf(register unsigned m, register long n) { register int i; ... }\rDue to hardware imitation, only few variables in each function may be kept in registers and only certain types are allowed.\nIt is not possible to take address of a register variable, regardless of it is placed in a register or not.\n4.8 Block Structure Function cannot be defined within a function but a variable can be defined in a block-structured fashion within a function.\nvariables declared in this way hide any identically named variable in outer block, and remain in existence until the matching right brace.\nif (n\u0026gt;0) { int i; /* declaring a new i */ for ( i = 0; i\u0026lt;n; i++) ... }\rAutomatic variables and formal parameters also hide eternal variables and functions of the same name. Better to avoid using same names which conceal names in outer scope to avoid confusion.\n4.9 Initialization In the absence of explicit initialization, external and static variables are guaranteed to be initialized to zero;\nautomatic and register variables have undefined (garbage) initial values.\nScalar variables, may be initialized when they are defined, by following the name with an equal sign and an expression.\nint x = 1; char squota = \u0026#39;\\\u0026#39;\u0026#39;; long day = 100L * 60L * 60L * 24L // milliseconds in a day external and static variables, the initializer must be a constant expression; the initialization is done once, conceptually before the program begins execution.\nautomatic and register variables, the initializer is not restricted to being a constant; it can even be a previously defined value, even function calls.\nInitializing a array of int, supplying initializer less than specified length adds zero, supplying more causes errors.\nThere is no way to initialize an element in the middle of an array without supplying all preceding values.\nint days[] = {31, 28, 31, ...}\nCharacter arrays are a special case of initialization; a string may be used instead of the braces and commas notation.\nchar pattern = \u0026quot;ould\u0026quot;;\nchar patter[] = { 'o', 'u', 'l', 'd', '\\0' };\n4.10 Recursion A function may call itself directly or indirectly.\nWhen a function calls itself recursively, each invocation gets a fresh set of all the sutomatic variables independent of the previous set.\nQuick sort using the middle of array for partitioning.\nvoid qsort(int v[], int left, int right) { int i, last; void swap(int v[], int i, int j); if (left \u0026gt;= right) return; /* Less than 2 elements, do nothing */ swap(v, left, (left + right)/2 ); last = left; for ( i = left + 1; i \u0026lt;= right; i++) if (v[i] \u0026lt; v[left]) swap(v, ++last, i); swap(v, left, last); qsort(v, left, last-1); qsort(v, last+1, right); } void swap (int v[], int i, int j) { int temp; temp = v[i]; v[i] = v[j]; v[j] = temp; }\rThe standard library includes a version of qsort that can sort objects of any type.\n4.11 The C Preprocessor Preprocessor is a separate first step in compilation.\nexamples, #include to include the contents of a file during compilation,\n#define to replace a token by an arbitrary sequence of characters.\n4.11.1 File Inclusion #include \u0026quot;filename\u0026quot; or #include \u0026lt;filename\u0026gt; is replaced by the contents of the file name.\nIf the file name is quoted, searching for the file typically begins where the source program was found; if it is not there, or file name has \u0026lt;\u0026gt;, searching follows an implementation defined rule to find the file.\nAn included file may itself contain #include lines.\n4.11.2 Macro Substitution #define name replacement text\nsubsequent occurrences of the token name will be replaced by the replacement text.\n4.11.3 Conditional Inclusion Controlling pre-processing itself with conditional statements that are evaluated during pre-processing.\n#if !defined(HDR) #define HDR #endif\r#if SYSTEM == SYSV #define HDR \u0026#34;sysv.h\u0026#34; #elif SYSTEM == BSD #define HDR \u0026#34;basd.h\u0026#34; #elif SYSTEM == MSDOS #define HDR \u0026#34;msdos.h\u0026#34; #else #define HDR \u0026#34;default.h\u0026#34; #endif #include HDR\r#ifdef #ifndef\n","date":"2024-12-18","id":33,"permalink":"/personal-site/docs/c/kr_c_book/kr-chapter-4-function-program-structure/","summary":"\u003cp\u003e\u003cstrong\u003eSection 4.1 - Automatic variables, parameters and stack\u003c/strong\u003e\u003cbr\u003e\nStack - last in first out implementation\u003cbr\u003e\nCall by value says within a function, parameter can be changed but doesn\u0026rsquo;t affect the variable in main. Parameters are \u0026ldquo;isolated\u0026rdquo; within the function. This is accomplished using stack.\u003cbr\u003e\nstack frames were used to the variables of function and removed when it is exited.\u003c/p\u003e","tags":[],"title":"K\u0026R - Chapter 4 - Function, Program Structure"},{"content":"Section 5.1 - Pointers\nPointers are where we move \u0026ldquo;below abstraction\u0026rdquo;, where C can replace assembly language.\n#include \u0026lt;stdio.h\u0026gt; int main() { int x, y; int* px; x = 42; px = \u0026amp;x; y = *px; printf( \u0026#34;%d %p %d\\n\u0026#34;, x, px, y); } // 42 0x16f5b31ec 42 int* integer of type pointer\n\u0026amp;x to get the address of x\n*px a look up operator or de-reference operator to get the value in location.\nSection 5.2 - Call by Reference / Call by value\nPointers give the ability to call by reference.\nSection 5.4 - Pointer arithmetic\nA pointer to a integer is different than a pointer to a character.\nThe addresses are of the same size, but If one is added to character, one added.\nIf one is added to an integer, it adds four. as integers take four characters.\nSo it is a pointer to a thing with a type that is pointed to. So type is important.\n#include \u0026lt;stdio.h\u0026gt; int main() { char ca[10], *cp; int ia[10], *ip; cp = ca + 1; ip = ia + 1; printf( \u0026#34;ca %p cp %p\\n\u0026#34;, ca, cp); printf( \u0026#34;ia %p ip %p\\n\u0026#34;, ia, ip); }\rSection 5.6 - Pointers are not integers\nTreating pointers as integer almost works.\nAddresses are positive numbers that start from zero.\nVoid Pointer - provided a way to return a \u0026ldquo;generic\u0026rdquo; address of memory without choosing the type of the data that would be stored in the memory.\nvoid * alloc()\nint *val = (int *) alloc(42)\nBuffer overflow\nThe most major security threat, A string has no length, but no run time length so excess is stored it keeps on storing beyond its limit into other part of the program, overflowing.\nDo not use gets() for input.\nSection 5.7, 5.10 to 5.12 skim\nChapter 5 - Pointers and Arrays A pointer is a variable that contains the address of a variable.\nPointers and Arrays are closely related.\nThe type void * (pointer to void) replaces char * as the proper type for a generic pointer.\n5.1 Pointers and Addresses A pointer is a group of cells (often two or four) that can hold an address.\nIn memory, any byte can be a char,\na pair of one-byte cells are short and\nfour adjacent bytes form a long.\n$ is the Unary operator that gives the address of an object,\nso p = \u0026amp;c; assigns the address of c to variable p,\nand p is said to \u0026lsquo;point to\u0026rsquo; c.\nThe \u0026amp; operator applies only to objects in memory like variables and array elements.\nNot to expressions (x+1) \u0026amp;3, constants or register variables.\n* is the in-direction or de-referencing operator; * treats its operand as the ultimate target, and accesses that address to fetch the contents. (When applied to a pointer, it accesses the object the pointer points to) y = *p\nx and y are integers and ip is a pointer to int.\nint x = 1, y = 2, z[10]; int *ip; // pointer to int ip = \u0026amp;x; // now points to x y = *ip; // y is now 1, i.e y = x *ip = 0; // x = 0 ip = \u0026amp;z[0]; // ip now points to z[0] int The declaration int *ip; is an mnemonic, meaning *ip is an int\ndouble *dp, atof(char *);\n*dp and atof(s) have values of double, and\nthe argument of of atof is a pointer to char.\nEvery pointer points to a specific datatype; A pointer points to a particular kind of object. (exception, a pointer to void is used to hold any type of pointer but cannot be de-referenced itself)\nIf ip points to (address of) integer x , then *ip can occur in any context where x could.\n*ip = *ip + 10; // increment x by 10 // incrementing the value by 1, different methods y = *ip + 1; *ip += 1; ++*ip; (*ip)++\rSince unary operators like * ++ associate right to left, the () needed to increment what ip points to instead of ip itself.\n(removing the * would increment the position of pointer by one bit)\nSince pointers are variables, they can be used without de-referencing.\nSuppose iq is another pointer to int\niq = ip copies the content of ip to iq, making it point to whatever ip was pointing to.\n(\u0026amp;x gets address of x, ip has just address, *ip gets the object from address/value)\n5.2 Pointers and Function Arguments Pointer arguments allow a function to access and change objects in the function that called it.\nCall by Value C passes arguments to functions by value, so the called function cannot alter the variable in the calling function.\nvoid swap(int x, int y) // wrong { int temp; temp = x; x = y; y = temp; }\rFunction swaps the copies of a and b, cannot affect the arguments a and b in the routine that called it.\nBy passing Pointers to the values, it can be swapped.\nswap(\u0026amp;a, \u0026amp;b); void swap(int *px, int *py) // pointers of x and y { int temp; temp = *px; *px = *py; *py = temp; }\r5.3 Pointers and Arrays Any operation that can be achieved by array sub-scripting can also be done with pointers.\nint a[10]; defines array of size 10, with objects named from a[0]...a[9]\na[i] refers to the i th element of the array.\nint *pa;\npa = \u0026amp;a[0];\nSets pa the pointer/address to element zero of a.\nx = *pa will copy the first element of array a[0] into x.\nThen pa+1 will point to the next element. which is pointer arithmetic.\nSo the corresponding between indexing and pointer arithmetic is very close.\nBy definition, The value of a variable or expression of type array is the address of the zero element of the array.\npa = \u0026amp;a[0];. pointer pa and array a has the same value. so pa = a; is also same.\na[i] is equal to * (a+i)\nmeaning the location is gotten by taking location of a and adding i places to it.\nIf pa is a pointer, pa[i] is identical to * (pa+i).\nIn short, array-index expression is equivalent to one written as a pointer and offset.\nThere is one difference,\nA pointer is a variable, so pa = a and pa++ are legal.\nArray names are not a variable; so a = pa and a++ are illegal. (incrementing array??)\nWhen an array name is passed to a function, the location of the initial element is passed. In that called function, this argument is a local variable.\nAn array name parameter is a pointer (a variable containing an address)\nint strlen(char *s) { int n; for (n = 0; *s != \u0026#39;\\0\u0026#39;, s++) n++; return n; }\rSince s is a pointer, incrementing is legal. s++ has no effect on the character string but merely increments strlen private copy of the pointer.\nchar s[]; and char *s; are equivalent.\nIt is also possible to pass part of an array by passing the pointer to beginning of the subarray.\nif a is an array, f(\u0026amp;a[2]) and f(a+2) both pass the function f the address of subarray which starts at a[2].\nWithin f the parameter declaration can be,\nf(int arr[]) { ... } // or f(int *arr) { ... }\rIf elements exist, it also possible to index backwards in an array p[-1] p[-2] and so on which refer to the elements that precede p[0]\n5.4 Address Arithmetic If p is a pointer, then p++ increments p to point to the next element of whatever kind of object p points to.\np+=i increments p to i elements beyond where it currently does.\nThese are the simplest pointer or address arithmetic.\nRudimentary storage allocator alloc(n) and afree(p). The storage managed by these are a stack, last-in, first-out.\nThe standard library provides malloc and free that have no such restrictions.\nPointer subtraction is also valid: if p and q point to members of the same array, p-q is the number of elements between p \u0026amp; q.\nstrlen(s) char *s; { char *p = s; while(*p != \u0026#39;\\0\u0026#39;) p++; return(p-s); }\rp is initialized to s, to point to the first character.\np++ advances p to next character each time, and p-s gives the number of characters advanced over, that is the length of the string.\nPointer arithmetic is consistent, if we had been dealing with float's which occupy more storage than char, and if p were a pointer to float, p++ would advance to the next float.\nAll the pointer manipulations automatically take into account the size of the object pointed to, so nothing else has to be altered.\nExcept adding, subtracting a pointer and integer and comparing two pointers, all other pointer arithmetic are illegal.\nAdding two pointers or multiply or divide or shift or mask or add float or double to them is not permitted.\n5.5 Character Pointers and Functions A string constant is an array of characters with \\0 so the programs can find the end.\nAs an argument to a function, like printf(\u0026quot;Hello\\n\u0026quot;);\nThe access to it is given by a character pointer to the beginning of the character array.\nC does not provide any operators for processing whole string of characters as a unit. char *pmessage which initializes a pointer .\npmessge = \u0026quot;now is the time\u0026quot; this assigns a pointer to the character array.\nchar amessage[] = \u0026quot;now is the time\u0026quot;; this is an array.\nchar *pmessage = \u0026quot;now is the time\u0026quot;; is a pointer.\namessage is an array, just big enough to hold the sequence of characters and \\0 that initializes it.\nIndividual characters within the array may be changed but amessage will always refer to the same storage.\npmessage is a pointer, initialized to point to a string constant; the pointer may subsequently be modified to point elsewhere but the result is undefined if the string constant is modified.\nTo copy string t to string s. ???\nvoid strcpy(char *s, char *t) { int i; i = 0; while ( (s[i] = t[i]) != \u0026#39;\\0\u0026#39; ) i++; }\rvoid strcpy(char *s, char *t) { int i; i = 0; while ( (*s = *t) != \u0026#39;\\0\u0026#39; ) { s++; t++; } }\rvoid strcpy(char *s, char *t) { while ( (*s++ = *t++) != \u0026#39;\\0\u0026#39;) ; }\rthis moves the increment of s and t into the part of the loop.\n5.6 Pointer Arrays; Pointers to Pointers Since pointers are variables themselves, they can be stored in array just as other variables.\nWhen sorting, two out of order lines which have to be exchanged, the pointers in the pointer array are exchanged, not the text lines themselves. which avoids complicated storage management with moving the lines themselves.\n5.7 Multi-dimensional Arrays 5.8 Initialization of Pointer Arrays Pointer Arrays; Pointers to pointers\nThe pointers themselves can be stored in an array. . . .\n5.9 Pointers vs Multi-dimensional Arrays 5.10 Command-line Arguments 5.11 Pointers to Functions 5.12 Complicated Declarations ","date":"2024-12-18","id":34,"permalink":"/personal-site/docs/c/kr_c_book/kr-chapter-5-pointers-arrays/","summary":"\u003cp\u003e\u003cstrong\u003eSection 5.1 - Pointers\u003c/strong\u003e\u003cbr\u003e\nPointers are where we move \u0026ldquo;below abstraction\u0026rdquo;, where C can replace assembly language.\u003c/p\u003e\n\r\n\r\n\r\n\u003cdiv class=\"expressive-code\"\u003e\r\n  \u003cfigure class=\"frame not-content\"\u003e\r\n  \u003cfigcaption class=\"header\"\u003e\r\n    \u003cspan class=\"title\"\u003e\u003c/span\u003e\r\n  \u003c/figcaption\u003e\r\n  \u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-c\" data-lang=\"c\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cp\"\u003e#include\u003c/span\u003e \u003cspan class=\"cpf\"\u003e\u0026lt;stdio.h\u0026gt;\u003c/span\u003e\u003cspan class=\"cp\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cp\"\u003e\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"kt\"\u003eint\u003c/span\u003e \u003cspan class=\"nf\"\u003emain\u003c/span\u003e\u003cspan class=\"p\"\u003e()\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\u003cspan class=\"kt\"\u003eint\u003c/span\u003e \u003cspan class=\"n\"\u003ex\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003ey\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\u003cspan class=\"kt\"\u003eint\u003c/span\u003e\u003cspan class=\"o\"\u003e*\u003c/span\u003e \u003cspan class=\"n\"\u003epx\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\u003cspan class=\"n\"\u003ex\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"mi\"\u003e42\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\u003cspan class=\"n\"\u003epx\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026amp;\u003c/span\u003e\u003cspan class=\"n\"\u003ex\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\u003cspan class=\"n\"\u003ey\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"n\"\u003epx\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\u003cspan class=\"nf\"\u003eprintf\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e \u003cspan class=\"s\"\u003e\u0026#34;%d %p %d\u003c/span\u003e\u003cspan class=\"se\"\u003e\\n\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003ex\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003epx\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003ey\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e//  42  0x16f5b31ec  42\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\r\n  \u003c/figure\u003e\r\n\u003c/div\u003e\r\n\u003cp\u003e\u003ccode\u003eint*\u003c/code\u003e integer of type pointer\u003cbr\u003e\n\u003ccode\u003e\u0026amp;x\u003c/code\u003e to get the address of x\u003cbr\u003e\n\u003ccode\u003e*px\u003c/code\u003e a look up operator or de-reference operator to get the value in location.\u003c/p\u003e","tags":[],"title":"K\u0026R - Chapter 5 - Pointers, Arrays"},{"content":"Mid Chapter Surprise\nStructures 6.1 - 6.4 - New type\nData Structures 6.5, 6.6 - Applications of structures\n6.1 Structures\nA structure is a user defined type that contain one or more types that can be treated as a unit.\nThe elements or variables mentioned in a structure are called members\nThe dot operator allows us to access the members of the structure.\n# include \u0026lt;stdio.h\u0026gt; int main() { struct point { double x; double y; }; struct point p1, p2; p1.x = 3.0; p1.y = 4.0; p2 = p1; printf( \u0026#34;%f %f\\n\u0026#34;, p2.x, p2.y); } // 3.000000 4.000000 call by value in structure\n#include \u0026lt;stdio.h\u0026gt; struct point { double x; double y; }; void func(pf) struct point pf; { pf.x = 9.0; pf.y = 8.0; printf(\u0026#34;func %f %f\\n\u0026#34;, pf.x, pf.y); } int main() { struct point pm; pm.x = 3.0; pm.y = 4.0; printf( \u0026#34;main %f %f\\n\u0026#34;, pm.x, pm.y); func(pm); printf( \u0026#34;back %f %f\\n\u0026#34;, pm.x, pm.y); } /* main 3.000000 4.000000 func 9.000000 8.000000 back 3.000000 4.000000 */ Defining a new type called point, then making objects of that type and initializing its members.\nThe passed struct to function is also accepted as struct\n6.2 Structures and Pointers\n#include \u0026lt;stdio.h\u0026gt; int main() { struct point{ double x; double y; }; struct point pt, *pp; pp = \u0026amp;pt; pt.x = 3.0; (*pp).y = 4.0; printf(\u0026#34;%p %f %f\\n\u0026#34;, pp, (*pp).x, pp-\u0026gt;y ); } // 0x16d72fle0 3.000000 4.000000 Pointer *pp also needs a type it represents. here it is a struct\nTo pass a structure by reference / address using \u0026amp;\n#include \u0026lt;stdio.h\u0026gt; struct point { double x; double y; }; void func(pp) struct point *pp; { pp-\u0026gt;x = 9.0; pp-\u0026gt;y = 8.0; printf(\u0026#34;func %f %f\\n\u0026#34;, pp-\u0026gt;x, pp-\u0026gt;y); } int main() { struct point pm; pm.x = 3.0; pm.y = 4.0; printf( \u0026#34;main %f %f\\n\u0026#34;, pm.x, pm.y); func(\u0026amp;pm); printf( \u0026#34;back %f %f\\n\u0026#34;, pm.x, pm.y); } /* main 3.000000 4.000000 func 9.000000 8.000000 back 9.000000 8.000000 */ func(\u0026amp;pm); passes the address of pm to the function,\nThe type in func is defined as struct point *pp means we are getting as parameter an address, not the value, The value will be struct.\nNow pp points to pm and members are changed.\n6.2 Storage Allocation\nsizeof() operator to find the size of something in characters.\n#include \u0026lt;stdio.h\u0026gt; int main() { struct point { double x; double y; }; struct point pt, *pp; printf(\u0026#34;sizeof pt %ld\\n\u0026#34;, sizeof(pt)); printf(\u0026#34;sizeof pp %ld\\n\u0026#34;, sizeof(pp)); printf(\u0026#34;sizeof point %ld\\n\u0026#34;, sizeof(struct point)); // size of a type } /* sizeof pt 16 sizeof pp 8 sizeof point 16 */\r6.2 Dynamic memory allocation\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; int main() { struct point { double x; double y; }; struct point *pp; pp = (struct point *) malloc(sizeof(struct point)); pp-\u0026gt;x = 3.0; (*pp).y = 4.0; printf(\u0026#34;%p %f %f\\n\u0026#34;, pp, (*pp).x, pp-\u0026gt;y); } // 0x600002a 3.000000 4.000000 stdlib.h has to be included to use malloc\n*pp represents the 8 character address, not the struct two doubles of 16 bits.\nmalloc(sizeof(struct point) will find free memory of character size 16.\n(struct point *) casting the returned address from malloc, pointer to a point ????\n6.5.1 A list of Strings\nCombining Dynamic memory and Structures to create lists\nPrinting out lines in a file using lists in python.\nlines = list() hand = open(\u0026#39;romeo.txt\u0026#39;) for line in hand: lines.append(line.rstrip()) for line in lines: print(line)\r6.5.1 Self Referential Structures\nIn C we need to create build a list() structure before we can use it.\nThe entries in the list will be stored in dynamically allocated memory.\nEach list entry contains some data and links to other members of the list using pointers.\nstruct lnode { char *text; // pointer to a character array struct lnode *next; };\rLinked Lists\nstruct lnode { char *text; struct lnode *next; }; struct lnode *head; struct londe *tall;\rHead points to the first item in the list, there is text and next in it, next is the address to the next thing.\nTail has text and the next will be Null, which is indicator of end of list.\nwhile(fgets(line, MAXLINE, stdin) != NULL) { char *save = (char *) malloc(strlen(line)+1 ); strcpy(save, line); struct lnode *new = (struct lnode *) malloc(sizeof(struct lnode)); if ( tail != NULL ) tail-\u0026gt;next = new; new-\u0026gt;text = save; new-\u0026gt;next = NULL; tail = new; if ( head == NULL ) head = new; }\rwhile(fgets(line, MAXLINE, stdin) != NULL) {\nreads a value into (line) automatic character array variable (max 1000 characters).\nchar *save = (char *) malloc(strlen(line)+1 );\nstrcpy(save, line);\nAllocate memory for the new line and copy the contents from line to save.\nAllocating memory for a new string using malloc, which is given the length of string plus one extra line end character. The address is cast to a char *, it is assigned to save.\nAllocating memory for a new sruct lnode.\nstruct lnode *new = (struct lnode *)\nmalloc (sizeof(struct lnode));\nif ( tail != NULL ) tail-\u0026gt;next = new;\nAppend the new node to the end of the linked list.\nnew-\u0026gt;text = save;\nPoint to text pointer in the lnode to the recently allocated copy of line.\nnew-\u0026gt;next = NULL;\nMark the newly allocated struct lnode as the last item in the list using NULL\ntail = new;\nUpdate tail to point to the newly allocated the last item in the list.\nDraw a Picture and arrows\nWalking the list\nDeleting the node (First, middle, last)\n6.5.1 Doubly Linked list\nDoubly linked list allows for reversing a string easy.\nTo scan a linked list in reverse, we need a \u0026ldquo;previous\u0026rdquo; entry in addition to the \u0026ldquo;next\u0026rdquo; entry. Since it has links to both, it is called doubly linked list pointing to front and back.\nstruct lnode { char *text; struct lnode *prev; struct lnode *next; }; int main() { struct lnode *head = NULL; struct lnode *tail = NULL; struct lnode *current; char line[MAXLINE]; while(fgets(line, MAXLINE, stdin) != NULL) { char *save = (char *) malloc(strlen(line)+1 ); strcpy(save, line); struct lnode *new = (struct lnode *) malloc(sizeof(struct lnode)); if ( tail != NULL ) tail-\u0026gt;next = new; new-\u0026gt;text = save; new-\u0026gt;next = NULL; new-\u0026gt;prev = tail; tail = new; if ( head == NULL ) head = new; } for (current = tail; current != NULL; current = current-\u0026gt;prev ) { printf( \u0026#34;%s\u0026#34;, current-\u0026gt;text); } }\r6.8 Unions\nA union is like a structure but all of the elements of the union overlap and allow you to view the same area of memory as multiple types.\n","date":"2024-12-18","id":35,"permalink":"/personal-site/docs/c/kr_c_book/kr-chapter-6-structures/","summary":"\u003cp\u003eMid Chapter Surprise\u003cbr\u003e\nStructures 6.1 - 6.4 - New type\u003cbr\u003e\nData Structures 6.5, 6.6 - Applications of structures\u003c/p\u003e\n\u003cp\u003e\u003cem\u003e\u003cstrong\u003e6.1 Structures\u003c/strong\u003e\u003c/em\u003e\u003cbr\u003e\nA structure is a user defined \u003ccode\u003etype\u003c/code\u003e that contain one or more types that can be treated as a unit.\u003cbr\u003e\nThe elements or variables mentioned in a structure are called \u003ccode\u003emembers\u003c/code\u003e\u003cbr\u003e\nThe dot operator allows us to access the members of the structure.\u003c/p\u003e","tags":[],"title":"K\u0026R - Chapter 6 - Structures"},{"content":"Chapter 6 - Structures A structure is a collection of one or more variables, possibly of different types, grouped together under a single name for convenient handling.\nStructures help to organize complicated data, allowing a group of related variables to be treated as a unit instead of separate entities.\nEmployee has many attributes, a point is a pair of co ordinates etc.\n6.1 Basics of Structures The keyword struct introduces a structure declaration, which is a list of declarations enclosed in braces.\nAn optional name called structure tag may follow the struct keyword. (here point) which can be used as shorthand.\nThe variables names in it are called members.\nBasic object is a point which has x and y co-ordinate, both integers.\nstruct point { int x; int y; };\rA structure member or tag and an ordinary variable can have the same name without conflict, since they can always be distinguished by context.\nThe same member name may occur in closely related objects.\nA struct declaration defines a type. The right brace that terminates the list of members may be followed by a list of variables, just as any basic types.\nstruct { ... } x, y, z; is similar to int x, y, z;\nin a sense, it declares x, y, z to be variables of the named type and sets aside space for them.\nA structure declaration that is not followed by a list of variables reserves no storage; it merely describes a template or shape of a structure.\nstruct point pt;\ndefines a variable pt which is a structure of type struct point.\nstruct date { int day; int month; int year; int yearday; char mon_name[4]; }; struct date d = { 14, 7, 1776, 186, \u0026#34;JUl\u0026#34; }; // initialized with list of initializers. struct date d; template without without list of variables.\nOperator . connects the structure name and member name.\nA member of a structure is accessed / referred to in an expression by a construction of form, structure-name.member\nprintf(\u0026quot;%d, %d\u0026quot;, pt.x, pt.y) to print co-ordinates of the point pt\nTo set leap from the date in structure d\nleap = d.year%4 == 0 \u0026amp;\u0026amp; d.year%100 != 0 || d.year%400 == 0;\rto check month name,\nif (strcmp(d.mon_name, \u0026#34;Aug\u0026#34;) == 0 ) ...\rto convert first character of month name to lower case,\nd.mon_name[0] = lower(d.mon_name[0]);\rStructures can be nested (a rectangle is a pair of points that denotes diagonally opposite corners)\nstruct rect { struct point pt1; struct point pt2; };\rA payroll record\nstruct person { char name[NAMESIZE]; char address[ADRSIZE]; double salary; struct date birthday; struct date hiredate; };\rThe person structure contains two date structures.\nstruct person emp; declaring emp;\nemp.birthday.month refers to month of birth.\n. associates from left to right.\nIf declared screen as struct rect screen;, then\nscreen.pt1.x refers to x co ordinate of pt1 member of screen\n6.2 Structures and Functions There are number of restrictions on C structures.\nThe only legal operations on a structure are taking its address with \u0026amp; and accessing its members, copying it, or assigning to it as a unit (as arguments),\n(copying structures make a shallow copy, pointers are copied but does not make copy of the data to which the pointers point to. Structures in structures are also shallow copied)\nStructures may not be compared.\nA structure may be initialized by a list of constant member values;\nan automatic structure may be initialized by an assignment.\nmakepoint will take two integers and return a point structure:\nstruct point makepoint(int x, int y) { struct point temp; temp.x = x; temp.y = y; return temp; }\rArgument name and member names are same but there is no conflict.\nmakepoint can be used to make any structure dynamically or provide structure arguments to a function.\nstruct rect screen; struct point middle; struct point makepoint(int, int); screen.pt1 = makepoint(0,0); screen.pt2 = makepoint(XMAX, YMAX); middle = makepoint( (screen.pt1.x) + (screen.pt2.x)/2, (screen.pt1.y) + (screen.pt2.y)/2);\rFunctions for doing arithmetic on points.\nstruct addpoints (struct point p1, struct point p2) { p1.x += p2.x; p1.y += p2.y; return p1; }\rHere both arguments and the return value are structures. . . .\nPassing structures to a function as a pointer is more efficient than to copy the whole structure.\nstruct point *pp; says,\npp is a pointer to a structure of type strcut point.\nIf pp points to a point structure, *pp is the structure, and (*pp).x and (*pp).y are the members.\nstruct point origin, *pp; pp = \u0026amp;origin; printf(\u0026#34;origin is (%d, %d)\\n\u0026#34;, (*pp).x, (*pp).y);\rA shorthand to represent a pointer p to a structure. p-\u0026gt;member-of-structure\nprintf(\u0026#34;origin is (%d, %d)\\n\u0026#34;, pp-\u0026gt;x, pp-\u0026gt;y);\rboth . and -\u0026gt; associate from left to right.\nstruct rect r, *rp = \u0026amp;r; r.pt1.x (r.pt1).x rp-\u0026gt;pt1.x (rp-\u0026gt;pt1).x // all four are equivalent ++p-\u0026gt;len increments len, not p because it means++(p-\u0026gt;len).\n(++p)-\u0026gt;len increments p before accessing len\n(p++)-\u0026gt;len increments p afterwards.\nSimilarly *p-\u0026gt;str fetches whatever str points to;\n*p-\u0026gt;str++ increments str after accessing whatever it points to;\n(*p-\u0026gt;str)++ increments whatever str points to;\n*p++-\u0026gt;str increments p after accessing whatever str points to.\n6.3 Arrays of Structures To count the occurrences of each keyword in C.\nEach keyword is a pair of word and its count:\nchar *word; int count;\rA structure with an array:\nstruct key { char *word; int count; } keytab[NKEYS];\rThe structure declaration declares a structure of type key, defies an array keytab of structures in this type and sets aside storage for them.\nEach element of the array is a structure. also written as.\nstruct key { char *word; int count; }; struct key keytab[NKEYS];\rSince keytab contains constant set of names, it is easier to make it an external variable and initialize it when it is defined.\nstruct key { char *word; int count; } keytab [] = { {\u0026#34;auto\u0026#34;, 0}, {\u0026#34;break\u0026#34;, 0}, ... }\rThe inner braces are not necessary when initializers are simple variables or character strings but not in pairs corresponding to the structure members.\nThe keyword counting program\u0026hellip;\u0026hellip;..\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;ctype.h\u0026gt; #include \u0026lt;string.h\u0026gt; #define MAXWORD 100 int getword(char *, int); int binsearch(char *, struct key, int); // count C keywords main() { int n; char word[MAXWORD]; while (getword(word, MAXWORD) != EOF) if ( isalpha(word[0]) ) if ( (n = binsearch(word, keytab, NKEYS)) \u0026gt;= 0) keytab[n].count++; for (n = 0; n \u0026lt; NKEYS; n++) if (keytab[n].count \u0026gt; 0) printf(\u0026#34;%4d %s\\n\u0026#34;, keytab[n].count, keytab[n].word); return 0; } // find words in tab[0]...tab[n-1] int binsearch(char *word, struct key tab[], int n) { int cond; int low, mid, high; low = 0; high = n-1; while (low \u0026lt;= high) { mid = (low+high)/2 if ( (cond = strcomp(word, tab[mid].word)) \u0026lt; 0) high = mid -1; else if (cond \u0026gt; 0) low = mid +1; else return mid; } return -1; }\rgetword finds a word, which is copied into the array named as its first argument.\n// get next word or character from input int getword(char *word, int lim) { int c, getch(void); void ungetch(int); char *w = word; while ( isspace(c = getch()) ) ; if ( c != EOF ) *w++ = c; if (!isalpha(c)) { *w = \u0026#39;\\0\u0026#39;; return c; } for ( ; --lim \u0026gt; 0; w++) if (!isalnum(*w = getch()) ) { ungetch(*w); break; } *w = \u0026#39;\\0\u0026#39;; return word[0]; }\rgetword uses getch and ungetch from chapter 4.\nisspace to skip space and isalpha to identify letters, isalnum to identify letters and digits; all are from \u0026lt;ctype.h\u0026gt;\n6.4 Pointers to Structures Rewriting the keyword counting program again using pointers instead of array indices. main and binsearch need modification.\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;ctype.h\u0026gt; #include \u0026lt;string.h\u0026gt; #define MAXWORD 100 int getword(char *, int); struct key *binsearch(char *, struct key, int); // changed // count C keywords main() { char word[MAXWORD]; struct key *p; while (getword(word, MAXWORD) != EOF) if ( isalpha(word[0]) ) if ( (p = binsearch(word, keytab, NKEYS)) != NULL ) p-\u0026gt;count++; for (p = keytab; p \u0026lt; keytab + NKEYS; p++) if (p-\u0026gt;count \u0026gt; 0) printf(\u0026#34;%4d %s\\n\u0026#34;, p-\u0026gt;count, p-\u0026gt;word); return 0; } // find words in tab[0]...tab[n-1] struct key *binsearch(char *word, struct key tab[], int n) { int cond; struct key *low = \u0026amp;tab[0]; struct key *high = \u0026amp;tab[n]; struct key *mid; while (low \u0026lt; high) { mid = low + (high-low) /2; if ( (cond = strcomp(word, mid-\u0026gt;word)) \u0026lt; 0) high = mid; else if (cond \u0026gt; 0) low = mid + 1; else return mid; } return NULL; }\rThe declaration of binsearch indicates that it return a pointer to struct key instead of an integer. this is declared both in function prototype and in binsearch.\nIf it finds a word, it return a pointer to it otherwise NULL.\nThe elements of keytab are now accessed by pointers. which changes binsearch. high low are pointers.\ncomputation of mid has to change as it is illegal to to add pointers. but subtraction is legal. high-low is number of elements so mid = low + (high-low) / 2 sets mid to element halfway between high and low.\n// get next word or character from input int getword(char *word, int lim) { int c, getch(void); void ungetch(int); char *w = word; while ( isspace(c = getch()) ) ; if ( c != EOF ) *w++ = c; if (!isalpha(c)) { *w = \u0026#39;\\0\u0026#39;; return c; } for ( ; --lim \u0026gt; 0; w++) if (!isalnum(*w = getch()) ) { ungetch(*w); break; } *w = \u0026#39;\\0\u0026#39;; return word[0]; }\r6.5 Self-referential Structures When wanting to handle data where the words are not known beforehand and searching through the seen words everytime in a list is not time efficient.\nSolution is to keep a set of seen words in a sorted order all the time and placing the words in proper position as they arrive. This can be done by binary tree.\nThe binary tree node, with four components.\nstruct tnode { char *word; // points to the text of the word int count; // number of occurences struct tnode *left; // points to left child struct tnode *right; // points to right child };\rIt is illegal for a structure to contain an instance of itself.\nstruct tnode *left; declares left to be a pointer to a tnode, not tnode itself.\nNo node may contain more than two children.\nIt is maintained in such a way that the left node always contains only the words which are lexicographically less than the word at that node, and right node contains the words that are greater.\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;ctype.h\u0026gt; #include \u0026lt;string.h\u0026gt; #define MAXWORD 100 struct tnode *addtree(struct tnode *, char *); void treeprint(struct tnode *); int getword(char *, int); // word frewuency count main() { struct tnode *root; char word[MAXWORD]; root = NULL; while (getword(word, MAXWORD) != EOF) if (isalpha(word[0])) root = address(root, word); treeprint(root); return 0; }\rThe function addtree is recursive.\nA word is presented by main to top level of the tree. At each stage the word is comapred to word in the node; and percolated down by recursive call to addtree.\nEventually, the word either match something or null pointer is encountered, indicating that a node must be created and added to the tree.\naddtree returns a pointer to new node.\n. . . .\nIf tree becomes unbalanced because the words do not come in random order(words are already in order) then the running time of the program can grow too much.\n6.6 Table Lookup 6.7 Typedef 6.8 Unions 6.9 Bit-fields ","date":"2024-12-18","id":36,"permalink":"/personal-site/docs/c/kr_c_book/kr-chapter-6.1-structures/","summary":"\u003ch2 id=\"chapter-6---structures\"\u003eChapter 6 - Structures\u003c/h2\u003e\n\u003cp\u003eA structure is a collection of one or more variables, possibly of different types, grouped together under a single name for convenient handling.\u003cbr\u003e\nStructures help to organize complicated data, allowing a group of related variables to be treated as a unit instead of separate entities.\u003cbr\u003e\nEmployee has many attributes, a point is a pair of co ordinates etc.\u003c/p\u003e","tags":[],"title":"K\u0026R - Chapter 6.1 - Structures"},{"content":" n: The number of disks to move. Poles A, B, and C: Representing the three rods (source, auxiliary, and destination). Function signature: The function takes four parameters — the number of disks (n), and three characters representing the poles (A, B, and C). Approach: Base Case:\nIf there are no disks left to move (n == 0), the function terminates (returns nothing). Recursive Case:\nTo move n disks from pole A to pole C using pole B as auxiliary: First, move n-1 disks from pole A to pole B using pole C as an auxiliary. This is done through a recursive call. Then, move the nth disk from pole A to pole C. Finally, move the n-1 disks from pole B to pole C using pole A as an auxiliary, again via recursion. Termination:\nThe function stops when n == 0, as no further moves are required. No Return Value:\nThe function is void, meaning it does not return any values. Instead, it prints the moves directly. #include \u0026lt;stdio.h\u0026gt; void towerOfHanoi(int n, char A, char B, char C) { if (n\u0026gt;0) { towerOfHanoi(n-1, A, C, B); printf(\u0026#34;\\nMove the disk %d, from %c tower to %c \\n\u0026#34;, n, A, C); towerOfHanoi(n-1, B, A, C); }\t} int main() { int n; printf(\u0026#34;Enter the number of Disks: \\n\u0026#34;); scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); printf(\u0026#34;\\nThe Sequence of moves are as Follows: \\n\u0026#34;); towerOfHanoi(n, \u0026#39;A\u0026#39;, \u0026#39;B\u0026#39;, \u0026#39;C\u0026#39;); return 0; }\r#include \u0026lt;stdio.h\u0026gt; // Function to solve Tower of Hanoi puzzle void towerOfHanoi(int n, char A, char B, char C) { // Base case: if no disks to move, return if (n \u0026gt; 0) { // Move n-1 disks from A to B, using C as auxiliary towerOfHanoi(n - 1, A, C, B); // Move the nth disk from A to C printf(\u0026#34;\\nMove disk %d from %c tower to %c tower\\n\u0026#34;, n, A, C); // Move n-1 disks from B to C, using A as auxiliary towerOfHanoi(n - 1, B, A, C); } } int main() { int n; // Prompt user for the number of disks printf(\u0026#34;Enter the number of disks: \\n\u0026#34;); scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); // Print the sequence of moves to solve the puzzle printf(\u0026#34;\\nThe sequence of moves is as follows:\\n\u0026#34;); towerOfHanoi(n, \u0026#39;A\u0026#39;, \u0026#39;B\u0026#39;, \u0026#39;C\u0026#39;); return 0; }\r","date":"2025-01-01","id":37,"permalink":"/personal-site/docs/c/ds_using_c/01-tower-of-hanoi/","summary":"\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e\u003ccode\u003en\u003c/code\u003e\u003c/strong\u003e: The number of disks to move.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003ePoles \u003ccode\u003eA\u003c/code\u003e, \u003ccode\u003eB\u003c/code\u003e, and \u003ccode\u003eC\u003c/code\u003e\u003c/strong\u003e: Representing the three rods (source, auxiliary, and destination).\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eFunction signature\u003c/strong\u003e: The function takes four parameters — the number of disks (\u003ccode\u003en\u003c/code\u003e), and three characters representing the poles (\u003ccode\u003eA\u003c/code\u003e, \u003ccode\u003eB\u003c/code\u003e, and \u003ccode\u003eC\u003c/code\u003e).\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"approach\"\u003eApproach:\u003c/h3\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003eBase Case\u003c/strong\u003e:\u003c/p\u003e","tags":[],"title":"01 - Tower of Hanoi"},{"content":"","date":"2025-01-01","id":38,"permalink":"/personal-site/docs/c/ds_using_c/","summary":"","tags":[],"title":"Data Structures Using C"},{"content":"Variables Logic int n: The size of the stack (input by the user). int top=-1: A variable to track the top of the stack. Initially set to -1 to represent an empty stack. The variables n and top are declared globally so they can be accessed by all functions for stack operations and for condition verification.\nstack[n]: An array declared locally inside the main() function to hold the stack elements. e: A temporary variable used to capture the element that is being pushed onto the stack. int ch: A variable to capture the user\u0026rsquo;s choice for selecting the stack operation (Push, Pop, Peep, Display, Exit). Logic of Implementation Global Declaration of Variables:\nn and top = -1 are declared globally to handle the stack\u0026rsquo;s size and top index throughout the functions. Main Function:\nThe user is prompted to enter the size of the stack, which is stored in n. The stack stack[n] is defined based on the size n. e to capture the input data is declared to pass to the push function. A while(1) loop is used to repeatedly display the menu and capture the user\u0026rsquo;s choice (ch) to perform the corresponding stack operation. The program will continue running until the user chooses to exit. Choice Handling:\nThe ch variable captures the user\u0026rsquo;s input for the stack operation they want to perform (Push, Pop, Peep, Display, or Exit). The input choice is passed to a switch or if-else block to determine the appropriate function to call. Exit Condition:\nA choice of 0 (Exit) will trigger an exit from the loop using exit(0). Stack Operations Push If push was the ch choice, then the e to be pushed has to be captured. push needs the stack and the item entered in e as parameters. Edge case - stack full- checking if top is at max of stack size n when top == n-1 otherwise increment top to next position top++ and assign e in that place in the stack. Print that the element has been pushed into stack. Pop If pop was the choice in ch, then just call pop with just the stack as parameter. Edge case - Stack is empty - checking if top == -1 If not empty, take the element at the place of top by stack[top]. Print it as popped. Decrement the top with top-- Peep If option was peep, call peep with stack as parameter. Edge case - Stack is empty - Checking with top == -1 else, Printing stack[top] No decrement. Display If choice was display, call with stack as parameter. Edge case - Stack not empty - Checking with top == -1 else, Using a for loop to get each element by traversal. top cannot be decremented so assigning top to i, that value is decremented till it is -1 for (int i = top; i\u0026gt;-1; i--) Print element as stack[i] Default case or else when no case or condition is matched, re-run the loop to get valid choice.\nChoice to exit the program, using exit(0) for some case or condition.\n#include \u0026lt;stdlib.h\u0026gt; has to be there for the exit function.\n(or flag can be used to call break outside switch case for the while loop)\nTo reduce three checks and print for if the stack is empty, isempty() is called to check if top == -1 and print it is empty and return 1 if not empty return 0. if (! isempty) return true when not empty, then code inside will run.\nImplementation 1 (Using Switch Case) #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; int n, top = -1; // global variables for stack size and top position // Function declarations void push(int stack[], int x); void pop(int stack[]); void peep(int stack[]); void display(int stack[]); int isempty(); // Main function void main() { // Input the size of the stack printf(\u0026#34;Enter the size of the stack: \\n\u0026#34;); scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); int stack[n], e; // Local stack array and element to push // Menu-driven loop for stack operations while(1) { int ch; // Choice variable printf(\u0026#34;\\nEnter the choice - \\n\u0026#34;); printf(\u0026#34;0 : Exit,\\n\u0026#34;); printf(\u0026#34;1 : Push,\\t2 : Pop,\\n\u0026#34;); printf(\u0026#34;3 : Peep,\\t4 : Display\\n\u0026#34;); scanf(\u0026#34;%d\u0026#34;, \u0026amp;ch); switch(ch) { case 0: exit(0); // Exit the program break; case 1: printf(\u0026#34;\\nEnter the number to be pushed: \\n\u0026#34;); scanf(\u0026#34;%d\u0026#34;, \u0026amp;e); push(stack, e); // Push the element to the stack break; case 2: pop(stack); // Pop the element from the stack break; case 3: peep(stack); // Display the top element without removing break; case 4: display(stack); // Display all elements in the stack break; default: printf(\u0026#34;\\nInvalid choice. Please try again.\\n\u0026#34;); // Handle invalid choices break; } } } // Function to check if the stack is empty int isempty() { if (top == -1) { printf(\u0026#34;\\nThe Stack is Empty\\n\u0026#34;); return 1; // Stack is empty } return 0; // Stack is not empty } // Function to push an element onto the stack void push(int stack[], int x) { if (top == n - 1) // Check if the stack is full { printf(\u0026#34;Stack is full. Cannot push %d.\\n\u0026#34;, x); } else { stack[++top] = x; // Increment top and push the element printf(\u0026#34;\\nThe element %d is pushed into the stack.\\n\u0026#34;, x); } } // Function to pop an element from the stack void pop(int stack[]) { if (!isempty()) // Check if stack is not empty { printf(\u0026#34;\\nThe number %d has been popped.\\n\u0026#34;, stack[top]); top--; // Decrease top position after popping } } // Function to display the top element without popping void peep(int stack[]) { if (!isempty()) // Check if stack is not empty { printf(\u0026#34;\\nThe number at the top is %d.\\n\u0026#34;, stack[top]); } } // Function to display all elements in the stack void display(int stack[]) { if (!isempty()) // Check if stack is not empty { printf(\u0026#34;\\nThe elements in the stack are:\\n\u0026#34;); for (int i = top; i \u0026gt;= 0; i--) // Traverse stack from top to bottom { printf(\u0026#34;%d\\n\u0026#34;, stack[i]); } } }\rImplementation 2 (Using if else) #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; int n, top = -1; // Global variables for stack size and top position // Function declarations void push(int stack[], int x); void pop(int stack[]); void peep(int stack[]); void display(int stack[]); int isempty(); // Main function void main() { // Input the size of the stack printf(\u0026#34;Enter the size of the stack: \\n\u0026#34;); scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); int stack[n], e; // Local stack array and element to push // Menu-driven loop for stack operations while(1) { int ch; // Choice variable printf(\u0026#34;\\nEnter the choice - \\n\u0026#34;); printf(\u0026#34;0 : Exit,\\n\u0026#34;); printf(\u0026#34;1 : Push,\\t2 : Pop,\\n\u0026#34;); printf(\u0026#34;3 : Peep,\\t4 : Display\\n\u0026#34;); scanf(\u0026#34;%d\u0026#34;, \u0026amp;ch); if (ch == 0) { exit(0); // Exit the program } else if (ch == 1) { printf(\u0026#34;\\nEnter the number to be pushed: \\n\u0026#34;); scanf(\u0026#34;%d\u0026#34;, \u0026amp;e); push(stack, e); // Push the element to the stack } else if (ch == 2) { pop(stack); // Pop the element from the stack } else if (ch == 3) { peep(stack); // Display the top element without removing } else if (ch == 4) { display(stack); // Display all elements in the stack } else { printf(\u0026#34;\\nInvalid choice. Please try again.\\n\u0026#34;); // Handle invalid choices } } } // Function to check if the stack is empty int isempty() { if (top == -1) { printf(\u0026#34;\\nThe Stack is Empty\\n\u0026#34;); return 1; // Stack is empty } return 0; // Stack is not empty } // Function to push an element onto the stack void push(int stack[], int x) { if (top == n - 1) // Check if the stack is full { printf(\u0026#34;Stack is full. Cannot push %d.\\n\u0026#34;, x); } else { stack[++top] = x; // Increment top and push the element printf(\u0026#34;\\nThe element %d is pushed into the stack.\\n\u0026#34;, x); } } // Function to pop an element from the stack void pop(int stack[]) { if (!isempty()) // Check if stack is not empty { printf(\u0026#34;\\nThe number %d has been popped.\\n\u0026#34;, stack[top]); top--; // Decrease top position after popping } } // Function to display the top element without popping void peep(int stack[]) { if (!isempty()) // Check if stack is not empty { printf(\u0026#34;\\nThe number at the top is %d.\\n\u0026#34;, stack[top]); } } // Function to display all elements in the stack void display(int stack[]) { if (!isempty()) // Check if stack is not empty { printf(\u0026#34;\\nThe elements in the stack are:\\n\u0026#34;); for (int i = top; i \u0026gt;= 0; i--) // Traverse stack from top to bottom { printf(\u0026#34;%d\\n\u0026#34;, stack[i]); } } }\r","date":"2025-01-01","id":39,"permalink":"/personal-site/docs/c/ds_using_c/02-stack-operations/","summary":"\u003ch3 id=\"variables-logic\"\u003eVariables Logic\u003c/h3\u003e\n\u003col\u003e\n\u003cli\u003e\u003ccode\u003eint n\u003c/code\u003e: The size of the stack (input by the user).\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eint top=-1\u003c/code\u003e: A variable to track the top of the stack. Initially set to \u003ccode\u003e-1\u003c/code\u003e to represent an empty stack.\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003eThe variables \u003ccode\u003en\u003c/code\u003e and \u003ccode\u003etop\u003c/code\u003e are declared globally so they can be accessed by all functions for stack operations and for condition verification.\u003c/p\u003e","tags":[],"title":"02 - Stack Operations"},{"content":"#include \u0026lt;ctype.h\u0026gt; to get the isalnum() function to check alphabets and numbers which returns false for any special characters.\nLogic for Variables char stack[100]: A fixed-size array to store operators and operands for conversion. int top = -1: This variable points to the top of the stack. char exp[100]: Another array to store the user input expression. char *e: A pointer used to traverse the exp[] array. char x: A variable to store the element popped from the stack. Implementation Logic Declare a global stack (stack[100]) with top = -1 to track the top of the stack. In the main function, declare the exp[100] array to capture the user input expression. Use scanf(\u0026quot;%s\u0026quot;, exp) to capture the entire expression (%c is for single char) (\u0026amp;exp is not needed as it is an array). Declare e and Set e = exp to point to the start of the expression, enabling traversal. Use x in the main function to capture popped elements. Use a while loop (while(*e != '\\0')) to traverse the expression by incrementing pointer e++. Each iteration processes one character in exp[] and ends when the end of the array is reached which is signaled by *e == '\\0' Conversion Logic As the while loop runs, e is incremented and it traverses the exp array elements.\ne points at the location within the array and *e is element in that array location.\nAlphanumeric Characters: if ( isalnum(*e) ) If the character *e is alphanumeric (number or letter), it is printed directly without being pushed to the stack. Opening Parenthesis (: Always pushed onto the stack. Closing Parenthesis ): Pop elements from the stack and print them until an opening parenthesis ( is encountered. while( (x=pop()) != '(' ) Operators: For other characters (operators), compare their priority with the operator at the top of the stack. Pop and print operators with equal or higher priority before pushing the current operator. while ( priority(stack[top]) \u0026gt;= priority(*e) ) Conditions for pushing in the operator.\nIf stack is empty, if (top == -1 ) then can be pushed in. If not empty, then priority of the element at the top of the stack stack[top] has to be compared with the element from the expression *e. After processing the entire expression, pop all remaining operators from the stack. After processing the entire expression the main while loop ends after *e reaches \\0. There are still operators in the stack. pop all remaining operators from the stack. while (top != -1 ) print all the popped items.\nFunctions logic Push push need the char that has to be pushed which is in the *e Increment the top to next place top++, and assign the value to stack[top] top++ ; stack[top] = x or stack[++top] Pop Edge case is top = -1 then return -1 to calling function. (This allows to know the end if the pop value is used in any checking) else, return the value which is at the stack[top] and then decrement top stack[top--] Priority Takes a char as parameter. Works by returning a value to reflect the operators precedence which allows the while loop to compare both operators based on their return value. Operator with lowest precedence returns 0 and next would be 1, 2, 3 (: Lowest precedence (0). +, -: Medium precedence (1). *, /: Highest precedence (2). #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;ctype.h\u0026gt; char stack[100]; int top = -1; char pop(); void push(char x); int priority(char x); int main() { char exp[100]; char *e, x; printf(\u0026#34;Enter the Infix Expression to be Converted: \\n\u0026#34;); scanf(\u0026#34;%s\u0026#34;, exp); e = exp; while( *e != \u0026#39;\\0\u0026#39; ) { if ( isalnum(*e) ) { print(\u0026#34;%c \\n\u0026#34;, *e ); } else if ( *e == \u0026#39;(\u0026#39;) { push(*e); } else if ( *e == \u0026#39;)\u0026#39;) { while ( (x = pop()) != \u0026#39;(\u0026#39; ) { printf(\u0026#34;%c \\n\u0026#34;, x); } } else { while ( priority(stack[top]) \u0026gt;= priority(*e) ) { printf(\u0026#34;%c \\n\u0026#34;, pop()); } push(*e); } e++; } while ( top != -1) { printf(\u0026#34;%c \\n\u0026#34;, pop()); } return 0; } void push(char x) { top++; stack[top] = x; } char pop() { if (top == -1) return -1; else return stack[top--]; } int priority(char x) { if (x == \u0026#39;(\u0026#39;) return 0; else if ( x == \u0026#39;+\u0026#39; || x == \u0026#39;-\u0026#39;) return 1; else if ( x == \u0026#39;*\u0026#39; || x == \u0026#39;/\u0026#39;) return 2; else return 0; }\r#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;ctype.h\u0026gt; char stack[100]; int top = -1; char pop(); void push(char x); int priority(char x); int main() { char exp[100]; // Expression to be converted char *e, x; // Pointer to traverse the expression and variable to store popped element printf(\u0026#34;Enter the Infix Expression to be Converted: \\n\u0026#34;); scanf(\u0026#34;%s\u0026#34;, exp); // Take input expression e = exp; // Pointer to the start of expression while (*e != \u0026#39;\\0\u0026#39;) // Loop until end of expression { if (isalnum(*e)) // If the character is a number/letter { printf(\u0026#34;%c \\n\u0026#34;, *e); // Print the character (operand) } else if (*e == \u0026#39;(\u0026#39;) // If opening parenthesis { push(*e); // Push it onto the stack } else if (*e == \u0026#39;)\u0026#39;) // If closing parenthesis { while ((x = pop()) != \u0026#39;(\u0026#39;) // Pop until \u0026#39;(\u0026#39; is encountered { printf(\u0026#34;%c \\n\u0026#34;, x); // Print the popped operator } } else // If the character is an operator { // Pop operators of higher or equal precedence and print them while (priority(stack[top]) \u0026gt;= priority(*e)) { printf(\u0026#34;%c \\n\u0026#34;, pop()); } push(*e); // Push the current operator onto the stack } e++; // Move to the next character in the expression } // After processing the expression, pop all remaining operators from the stack while (top != -1) { printf(\u0026#34;%c \\n\u0026#34;, pop()); // Print and pop the remaining operators } return 0; } // Function to push an element onto the stack void push(char x) { top++; // Increment the top of the stack stack[top] = x; // Assign the element to the stack } // Function to pop an element from the stack char pop() { if (top == -1) // Check if the stack is empty return -1; // Return -1 if stack is empty else return stack[top--]; // Return the top element and decrement top } // Function to return the priority of operators int priority(char x) { if (x == \u0026#39;(\u0026#39;) return 0; // \u0026#39;(\u0026#39; has the lowest precedence else if (x == \u0026#39;+\u0026#39; || x == \u0026#39;-\u0026#39;) return 1; // + and - have medium precedence else if (x == \u0026#39;*\u0026#39; || x == \u0026#39;/\u0026#39;) return 2; // * and / have high precedence else return 0; // Default case for non-operators }\r","date":"2025-01-01","id":40,"permalink":"/personal-site/docs/c/ds_using_c/03-infix-to-postfix-conversion/","summary":"\u003cp\u003e\u003ccode\u003e#include \u0026lt;ctype.h\u0026gt;\u003c/code\u003e to get the \u003ccode\u003eisalnum()\u003c/code\u003e function to check alphabets and numbers which returns false for any special characters.\u003c/p\u003e\n\u003ch3 id=\"logic-for-variables\"\u003eLogic for Variables\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003echar stack[100]\u003c/code\u003e: A fixed-size array to store operators and operands for conversion.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eint top = -1\u003c/code\u003e: This variable points to the top of the stack.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003echar exp[100]\u003c/code\u003e: Another array to store the user input expression.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003echar *e\u003c/code\u003e: A pointer used to traverse the \u003ccode\u003eexp[]\u003c/code\u003e array.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003echar x\u003c/code\u003e: A variable to store the element popped from the stack.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"implementation-logic\"\u003eImplementation Logic\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eDeclare a global stack (\u003ccode\u003estack[100]\u003c/code\u003e) with \u003ccode\u003etop = -1\u003c/code\u003e to track the top of the stack.\u003c/li\u003e\n\u003cli\u003eIn the \u003ccode\u003emain\u003c/code\u003e function, declare the \u003ccode\u003eexp[100]\u003c/code\u003e array to capture the user input expression. Use \u003ccode\u003escanf(\u0026quot;%s\u0026quot;, exp)\u003c/code\u003e to capture the entire expression (\u003ccode\u003e%c\u003c/code\u003e is for single \u003ccode\u003echar\u003c/code\u003e) (\u003ccode\u003e\u0026amp;exp\u003c/code\u003e is not needed as it is an array).\u003c/li\u003e\n\u003cli\u003eDeclare \u003ccode\u003ee\u003c/code\u003e and Set \u003ccode\u003ee = exp\u003c/code\u003e to point to the start of the expression, enabling traversal.\u003c/li\u003e\n\u003cli\u003eUse \u003ccode\u003ex\u003c/code\u003e in the main function to capture popped elements.\u003c/li\u003e\n\u003cli\u003eUse a \u003ccode\u003ewhile\u003c/code\u003e loop (\u003ccode\u003ewhile(*e != '\\0')\u003c/code\u003e) to traverse the expression by incrementing pointer \u003ccode\u003ee++\u003c/code\u003e.\u003c/li\u003e\n\u003cli\u003eEach iteration processes one character in \u003ccode\u003eexp[]\u003c/code\u003e and ends when the end of the array is reached which is signaled by \u003ccode\u003e*e == '\\0'\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"conversion-logic\"\u003eConversion Logic\u003c/h3\u003e\n\u003cp\u003eAs the \u003ccode\u003ewhile\u003c/code\u003e loop runs, \u003ccode\u003ee\u003c/code\u003e is incremented and it traverses the \u003ccode\u003eexp\u003c/code\u003e array elements.\u003cbr\u003e\n\u003ccode\u003ee\u003c/code\u003e points at the location within the array and \u003ccode\u003e*e\u003c/code\u003e is element in that array location.\u003c/p\u003e","tags":[],"title":"03 - Infix to Postfix Conversion"},{"content":"isdigit() is needed to check the numbers, which will be available in \u0026lt;ctype.h\u0026gt;\nLogic for Variables int stack[100]: A fixed-size stack to hold the operands and results of operations. int top = -1: This variable points to the top of the stack. char exp[100]: Array to store the input postfix expression. char *e: Pointer used to traverse the exp[] array. int conv: Variable used to hold the converted integer value from the character. int n1, n2, n3: Variables to hold the popped values from the stack and the result of operations. Logic for Implementation Global Variables int stack[100] and int top = -1 to manage stack. In main function Declaring char exp[100] and char *e to hold the prefix expression and pointer to traverse it. Taking the expression from input and passing to array, scanf(\u0026quot;%s\u0026quot;, exp) Assigning the address of array starting location to the pointer, e = exp Declaring int conv to hold converted value of the character in *e Declaring int n1, n2, n3 to hold the values in the popped values and new result. Starting a while loop to traverse through the exp array while incrementing e Loop ending condition when *e == '\\0', So runs when while ( *e != '\\0' ) Within the loop checking if the *e is a number by passing to isdigit() from \u0026lt;ctype.h\u0026gt; If it is a digit, convert to int by subtracting its ASCII value with 48 as number 0 has value of 48, then storing it in conv Pushing conv to the stack. If it is not a digit, then it is an operator, then two int from the stack has to be popped and operated on. (there will be no ( or ) in postfix evaluation) Logic for operation The popped values are stored in n1 and n2 The operator is a char and direct operation cannot happen. Check the character in *e using switch case or if else and perform the relevant operation on n2 and n1. Store result in n3 The resultant n3 is pushed into the stack. Once the iteration of the exp[] is done, the stack will have the last value which will be the result. It can be accessed as stack[top] as top will be 0 or by using pop()\nLogic for Functions Push Receives one parameter, returns nothing No checks, Increment top and push the value to stack at top, x = stack[++top] Pop Returns an int, receives no parameter (not required) Edge case - if stack is empty, check using top == -1 and return -1 else return the value at the top and decrement stack[top--] Eval Receives the n1, n2, n3 integers and the *e character. Matches the *e with operators and performs the appropriate operation. The result is put in n3, n3 = n2 + n1 etc n3 is pushed into the stack Implementation #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;ctype.h\u0026gt; int stack[100]; int top = -1; void push(int x); int pop(); void eval(int n1, int n2, int n3, char x ); int main() { char exp[100]; char *e; printf(\u0026#34;Enter the Postfix Expression: \\n\u0026#34;); scanf(\u0026#34;%s\u0026#34;, exp); e = exp; int conv; int n1, n2, n3; while ( *e != \u0026#39;\\0\u0026#39;) { if ( isdigit(*e) ) { conv = *e - 48; push(conv); } else { n1 = pop(); n2 = pop(); eval(n1, n2, n3, *e); } e++; } printf(\u0026#34;\\nThe Result of the expression %s is %d\\n\u0026#34;, exp, pop()); return 0; } void push(int x) { stack[++top] = x;\t} int pop() { return stack[top--]; } void eval(int n1, int n2, int n3, char x ) { if (x == \u0026#39;+\u0026#39;) n3 = n2 + n1; else if (x == \u0026#39;-\u0026#39;) n3 = n2 - n1; else if (x == \u0026#39;*\u0026#39;) n3 = n2 * n1; else n3 = n2 / n1; push(n3); }\rAnother Implementation #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;ctype.h\u0026gt; int stack[100]; int top = -1; void push(int x); int pop(); void eval(int n1, int n2, int *n3, char x); int main() { char exp[100]; char *e; printf(\u0026#34;Enter the Postfix Expression: \\n\u0026#34;); scanf(\u0026#34;%s\u0026#34;, exp); // Read the input postfix expression e = exp; // Pointer to traverse the expression int conv; int n1, n2, n3; while (*e != \u0026#39;\\0\u0026#39;) { // Loop until the end of the expression if (isdigit(*e)) { // Check if the character is a digit conv = *e - \u0026#39;0\u0026#39;; // Convert char to int push(conv); // Push the integer onto the stack } else { // If the character is an operator n1 = pop(); // Pop first operand n2 = pop(); // Pop second operand eval(n1, n2, \u0026amp;n3, *e); // Perform the operation push(n3); // Push the result back onto the stack } e++; // Move to the next character in the expression } printf(\u0026#34;\\nThe Result of the expression %s is %d\\n\u0026#34;, exp, pop()); // The final result return 0; } // Function to push an integer onto the stack void push(int x) { stack[++top] = x; // Increment top and store the value } // Function to pop an integer from the stack int pop() { return stack[top--]; // Return the value at top and decrement top } // Function to evaluate an operation and store the result in n3 void eval(int n1, int n2, int *n3, char x) { switch (x) { case \u0026#39;+\u0026#39;: *n3 = n2 + n1; // Addition break; case \u0026#39;-\u0026#39;: *n3 = n2 - n1; // Subtraction break; case \u0026#39;*\u0026#39;: *n3 = n2 * n1; // Multiplication break; case \u0026#39;/\u0026#39;: *n3 = n2 / n1; // Division break; default: printf(\u0026#34;Unknown operator %c\\n\u0026#34;, x); // Handle invalid operators break; } }\r","date":"2025-01-01","id":41,"permalink":"/personal-site/docs/c/ds_using_c/04-postfix-expression-evaluation/","summary":"\u003cp\u003e\u003ccode\u003eisdigit()\u003c/code\u003e is needed to check the numbers, which will be available in \u003ccode\u003e\u0026lt;ctype.h\u0026gt;\u003c/code\u003e\u003c/p\u003e\n\u003ch3 id=\"logic-for-variables\"\u003eLogic for Variables\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eint stack[100]\u003c/code\u003e: A fixed-size stack to hold the operands and results of operations.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eint top = -1\u003c/code\u003e: This variable points to the top of the stack.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003echar exp[100]\u003c/code\u003e: Array to store the input postfix expression.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003echar *e\u003c/code\u003e: Pointer used to traverse the \u003ccode\u003eexp[]\u003c/code\u003e array.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eint conv\u003c/code\u003e: Variable used to hold the converted integer value from the character.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eint n1, n2, n3\u003c/code\u003e: Variables to hold the popped values from the stack and the result of operations.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"logic-for-implementation\"\u003eLogic for Implementation\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eGlobal Variables \u003ccode\u003eint stack[100]\u003c/code\u003e and \u003ccode\u003eint top = -1\u003c/code\u003e to manage stack.\u003c/li\u003e\n\u003cli\u003eIn \u003ccode\u003emain\u003c/code\u003e function Declaring \u003ccode\u003echar exp[100]\u003c/code\u003e and \u003ccode\u003echar *e\u003c/code\u003e to hold the prefix expression and pointer to traverse it.\u003c/li\u003e\n\u003cli\u003eTaking the expression from input and passing to array, \u003ccode\u003escanf(\u0026quot;%s\u0026quot;, exp)\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003eAssigning the address of array starting location to the pointer, \u003ccode\u003ee = exp\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003eDeclaring \u003ccode\u003eint conv\u003c/code\u003e to hold converted value of the character in \u003ccode\u003e*e\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003eDeclaring \u003ccode\u003eint n1, n2, n3\u003c/code\u003e to hold the values in the popped values and new result.\u003c/li\u003e\n\u003cli\u003eStarting a \u003ccode\u003ewhile\u003c/code\u003e loop to traverse through the \u003ccode\u003eexp\u003c/code\u003e array while incrementing \u003ccode\u003ee\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003eLoop ending condition when \u003ccode\u003e*e == '\\0'\u003c/code\u003e, So runs when \u003ccode\u003ewhile ( *e != '\\0' )\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003eWithin the loop checking if the \u003ccode\u003e*e\u003c/code\u003e is a number by passing to \u003ccode\u003eisdigit()\u003c/code\u003e from \u003ccode\u003e\u0026lt;ctype.h\u0026gt;\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003eIf it is a digit, convert to \u003ccode\u003eint\u003c/code\u003e by subtracting its ASCII value with \u003ccode\u003e48\u003c/code\u003e as number \u003ccode\u003e0\u003c/code\u003e has value of \u003ccode\u003e48\u003c/code\u003e, then storing it in \u003ccode\u003econv\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003ePushing \u003ccode\u003econv\u003c/code\u003e to the \u003ccode\u003estack\u003c/code\u003e.\u003c/li\u003e\n\u003cli\u003eIf it is not a digit, then it is an operator, then two \u003ccode\u003eint\u003c/code\u003e from the stack has to be popped and operated on. (there will be no \u003ccode\u003e(\u003c/code\u003e or \u003ccode\u003e)\u003c/code\u003e in postfix evaluation)\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"logic-for-operation\"\u003eLogic for operation\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eThe popped values are stored in \u003ccode\u003en1\u003c/code\u003e and \u003ccode\u003en2\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003eThe operator is a \u003ccode\u003echar\u003c/code\u003e and direct operation cannot happen.\u003c/li\u003e\n\u003cli\u003eCheck the character in \u003ccode\u003e*e\u003c/code\u003e using \u003ccode\u003eswitch case\u003c/code\u003e or \u003ccode\u003eif else\u003c/code\u003e and perform the relevant operation on \u003ccode\u003en2\u003c/code\u003e and \u003ccode\u003en1\u003c/code\u003e. Store result in \u003ccode\u003en3\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003eThe resultant \u003ccode\u003en3\u003c/code\u003e is pushed into the stack.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eOnce the iteration of the \u003ccode\u003eexp[]\u003c/code\u003e is done, the \u003ccode\u003estack\u003c/code\u003e will have the last value which will be the result. It can be accessed as \u003ccode\u003estack[top]\u003c/code\u003e as top will be \u003ccode\u003e0\u003c/code\u003e or by using \u003ccode\u003epop()\u003c/code\u003e\u003c/p\u003e","tags":[],"title":"04 - Postfix Expression Evaluation"},{"content":"Basic Logic Queue Structure: The queue is a data structure where elements are added at the back and removed from the front.\nPointers:\nhead points to the first element in the queue (front). tail points to the next available position for insertion (back). The head is incremented after each removal, and tail is incremented after each insertion. Variables int n: Size of the queue. int head = -1, tail = -1: Initialize the head and tail pointers to indicate an empty queue. stack[n]: Array of integers or characters used as the queue. ele: The value to be added to the queue (enqueue operation). ch: Integer variable used to store the user’s choice for queue operations. Implementation Logic Global Variables:\nDeclare n, head = -1, and tail = -1 globally to manage the queue. Functions for queue operations (enque, deque, and display) are declared, all of which return void. Input Handling:\nIn the main() function, the size of the queue is taken as input (scanf(\u0026quot;%d\u0026quot;, \u0026amp;n)). Declare stack[n] to store the queue elements and ele for input values of relevant type. A while(1) loop used to continuously display options and perform chosen operation. Declare int ch to hold the choice of user. make if else conditions for each function, an exit and miss typed number. Only option for enque needs to be passed the value to be added with stack Function Logic enque:\nChecks if the queue is full (tail == n-1). If not full, it increments tail and inserts the element into stack[tail]. If head is -1 (first insertion), it increments head to indicate that the queue is no longer empty. dequ: Removal happens at the head, so check if (head == -1 || head \u0026gt; tail) which means queue is empty If not empty, it removes the element at head and increments head. display: Checks if the queue is empty (head == -1 || head \u0026gt; tail). If not empty, it displays all elements from head to tail. run a for loop with i = front and running till i \u0026lt;= tail with i++ Print each stack[i] Implementation #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; int n, head = -1, tail = -1; void enqu(int stack[], int x); void dequ(int stack[]); void display(int stack[]); void main() { printf(\u0026#34;Enter the size of the Queue \\n\u0026#34;); scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); int stack[n], ele; while(1) { int ch; printf(\u0026#34;Make a choise:\\n\u0026#34;); printf(\u0026#34;\\n0.Exit\\t1.Enqueue\\n2.Dequeue\\t3.Display\\n\u0026#34;); scanf(\u0026#34;%d\u0026#34;, \u0026amp;ch); if (ch == 0) exit(0); else if (ch == 1) { printf(\u0026#34;\\nProvide the Number to Add: \\n\u0026#34;); scanf(\u0026#34;%d\u0026#34;, \u0026amp;ele); enqu(stack, ele); } else if (ch == 2) dequ(stack); else if (ch == 3) display(stack); else printf(\u0026#34;Enter a Proper choice\\n\u0026#34;); } } void enqu(int stack[], int x) { if ( tail == n-1) { printf(\u0026#34;\\nThe Queue is Full\\n\u0026#34;); } else { if ( head == -1) head++; tail++; stack[tail] = x; printf(\u0026#34;\\nNumber %d has been inserted in the Queue\\n\\n\u0026#34;, x);\t} } void dequ(int stack[]) { if ( head == -1 || head \u0026gt; tail) printf(\u0026#34;\\nThe Queue is empty\\n\u0026#34;); else { printf(\u0026#34;The Number %d has been removed\\n\u0026#34;, stack[head]); head++; } } void display(int stack[]) { if ( head == -1 || head \u0026gt; tail) printf(\u0026#34;\\nThe Queue is empty\\n\u0026#34;); else { printf(\u0026#34;The Elements in the Queue are: \\n\u0026#34;); for( int i = head; i \u0026lt;= tail; i++) { printf(\u0026#34;%d \\t\u0026#34;, stack[i]); } printf(\u0026#34;\\n\u0026#34;); } }\r","date":"2025-01-01","id":42,"permalink":"/personal-site/docs/c/ds_using_c/05-queue/","summary":"\u003ch4 id=\"basic-logic\"\u003e\u003cstrong\u003eBasic Logic\u003c/strong\u003e\u003c/h4\u003e\n\u003cp\u003e\u003cstrong\u003eQueue Structure\u003c/strong\u003e: The queue is a data structure where elements are added at the \u003cstrong\u003eback\u003c/strong\u003e and removed from the \u003cstrong\u003efront\u003c/strong\u003e.\u003c/p\u003e","tags":[],"title":"05 - Queue"},{"content":"In a circular queue, the tail pointer wraps around to the front when the queue is full, making efficient use of the available space in the array. This avoids the problem of running out of space when elements are dequeued, as would happen in a linear queue.\nBasic Logic Circular Structure: The queue is implemented using a circular array, so when the tail reaches the end of the array, it wraps around to the beginning. Pointers: head points to the first element (front) of the queue. tail points to the next available position for insertion (back). After dequeuing, the head is incremented, and after enqueueing, the tail is incremented, with both wrapping around if necessary. Variables int n: Size of the queue. int head = -1, tail = -1: Initialize head and tail to -1 to indicate an empty queue. queue[n]: Array of integers (or relevant type) used to represent the queue. ele: The value to be added to the queue (enqueue operation). ch: Integer variable used to capture the user\u0026rsquo;s choice for queue operations. Implementation Logic Global Variables:\nDeclare n, head = -1, and tail = -1 globally to manage the circular queue. Functions (enque, deque, display) are declared, all returning void. Input Handling:\nIn main(), take the size of the queue (scanf(\u0026quot;%d\u0026quot;, \u0026amp;n)). Declare queue[n] to store elements and ele to hold the value to be inserted. Loop for Operations:\nA while(1) loop continuously displays options and performs the selected operation. User selects an operation, and the corresponding function is executed. Queue Operations:\nEnqueue: Adds an element at the tail position, checks if the queue is full, and updates the tail. Dequeue: Removes an element from the front (head), and updates the head. Display: Prints all elements from head to tail, considering the circular nature of the queue. Function Logic enque:\nChecks if the queue is full ((tail + 1) % n == head). If not full, increments tail, wraps it if necessary, and inserts the value at queue[tail]. If head is -1 (first insertion), it increments head to indicate the queue is no longer empty. dequ:\nChecks if the queue is empty (head == -1). If not empty, removes the element at head and increments head. The head wraps around if needed. display:\nChecks if the queue is empty (head == -1). If not empty, prints elements starting from head to tail, considering the circular nature. Circular Queue Implementation #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; int n, head = -1, tail = -1; void enqu(int queue[], int x); void dequ(int queue[]); void display(int queue[]); void main() { printf(\u0026#34;Enter the size of the Queue: \\n\u0026#34;); scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); int queue[n], ele; while(1) { int ch; printf(\u0026#34;Make a choice:\\n\u0026#34;); printf(\u0026#34;\\n0.Exit\\t1.Enqueue\\n2.Dequeue\\t3.Display\\n\u0026#34;); scanf(\u0026#34;%d\u0026#34;, \u0026amp;ch); if (ch == 0) exit(0); else if (ch == 1) { printf(\u0026#34;\\nProvide the Number to Add: \\n\u0026#34;); scanf(\u0026#34;%d\u0026#34;, \u0026amp;ele); enqu(queue, ele); } else if (ch == 2) dequ(queue); else if (ch == 3) display(queue); else printf(\u0026#34;Enter a Proper choice\\n\u0026#34;); } } // Function to enqueue (add an element to the circular queue) void enqu(int queue[], int x) { if (head == ((tail + 1) % n) ) // Check if queue is full { printf(\u0026#34;\\nThe Queue is Full\\n\u0026#34;); } else { if (head == -1) // First element to be added head = 0; // Set head to 0 (indicating the queue is not empty) tail = (tail + 1) % n; // Increment tail (circularly) queue[tail] = x; // Insert element at the tail printf(\u0026#34;\\nNumber %d has been inserted in the Queue\\n\\n\u0026#34;, x); } } // Function to dequeue (remove an element from the circular queue) void dequ(int queue[]) { if (head == -1) // Queue is empty printf(\u0026#34;\\nThe Queue is empty\\n\u0026#34;); else { printf(\u0026#34;The Number %d has been removed\\n\u0026#34;, queue[head]); if (head == tail) // If there\u0026#39;s only one element in the queue { head = tail = -1; // Reset the queue to empty } else { head = (head + 1) % n; // Increment head (circularly) } } } // Function to display all elements in the circular queue void display(int queue[]) { if (head == -1) // Queue is empty printf(\u0026#34;\\nThe Queue is empty\\n\u0026#34;); else { printf(\u0026#34;The Elements in the Queue are: \\n\u0026#34;); int i = head; while (i != tail) // Display elements from head to tail (circularly) { printf(\u0026#34;%d \\t\u0026#34;, queue[i]); i = (i + 1) % n; // Circular increment } printf(\u0026#34;%d \\n\u0026#34;, queue[tail]); // Print the last element (tail) } }\rKey Points for Circular Queue Implementation Circular Behavior:\nEnqueue: When tail reaches the end of the queue (tail == n-1), the tail pointer wraps around to the front of the queue, allowing reuse of empty spaces. Dequeue: After an element is removed, head increments circularly. If head == tail, the queue is reset to empty (head = tail = -1). Full Queue Check:\nThe queue is full if (tail + 1) % n == head, meaning there is no space left for new elements. Display Operation:\nThe display function uses a while loop to iterate through the queue from head to tail while considering circular wrapping. Efficiency:\nTime Complexity: All operations (enqueue, dequeue, and display) have constant time complexity (O(1) for enqueue and dequeue, O(n) for display). Space Complexity: The queue uses O(n) space where n is the size of the queue. Circular queue implementation efficiently handles the queue operations, ensuring that space is utilized effectively and avoiding the issue of \u0026ldquo;unused space\u0026rdquo; in a typical linear queue.\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; int n, head = -1, tail=-1; void enqueu(int queue[], int x); void dequeu(int queue[]); void display(int queue[]); int main() { printf(\u0026#34;Enter the size of queue\\n\u0026#34;); scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); int queue[n], ele; while(1) { int ch; printf(\u0026#34;Select choises: 0, 1, 2, 3 \\n\u0026#34;); scanf(\u0026#34;%d\u0026#34;, \u0026amp;ch); if(ch==0) exit(0); else if(ch ==1) { printf(\u0026#34;enter the number: \\n\u0026#34;); scanf(\u0026#34;%d\u0026#34;, \u0026amp;ele); enqueu(queue, ele); } else if (ch == 2) { dequeu(queue); } else if (ch == 3) { display(queue); } } } void enqueu(int queue[], int x) { if (head == ( (tail + 1) % n )) printf(\u0026#34;Queue is full\\n\u0026#34;); else { if ( head == -1) head = 0; tail = (tail + 1) %n; queue[tail] = x; printf(\u0026#34;Number %d has been added at %d\u0026#34;, x, tail); } } void dequeu(int queue[]) { if ( head == -1) printf(\u0026#34;Queue is empty\\n\u0026#34;); else { printf(\u0026#34;element %d has been removed from %d\u0026#34;, queue[head], head); if( head == tail) head = tail = -1; else head = (head + 1) % n; } } void display(int queue[]) { if (head == -1 ) printf(\u0026#34;The queue is empty\\n\u0026#34;); else { int i = head; while ( i != tail) { printf(\u0026#34;%d \\n\u0026#34;,queue[i]); i = (i+1) % n; } printf(\u0026#34;%d \\n\u0026#34;, queue[tail]); } }\r","date":"2025-01-01","id":43,"permalink":"/personal-site/docs/c/ds_using_c/06-circular-queue/","summary":"\u003cp\u003eIn a circular queue, the \u003ccode\u003etail\u003c/code\u003e pointer wraps around to the front when the queue is full, making efficient use of the available space in the array. This avoids the problem of running out of space when elements are dequeued, as would happen in a linear queue.\u003c/p\u003e","tags":[],"title":"06 - Circular Queue"},{"content":"","date":"2024-11-07","id":44,"permalink":"/personal-site/docs/java-script/js-language/1-data-types/","summary":"","tags":[],"title":"Data Types"},{"content":"","date":"2024-10-22","id":45,"permalink":"/personal-site/docs/java-script/js-language/","summary":"","tags":[],"title":"JS Language"},{"content":"","date":"2024-10-22","id":46,"permalink":"/personal-site/docs/java-script/","summary":"","tags":[],"title":"JavaScript"},{"content":"In JavaScript, bindings (also known as variables) are used to maintain the internal state and store values.\nRules for naming variables: No keywords or reserved words (e.g., if, for, function, etc.). Cannot start with a number (e.g., 123variable is invalid). No spaces or hyphens (-). No special characters, except for $ and _. Naming Variables Properly A good variable name should be descriptive and easy to understand. It should clearly represent the value or data that it holds.\nUse camelCase for variable names (e.g., userName, squareRoot). Choose human-readable names that describe the purpose of the variable (e.g., currentUser, shoppingCart). Avoid abbreviations or short names like a, b, and c, unless it\u0026rsquo;s clear what they represent. Be descriptive but also concise. For example, avoid overly generic names like data or value. If referring to a user in your application, use names like currentUser or newUser instead of vague terms like currentVisitor or newManInTown. lazy programmers who, instead of declaring new variables, tend to reuse existing ones. like boxes into which people throw different things without changing their stickers. What’s inside the box now? Who knows?. Such programmers save a little bit on variable declaration but lose ten times more on debugging. // Descriptive variable names let userName = \u0026#39;Jane Doe\u0026#39;; let totalPrice = 100.50;\rComments in JavaScript Single-line comment // Multi-line comment /* ... */ // This is a single-line comment let x = 5; // Inline comment /* This is a multi-line comment that spans across multiple lines */ let y = 10;\rvar (Old Way of Declaring Variables) The var keyword was previously used to declare variables in JavaScript, but it is now considered outdated due to some issues with variable scoping. As such, its usage is discouraged in favor of let and const.\nlet for Declaring Variables The let keyword is used to declare variables that can be reassigned later.\nlet message; // Declaring a variable message = \u0026#39;Hello\u0026#39;; // Assigning a value let caught = 5 * 5; // Declaring and assigning a value in one line The let keyword indicates that a new variable is being defined. A variable declared with let can be reassigned to a different value after its initial assignment. Reassigning Variables: The binding is not tied to that value, it can be disconnected from current value and have them point to a new one;\nlet mood = \u0026#39;light\u0026#39;; // Initial assignment mood = \u0026#39;dark\u0026#39;; // Reassigning the value Important: Once a variable is declared with let, it can be reassigned, but it does not need let for the reassignment. You only use let when declaring the variable for the first time. Defining Multiple Variables: You can define multiple variables in a single let declaration, separating them with commas.\nlet one = 1, two = 2; // Multiple variables in one line let user = \u0026#39;John\u0026#39;, age = 25, message = \u0026#39;Hello\u0026#39;; // Another example // Alternatively, you can split the declarations across multiple lines: let user = \u0026#39;John\u0026#39; , age = 25 , message = \u0026#39;Hello\u0026#39;;\rconst for Constants The const keyword is used to declare constants. Once a value is assigned to a const variable, it cannot be reassigned. Attempting to change the value of a constant results in an error.\nconst pi = 3.142; // Constant value const myBirthday = \u0026#39;18.04.1999\u0026#39;; // Another constant A constant binding points to the same value as long as it lives. Constants cannot be reassigned once their initial value is set.\nConstants and Runtime Values: Some constants may be known beforehand (e.g., pi), while others are calculated at runtime but remain unchanged after their initial assignment.\nconst pageLoadTime = /* Time taken for a webpage to load */; const age = calculateAge(myBirthday); // Value computed at runtime Uppercase Constants A common convention for constants that represent values known before execution is to use uppercase letters with underscores (_) to separate words. This makes them easier to identify in your code.\nconst COLOR_RED = \u0026#34;#F00\u0026#34;; const COLOR_GREEN = \u0026#34;#0F0\u0026#34;; const COLOR_BLUE = \u0026#34;#00F\u0026#34;; const COLOR_ORANGE = \u0026#34;#FF7F00\u0026#34;; // Using the constant to set a variable let color = COLOR_ORANGE; alert(color); // Outputs the color value Redone on #07oct24\n","date":"2024-11-07","id":47,"permalink":"/personal-site/docs/java-script/js-language/1-data-types/js-01.01-variables/","summary":"\u003cp\u003eIn JavaScript, \u003cem\u003ebindings\u003c/em\u003e (also known as \u003cem\u003evariables\u003c/em\u003e) are used to maintain the internal state and store values.\u003c/p\u003e\n\u003ch2 id=\"rules-for-naming-variables\"\u003eRules for naming variables:\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eNo keywords or reserved words\u003c/strong\u003e (e.g., \u003ccode\u003eif\u003c/code\u003e, \u003ccode\u003efor\u003c/code\u003e, \u003ccode\u003efunction\u003c/code\u003e, etc.).\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eCannot start with a number\u003c/strong\u003e (e.g., \u003ccode\u003e123variable\u003c/code\u003e is invalid).\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eNo spaces or hyphens (\u003ccode\u003e-\u003c/code\u003e)\u003c/strong\u003e.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eNo special characters\u003c/strong\u003e, except for \u003ccode\u003e$\u003c/code\u003e and \u003ccode\u003e_\u003c/code\u003e.\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003ch2 id=\"naming-variables-properly\"\u003eNaming Variables Properly\u003c/h2\u003e\n\u003cp\u003eA good variable name should be \u003cstrong\u003edescriptive\u003c/strong\u003e and \u003cstrong\u003eeasy to understand\u003c/strong\u003e. It should clearly represent the value or data that it holds.\u003c/p\u003e","tags":[],"title":"JS - 01.01 - Variables"},{"content":"In JavaScript, values are chunks of information.\nEach value has a specific type that defines how it behaves and interacts with other values.\nThere are eight basic types in JavaScript:\nnumber bigint string boolean null undefined object symbol\rTypes of Values Primitive Types Primitive types can hold only one value at a time, and they are immutable (i.e., they can\u0026rsquo;t be changed). These types include:\nString: Represents a sequence of characters. let name = \u0026quot;Eag\u0026quot;;\nNumber: Represents both integer and floating-point numbers. JavaScript doesn\u0026rsquo;t distinguish between them — all numbers are of the same type. let age = 30;\nBoolean: Represents a true or false value. let isApproved = false;\nUndefined: Indicates that a variable has been declared but not assigned a value. let firstName = undefined; // Value not initialized\nNull: Represents an intentionally empty or non-existent value. let lastName = null; // Value intentionally left blank\nBigInt: Used to represent very large integers that are beyond the limit of the standard Number type. let largeNumber = 1234567890123456789012345678901234567890n; // BigInt\nSymbol: Represents a unique and immutable value, often used to create unique identifiers. let sym = Symbol(\u0026quot;id\u0026quot;);\nReference Types Reference types can store collections of data and more complex entities. These include:\nObject: Can hold collections of data, including properties and methods. let user = { name: \u0026quot;John\u0026quot;, age: 30 };\nArray: A special type of object for storing ordered collections of values.\nlet numbers = [1, 2, 3];\nFunction: A special type of object used to define callable blocks of code.\nfunction greet() { console.log(\u0026#34;Hello!\u0026#34;); }\rsymbol: Used to create unique identifiers, ensuring no collisions in object properties. typeof Operator The typeof operator is used to determine the type of a value or variable. It returns a string indicating the type of the operand.\nThe type can change based on the value it holds.\ntypeof 0 // \u0026#34;number\u0026#34; typeof 10n // \u0026#34;bigint\u0026#34; typeof \u0026#39;foo\u0026#39; // \u0026#34;string\u0026#34; typeof Symbol(\u0026#34;id\u0026#34;) // \u0026#34;symbol\u0026#34; typeof Math // \u0026#34;object\u0026#34; (Math is an object) typeof null // \u0026#34;object\u0026#34; (This is a known quirk in JavaScript) typeof alert // \u0026#34;function\u0026#34; (Functions are objects) Note: The behavior of typeof with null is incorrect — it returns \u0026quot;object\u0026quot;, which is a known issue in JavaScript, but it\u0026rsquo;s kept for compatibility reasons. null is not an object; it is its own unique type.\nMethods of Primitives Methods are part of objects. While primitives (like strings, numbers, booleans) are not objects by themselves, JavaScript allows them to behave like objects in certain situations. This is done through \u0026ldquo;wrapper objects\u0026rdquo; that temporarily convert the primitive to an object for method access.\nWhen you call a method on a primitive value, JavaScript wraps the primitive in an appropriate object wrapper (e.g., String, Number, Boolean, Symbol, or BigInt). After the method call, the wrapper is discarded.\nlet str = \u0026#34;hello\u0026#34;; console.log(str.toUpperCase()); // \u0026#34;HELLO\u0026#34; str is a primitive string. JavaScript temporarily wraps it in a String object to call the toUpperCase method, and then the wrapper is discarded. So primitives can provide methods yet still remain lightweight. Wrappers for Each Primitive Type: String has methods like .toUpperCase(), .toLowerCase(), etc. Number has methods like .toFixed(), .toPrecision(), etc. Boolean has methods like .toString() to convert it into a string. However, null and undefined do not have object wrappers, so they cannot be used with methods.\nConverting primitive types: let num = Number(\u0026#34;123\u0026#34;); // Converts the string \u0026#34;123\u0026#34; into a number let booleanVal = Boolean(0); // Converts 0 to false Note: null and undefined do not have methods because they are the most primitive types and do not have associated object wrappers.\nPrimitive types: Single values, immutable, include string, number, boolean, null, undefined, symbol, bigint. Reference types: Store collections of data and more complex entities, include object, array, function, etc. typeof operator: Used to check the type of a value. Wrapper objects: Allow primitives to behave like objects when methods are invoked on them (e.g., String, Number, Boolean). Empty values null is used to assign an empty, nothing or value unkown value to a variable.\nundefined means value is not assigned It as a default initial value when variable is declared but value is not assigned. Many operations yield undefined when they have to yield some value if the operation don\u0026rsquo;t produce a meaningful value.\nnull and undefined are used to denote the absence of meaningful value / value unknown. These two are values but they do not carry no information. Both are mostly interchangeable.\n#17sep24\n","date":"2024-11-07","id":48,"permalink":"/personal-site/docs/java-script/js-language/1-data-types/js-01.02-values-and-types/","summary":"\u003cp\u003eIn JavaScript, \u003cstrong\u003evalues\u003c/strong\u003e are chunks of information.\u003cbr\u003e\nEach value has a specific \u003cstrong\u003etype\u003c/strong\u003e that defines how it behaves and interacts with other values.\u003c/p\u003e","tags":[],"title":"JS - 01.02 - Values and Types"},{"content":"In JavaScript, there are two types of numbers: Regular Numbers and BigInt Numbers.\nTypes of Numbers Regular Numbers Regular Numbers are stored in 64-bit memory, with some bits representing the sign (positive or negative), and others representing the value of the number (including the decimal point for floating-point numbers).\nBigInt Numbers A BigInt is a numeric type that can represent integers of arbitrary length, i.e., numbers larger than the limit of the regular number type (which is 2^53 - 1). This makes BigInt useful for working with very large integers, such as cryptography or certain scientific calculations.\nA BigInt value is created by appending an n to the end of an integer:\nconst bigInt = 12345553213423423424241313322442324234342n; // The \u0026#39;n\u0026#39; at the end indicates it\u0026#39;s a BigInt Converting to Number You can convert a value to a regular number using the Number() function. It will convert the value to a number if it’s possible:\nconst myString = \u0026#39;123\u0026#39;; const myNum = Number(myString); console.log(typeof myNum); // \u0026#34;number\u0026#34; Special Numeric Values JavaScript has several special numeric values:\nInfinity: Represents an infinitely large number. It results from dividing a positive number by zero.\nalert(1 / 0); // Infinity -Infinity: Represents an infinitely large negative number.\nalert(-1 / 0); // -Infinity NaN (Not a Number): Indicates an invalid or undefined result of a mathematical operation.\nalert(0 / 0); // NaN alert(\u0026#34;hello\u0026#34; * 2); // NaN NaN is not equal to itself (NaN !== NaN), which is a unique property in JavaScript. If NaN appears in an expression, the entire result will likely be NaN.\nArithmetic Operators JavaScript provides several operators for performing arithmetic operations on numbers:\n+ // Addition - // Subtraction * // Multiplication / // Division % // Modulo (Remainder) Operation ** // Exponentiation (Power) Arithmetic Behavior Division by Zero: When dividing by zero, JavaScript returns Infinity or -Infinity depending on the sign.\nalert(1 / 0); // Infinity alert(-1 / 0); // -Infinity NaN (Not a Number): If an operation results in a value that cannot be calculated, it returns NaN (Not a Number). This can happen in operations like division by zero, or invalid operations involving non-numeric values.\nalert(\u0026#34;not a number\u0026#34; / 2); // NaN alert(NaN + 1); // NaN Special Cases Involving NaN:\nAny expression involving NaN will propagate NaN as the result: 0 / 0; // NaN Infinity - Infinity; // NaN NaN Propagation: If NaN is part of an expression, the result will also be NaN, unless the operation is NaN raised to the power of 0, which is 1.\nNaN ** 0; // 1 Ways to Write Numbers in JavaScript JavaScript provides different ways to represent numbers in a readable and compact form:\n1. Using Underscores (_) as Separators You can use underscores to improve the readability of large numbers. These underscores are ignored during execution.\nlet billion = 1_000_000_000; // 1 billion 2. Using Scientific Notation (e) You can represent numbers using exponential (scientific) notation with the e character, where e represents \u0026ldquo;times 10 raised to the power of.\u0026rdquo;\nPositive exponent:\nlet billion = 1e9; // 1e9 is equal to 1,000,000,000 (1 billion) alert(7.3e9); // 7.3e9 is 7.3 billion Negative exponent:\nlet mcs = 1e-6; // 1e-6 is 0.000001 alert(mcs); // 0.000001 // five zeroes to left from 1 3. Standard Notation (Without Exponent) A number can be written in its standard form without any scientific notation.\nlet billion = 1000000000; // 1 billion ","date":"2024-11-07","id":49,"permalink":"/personal-site/docs/java-script/js-language/1-data-types/js-01.03-number-types/","summary":"\u003cp\u003eIn JavaScript, there are two types of numbers: \u003cstrong\u003eRegular Numbers\u003c/strong\u003e and \u003cstrong\u003eBigInt Numbers\u003c/strong\u003e.\u003c/p\u003e\n\u003ch2 id=\"types-of-numbers\"\u003eTypes of Numbers\u003c/h2\u003e\n\u003ch3 id=\"regular-numbers\"\u003eRegular Numbers\u003c/h3\u003e\n\u003cp\u003e\u003cstrong\u003eRegular Numbers\u003c/strong\u003e are stored in \u003cstrong\u003e64-bit\u003c/strong\u003e memory, with some bits representing the sign (positive or negative), and others representing the value of the number (including the decimal point for floating-point numbers).\u003c/p\u003e","tags":[],"title":"JS - 01.03 - Number Types"},{"content":"Notes on common number methods: Rounding, Tests with isNaN and isFinite, and parseInt()/parseFloat() functions and Math object.\nRounding in JavaScript JavaScript provides several methods for rounding numbers to the nearest integer or a specific number of digits.\nRounding Methods Math.floor()\nRounds a number down to the nearest integer, regardless of whether the number is positive or negative.\nMath.floor(3.1); // 3 Math.floor(-1.1); // -2 Math.ceil()\nRounds a number up to the nearest integer.\nMath.ceil(3.1); // 4 Math.ceil(-1.1); // -1 Math.round()\nRounds a number to the nearest integer: Rounds up if the decimal part is \u0026gt;= 0.5. Rounds down if the decimal part is \u0026lt; 0.5.\nMath.round(3.1); // 3 Math.round(3.6); // 4 Math.round(3.5); // 4 (Rounds up) Math.round(-3.5); // -3 (Rounds up to less negative) Math.trunc()\nRemoves the decimal part of a number without rounding, effectively truncating it.\nMath.trunc(3.1); // 3 Math.trunc(-1.1); // -1 Note: Math.trunc() is not supported by Internet Explorer.\nRounding to a Specific Number of Digits To round a number to a specific number of digits after the decimal point, you can use either the multiply-and-divide technique or the toFixed() method.\nMultiply-and-Divide Method\nThis method multiplies the number by a power of 10, applies the rounding function, and then divides by the same power of 10.\nlet num = 1.23456; alert(Math.round(num * 100) / 100); // 1.23 (Rounds to two decimal places) toFixed(n)\nThe toFixed() method rounds the number to n decimal places and returns the result as a string.\nlet num = 12.3445; alert(num.toFixed(1)); // \u0026#34;12.3\u0026#34; let num2 = 12.3745; alert(num2.toFixed(1)); // \u0026#34;12.4\u0026#34; // To round up to 5 decimal places: let num3 = 12.36; alert(num3.toFixed(5)); // \u0026#34;12.36000\u0026#34; alert(+num3.toFixed(5)); // 12.36000 (Converts back to a number) Note: You can convert the string back to a number by using the unary plus (+) operator.\nFloating-point Precision Issues JavaScript is known for some floating-point precision errors.\nalert(0.1 + 0.2); // 0.3000000000004 (Precision issue) alert(+(0.1 + 0.2).toFixed(2)); // 0.30 (Fixed by rounding) Testing for NaN and Finite Numbers JavaScript provides special functions to handle cases where values may not be valid numbers or may be infinite.\nisNaN() The isNaN() function tests whether a value is Not a Number (NaN). It converts the argument to a number and then checks if it is NaN.\nalert(isNaN(NaN)); // true alert(isNaN(\u0026#34;str\u0026#34;)); // true (because \u0026#34;str\u0026#34; is not a number) alert(NaN === NaN); // false (NaN is not equal to itself) isFinite() The isFinite() function tests whether a value is a finite number (i.e., not NaN, Infinity, or -Infinity).\nalert(isFinite(\u0026#34;15\u0026#34;)); // true (string \u0026#34;15\u0026#34; is converted to number) alert(isFinite(\u0026#34;str\u0026#34;)); // false (because \u0026#34;str\u0026#34; is not a number) alert(isFinite(Infinity)); // false alert(isFinite(-Infinity));// false isFinite() is often used to validate user input to ensure it\u0026rsquo;s a regular number:\nlet num = +prompt(\u0026#34;Enter a number\u0026#34;, \u0026#39;\u0026#39;); alert(isFinite(num)); // true unless the value is NaN or Infinity Converting Strings to Numbers: parseInt() and parseFloat() JavaScript provides two built-in functions to convert strings into numeric values: parseInt() and parseFloat().\nparseInt(): Converts a string to an integer (whole number). parseFloat(): Converts a string to a floating-point number (decimal number). parseInt() parseInt() parses a string and returns an integer. It reads the string until it encounters a non-digit character, then stops parsing and returns the integer.\nalert(parseInt(\u0026#39;100px\u0026#39;)); // 100 alert(parseInt(\u0026#39;12.5em\u0026#39;)); // 12 (stops parsing at the first non-numeric character) alert(parseInt(\u0026#39;12.3\u0026#39;)); // 12 (only integer part is parsed) alert(parseInt(\u0026#39;a123\u0026#39;)); // NaN (cannot parse anything) parseFloat() parseFloat() parses a string and returns a floating-point number. It reads until it encounters a character that is not part of a floating-point number (e.g., a letter).\nalert(parseFloat(\u0026#39;12.5em\u0026#39;)); // 12.5 alert(parseFloat(\u0026#39;12.3.4\u0026#39;)); // 12.3 (stops parsing at the second dot) alert(parseFloat(\u0026#39;100px\u0026#39;)); // 100 alert(parseFloat(\u0026#39;a123\u0026#39;)); // NaN Numeric Conversion Using + or Number() For strict conversion of a string to a number, you can use the unary plus (+) or Number() function. These will fail if the string cannot be strictly converted to a valid number.\nalert(+\u0026#34;100px\u0026#34;); // NaN (invalid string) alert(Number(\u0026#34;100px\u0026#34;)); // NaN alert(+\u0026#34;123\u0026#34;); // 123 (valid number) alert(Number(\u0026#34;123\u0026#34;)); // 123 The Math Object JavaScript has a built-in Math object, which provides a set of mathematical functions and constants.\nCommon Math Functions Math.abs(): Returns the absolute (positive) value of a number.\nMath.abs(-5); // 5 Math.max(): Returns the largest of zero or more numbers.\nMath.max(1, 2, 3); // 3 Math.min(): Returns the smallest of zero or more numbers.\nMath.min(1, 2, 3); // 1 Math.pow(n, power): Returns n raised to the power of power.\nMath.pow(2, 3); // 8 (2^3) Math.sqrt(): Returns the square root of a number.\nMath.sqrt(16); // 4 Constants:\nMath.PI: The value of Pi (3.14159\u0026hellip;). Math.PI; // 3.141592653589793 Math.random(): Returns a random floating-point number between 0 (inclusive) and 1 (exclusive).\nMath.random(); // Random number between 0 and 1 Trigonometric Functions:\nMath.cos(), Math.sin(), Math.tan() – Compute the cosine, sine, and tangent of an angle (in radians). Math.asin(), Math.acos(), Math.atan() – Compute the arcsine, arccosine, and arctangent, respectively. Rounding Functions:\nMath.floor(): Rounds down to the nearest integer. Math.ceil(): Rounds up to the nearest integer. Math.round(): Rounds to the nearest integer. ","date":"2024-11-07","id":50,"permalink":"/personal-site/docs/java-script/js-language/1-data-types/js-01.04-number-methods/","summary":"\u003cp\u003eNotes on common number methods: \u003cstrong\u003eRounding\u003c/strong\u003e, \u003cstrong\u003eTests with \u003ccode\u003eisNaN\u003c/code\u003e and \u003ccode\u003eisFinite\u003c/code\u003e\u003c/strong\u003e, and \u003cstrong\u003e\u003ccode\u003eparseInt()\u003c/code\u003e/\u003ccode\u003eparseFloat()\u003c/code\u003e\u003c/strong\u003e functions and \u003cstrong\u003eMath object\u003c/strong\u003e.\u003c/p\u003e\n\u003chr\u003e\n\u003ch2 id=\"rounding-in-javascript\"\u003eRounding in JavaScript\u003c/h2\u003e\n\u003cp\u003eJavaScript provides several methods for rounding numbers to the nearest integer or a specific number of digits.\u003c/p\u003e","tags":[],"title":"JS - 01.04 - Number Methods"},{"content":"A string is a sequence of text characters enclosed in either single quotes (' '), double quotes (\u0026quot; \u0026quot;), or backticks (`). Strings are one of the most commonly used data types in JavaScript.\nBasic String Declaration let str = \u0026#34;Hello\u0026#34;; // Double quotes let str1 = \u0026#39;Single quotes are ok too\u0026#39;; // Single quotes let phrase = `Backticks allow embedding expressions like ${str}`; // Template literal (backticks) let combined = `${str} ${phrase}`; // String concatenation using template literals alert(`1 + 2 = ${sum(1, 2)}.`); // Using template literals to embed function results Template Literals Template literals are enclosed by backticks (`) and allow embedding of expressions inside ${}. These expressions are evaluated, converted to strings, and inserted into the string.\nlet name = \u0026#34;John\u0026#34;; console.log(`Hello, ${name}`); // Hello, John console.log(`The result of 1 + 2 is ${1 + 2}`); // The result of 1 + 2 is 3 Template literals can do much more:\nMultiline strings: Unlike regular strings enclosed in quotes, template literals can span multiple lines without the need for escape characters.\nlet multiline = `This is a string that spans multiple lines.`;\rEmbedded expressions: As shown above, you can embed variables, calculations, and even function calls inside ${}.\nlet a = 5, b = 10; let result = `${a} + ${b} = ${a + b}`; // \u0026#34;5 + 10 = 15\u0026#34; Escaping Characters Escaping characters allows you to treat characters as literal text when needed. This is useful for special characters such as quotes, newlines, or backslashes that might otherwise have special meaning in JavaScript.\nEscape sequences:\n\\n: Newline character \\t: Tab character \\\\: Backslash \\': Single quote \\\u0026quot;: Double quote First line and\\nThis is second line A newline character is \u0026#34;\\n\u0026#34; A newline character is \\\u0026#34;\\\\n\\\u0026#34; let message = \u0026#34;First line\\nSecond line\u0026#34;; console.log(message); // First line (new line) Second line const quote = \u0026#34;I\\\u0026#39;ve got no right to take my place\u0026#34;; // Escape single quote console.log(quote); // I\u0026#39;ve got no right to take my place\rConcatenation Concatenation is the process of combining two or more strings into one string. You can use the + operator to concatenate strings.\nlet first = \u0026#34;Hello\u0026#34;; let second = \u0026#34;World\u0026#34;; let combined = first + \u0026#34; \u0026#34; + second; // \u0026#34;Hello World\u0026#34; let name = \u0026#34;con\u0026#34; + \u0026#34;cat\u0026#34; + \u0026#34;e\u0026#34; + \u0026#34;nate\u0026#34;\rIf any of the operands is a string, the other will be converted to a string and concatenated.\nalert(\u0026#39;1\u0026#39; + 2); // \u0026#34;12\u0026#34; (number 2 converted to string) alert(2 + \u0026#34;1\u0026#34;); // \u0026#34;21\u0026#34; (number 2 converted to string) JavaScript concatenates strings from left to right:\nalert(2 + 1 + \u0026#34;1\u0026#34;); // \u0026#34;31\u0026#34; (2 + 1 = 3, then \u0026#34;3\u0026#34; + \u0026#34;1\u0026#34; = \u0026#34;31\u0026#34;) alert(\u0026#34;2\u0026#34; + 1 + 1); // \u0026#34;211\u0026#34; (\u0026#34;2\u0026#34; + 1 = \u0026#34;21\u0026#34;, then \u0026#34;21\u0026#34; + 1 = \u0026#34;211\u0026#34;) All other math operators try to convert string to number and do the operation but not +\nThe String() function can explicitly convert other data types to strings.\nlet number = 123; let str = String(number); // Converts the number to a string console.log(str); // \u0026#34;123\u0026#34; ","date":"2024-11-07","id":51,"permalink":"/personal-site/docs/java-script/js-language/1-data-types/js-01.05-string-type/","summary":"\u003cp\u003eA \u003cstrong\u003estring\u003c/strong\u003e is a sequence of text characters enclosed in either single quotes (\u003ccode\u003e' '\u003c/code\u003e), double quotes (\u003ccode\u003e\u0026quot; \u0026quot;\u003c/code\u003e), or backticks (\u003ccode\u003e`\u003c/code\u003e). Strings are one of the most commonly used data types in JavaScript.\u003c/p\u003e","tags":[],"title":"JS - 01.05 - String Type"},{"content":"Strings in JavaScript are primitive values and are immutable, meaning their content cannot be modified after they are created. However, they come with built-in properties and methods that allow manipulation and examination of string data.\nBasic String Methods string.length at(position) // allows negative index charAt(position) //charecter from possition string[pos] // works same toUpperCase() toLowerCase() // searching for a substring search() indexOf() lastIndexOf() match() includes(), startsWith(), endsWith() // returns true/false padSrart(targetLength, padString) padEnd(targetLength, padString) trim() charCodeAt(position) // returns code character codePointAt(pos) // Returns a decimal number representing the code for the character at position `pos` fromCodePoint(code) // Creates a character by its numeric `code` String Length The length property returns the number of characters in a string, counting spaces and special characters (such as \\n).\nlet text = \u0026#39;Hello, world!\u0026#39;; let length = text.length; alert(length); // 13 alert( `My\\n`.length ); // 3 because \\n is considered one character str.length is a numeric property, not a function. There is no need to add parenthesis after it. Not .length(), but .length.\nAccessing String Characters There are multiple ways to access characters in a string:\nUsing []: This allows you to access a character at a specific position.\nlet text = \u0026#34;Hello\u0026#34;; let char = text[0]; // \u0026#34;H\u0026#34; Note: Using [] does not support negative indexing (will return undefined for negative values).\nUsing at(position): A new method that supports negative indices to count from the end of the string.\nlet text = \u0026#34;Hello\u0026#34;; console.log(text.at(0)); // \u0026#34;H\u0026#34; console.log(text.at(-1)); // \u0026#34;o\u0026#34; Using charAt(position): Works similarly to at() but without support for negative indexing.\nlet text = \u0026#34;Hello\u0026#34;; console.log(text.charAt(0)); // \u0026#34;H\u0026#34; Using charCodeAt(position): Returns the Unicode (ASCII) value of the character at the specified position.\nlet text = \u0026#34;Hello\u0026#34;; console.log(text.charCodeAt(0)); // 72 (Unicode value for \u0026#39;H\u0026#39;) Iterating Over Characters To iterate over each character in a string, you can use a for...of loop.\nfor (let char of \u0026#34;Hello\u0026#34;) { alert(char); // \u0026#34;H\u0026#34;, \u0026#34;e\u0026#34;, \u0026#34;l\u0026#34;, \u0026#34;l\u0026#34;, \u0026#34;o\u0026#34; }\rString Methods: Immutable Operations Strings are immutable, meaning once a string is created, its characters cannot be changed directly. You would need to create a new string to modify it.\nlet str = \u0026#34;hi\u0026#34;; str[0] = \u0026#39;H\u0026#39;; // This does not work alert(str[0]); // \u0026#34;h\u0026#34; let newStr = \u0026#39;H\u0026#39; + str[1]; // Create a new string alert(newStr); // \u0026#34;Hi\u0026#34; Case Conversion You can convert strings to upper or lower case using toUpperCase() and toLowerCase().\nlet text = \u0026#34;Hello World\u0026#34;; let upperCase = text.toUpperCase(); // \u0026#34;HELLO WORLD\u0026#34; let lowerCase = text.toLowerCase(); // \u0026#34;hello world\u0026#34; alert( \u0026#39;Interface\u0026#39;.toUpperCase() ); // \u0026#34;INTERFACE\u0026#34; alert( \u0026#39;Interface\u0026#39;[0].toLowerCase() ); // \u0026#34;i\u0026#34; Searching for Substrings There are several methods to search for substrings within strings:\nsearch(): Searches a string for a match against a regular expression and returns the index of the match.\nlet text = \u0026#34;Hello world!\u0026#34;; let index = text.search(\u0026#34;world\u0026#34;); // 6 (position where \u0026#34;world\u0026#34; starts) alert(index);\rindexOf(): Finds the position of the first occurrence of a substring within a string.\nlet text = \u0026#39;Widget with id\u0026#39;; alert(text.indexOf(\u0026#39;Widget\u0026#39;)); // 0 alert(text.indexOf(\u0026#39;widget\u0026#39;)); // -1 (case-sensitive) lastIndexOf(): Similar to indexOf() but searches from the end of the string. str.lastIndexOf(substr, position)\nlet text = \u0026#39;As sly as a fox, as strong as an ox\u0026#39;; let target = \u0026#39;as\u0026#39;; let pos = text.lastIndexOf(target); // 30 (last \u0026#34;as\u0026#34;) alert(pos);\rmatch(): Returns the matches based on a regular expression.\nlet text = \u0026#34;The rain in Spain stays mainly in the plain\u0026#34;; let matches = text.match(/ain/g); // Returns an array of \u0026#34;ain\u0026#34; matches alert(matches); // [\u0026#34;rain\u0026#34;, \u0026#34;Spain\u0026#34;, \u0026#34;plain\u0026#34;] includes(): Returns true if the substring is found, otherwise false. str.includes(substr, pos)\nalert(\u0026#34;Hello World\u0026#34;.includes(\u0026#34;World\u0026#34;)); // true alert(\u0026#34;Hello World\u0026#34;.includes(\u0026#34;world\u0026#34;)); // false startsWith(): Checks if the string starts with the given substring.\nalert(\u0026#34;Hello\u0026#34;.startsWith(\u0026#34;He\u0026#34;)); // true alert(\u0026#34;Hello\u0026#34;.startsWith(\u0026#34;he\u0026#34;)); // false endsWith(): Checks if the string ends with the given substring.\nalert(\u0026#34;Hello\u0026#34;.endsWith(\u0026#34;lo\u0026#34;)); // true alert(\u0026#34;Hello\u0026#34;.endsWith(\u0026#34;ell\u0026#34;)); // false String Padding JavaScript provides padStart() and padEnd() for padding strings to a specific length:\npadStart(targetLength, padString): Pads the start of a string with padString until the string reaches targetLength. let text = \u0026#34;5\u0026#34;; console.log(text.padStart(3, \u0026#34;0\u0026#34;)); // \u0026#34;005\u0026#34; padEnd(targetLength, padString): Pads the end of a string with padString until the string reaches targetLength. let text = \u0026#34;5\u0026#34;; console.log(text.padEnd(3, \u0026#34;0\u0026#34;)); // \u0026#34;500\u0026#34; Special String Methods toUpperCase() and toLowerCase(): Convert the string to uppercase or lowercase. trim(): Removes whitespace from both ends of a string (spaces, tabs, newlines). let str = \u0026#34; Hello World \u0026#34;; console.log(str.trim()); // \u0026#34;Hello World\u0026#34; charCodeAt(): Returns the Unicode (ASCII) value of a character at the specified index. codePointAt(): Returns the code point of a character at the specified position (supports characters outside the Basic Multilingual Plane). let str = \u0026#34;Hello\u0026#34;; console.log(str.charCodeAt(0)); // 72 (Unicode of \u0026#39;H\u0026#39;) console.log(str.codePointAt(0)); // 72 String.fromCodePoint(): Converts a Unicode code point to a string. let char = String.fromCodePoint(72); // \u0026#34;H\u0026#34; console.log(char);\r","date":"2024-11-07","id":52,"permalink":"/personal-site/docs/java-script/js-language/1-data-types/js-01.06-string-methods/","summary":"\u003cp\u003eStrings in JavaScript are \u003cstrong\u003eprimitive values\u003c/strong\u003e and are immutable, meaning their content cannot be modified after they are created. However, they come with built-in properties and methods that allow manipulation and examination of string data.\u003c/p\u003e","tags":[],"title":"JS - 01.06 - String Methods"},{"content":"\r// Getting a substring slice(start, end) // extract part and new string substring(start, end) substr(start, length) // slices on length given\t+ concat( \u0026#34; \u0026#34;, toJoin ) trim() trimStart() trimEnd() padStart(Number, element) padEnd(Number, element) repeat(count) replace(toReplace, replacedWith) replaceAll(toReplace, replacedWith) split(at) join(with) reverse()\rString Manipulation Methods in JavaScript 1. Extracting Substrings slice(start [, end]) The slice() method extracts a portion of a string and returns a new string. If the end parameter is omitted, it slices from the start to the end of the string.\nNegative indices count from the end of the string (e.g., -1 refers to the last character). let text = \u0026#34;Apple, Kiwi, Banana\u0026#34;; alert(text.slice(0, 5)); // \u0026#34;Apple\u0026#34; (from 0 to 5) alert(text.slice(0,1) ); // \u0026#34;A\u0026#34;, from 0, 1 not included alert(text.slice(7)); // \u0026#34;Kiwi, Banana\u0026#34; (from index 7 to end) alert(text.slice(-12)); // \u0026#34;Kiwi, Banana\u0026#34; (starts 12 chars from end) alert(text.slice(-12, -6)); // \u0026#34;Kiwi,\u0026#34; (from -12 to -6) substring(start [, end]) The substring() method returns a portion of the string between the start and end indices (not including the end).\nUnlike slice(), if start is greater than end, substring() swaps them. Negative indices are treated as 0. let text = \u0026#34;Apple, Kiwi, Banana\u0026#34;; alert(text.substring(7, 13)); // \u0026#34;Kiwi\u0026#34; alert(text.substring(6, 2)); // \u0026#34;p, k\u0026#34; (start and end swapped) alert(text.substring(-4)); // \u0026#34;Apple, Kiwi, Banana\u0026#34; (negative treated as 0) let str = \u0026#34;stringify\u0026#34;; alert( str.substring(2, 6) ); // \u0026#34;ring\u0026#34; alert( str.substring(6, 2) ); // \u0026#34;ring\u0026#34; alert( str.slice(2, 6) ); // \u0026#34;ring\u0026#34; alert( str.slice(6, 2) ); // \u0026#34;\u0026#34; // not same in slice substr(start [, length]) The substr() method extracts a substring starting at start for a specified length.\nThe start parameter can be negative to count from the end. If length is omitted, the substring starts from start and continues to the end of the string. let text = \u0026#34;stringify\u0026#34;; alert(text.substr(2, 4)); // \u0026#34;ring\u0026#34; (from index 2, length 4) alert(text.substr(-4, 2)); // \u0026#34;gi\u0026#34; (from 4 chars from end, 2 chars) Method Behavior Negative Indices slice(start, end) Extracts from start to end (excluding end) Supports negative substring(start, end) Extracts between start and end (excluding end) Negative treated as 0 substr(start, length) Extracts from start for length characters Supports negative start 2. String Concatenation concat() The concat() method joins two or more strings and returns a new string. This is similar to using the + operator but allows multiple string inputs.\nlet text1 = \u0026#34;Hello\u0026#34;; let text2 = \u0026#34;World\u0026#34;; let result = text1.concat(\u0026#34; \u0026#34;, text2); // \u0026#34;Hello World\u0026#34; result = \u0026#34;Hello\u0026#34;.concat(\u0026#34; \u0026#34;, \u0026#34;World\u0026#34;); // \u0026#34;Hello World\u0026#34; 3. Whitespace Manipulation trim(), trimStart(), trimEnd() These methods remove whitespace from the string:\ntrim() removes whitespace from both ends. trimStart() removes whitespace from the beginning. trimEnd() removes whitespace from the end. let text = \u0026#34; Hello World! \u0026#34;; alert(text.trim()); // \u0026#34;Hello World!\u0026#34; alert(text.trimStart()); // \u0026#34;Hello World! \u0026#34; alert(text.trimEnd()); // \u0026#34; Hello World!\u0026#34; 4. Padding Strings padStart(targetLength, padString), padEnd(targetLength, padString) These methods pad the string to the specified length with a given character. If the string is already long enough, the original string is returned.\npadStart() pads the start of the string. padEnd() pads the end of the string. let text = \u0026#39;5\u0026#39;; alert(text.padStart(4, \u0026#34;0\u0026#34;)); // \u0026#34;0005\u0026#34; alert(text.padEnd(4, \u0026#34;x\u0026#34;)); // \u0026#34;5xxx\u0026#34; 5. Repeating Strings repeat(count) The repeat() method repeats the string a given number of times.\nlet text = \u0026#34;Hello\u0026#34;; let result = text.repeat(3); // \u0026#34;HelloHelloHello\u0026#34; 6. Replacing Parts of Strings replace(toReplace, replacedWith) The replace() method replaces the first occurrence of toReplace with replacedWith. If you want to replace all occurrences, use a regular expression with the g (global) flag.\nSearches are case sensitive, to replace case insensitive, use regular expression with an /i (insensitive) flag.\nlet text = \u0026#34;Please visit Microsoft and Microsoft\u0026#34;; let newText = text.replace(\u0026#34;Microsoft\u0026#34;, \u0026#34;W3Schools\u0026#34;); // Replaces the first occurrence alert(newText); // \u0026#34;Please visit W3Schools and Microsoft\u0026#34; newText = text.replace(/Microsoft/g, \u0026#34;W3Schools\u0026#34;); // Replaces all occurrences alert(newText); // \u0026#34;Please visit W3Schools and W3Schools\u0026#34; let newText = text.replace(/MICROSOFT/i, \u0026#34;W3School\u0026#34;); // regular expressions are written without Quotes replaceAll(toReplace, replacedWith) The replaceAll() method replaces all occurrences of the substring or pattern with the specified replacement string.\nlet text = \u0026#34;Cats are nice, but Cats are noisy!\u0026#34;; let newText = text.replaceAll(\u0026#34;Cats\u0026#34;, \u0026#34;Dogs\u0026#34;); alert(newText); // \u0026#34;Dogs are nice, but Dogs are noisy!\u0026#34; Allows to specify a regular expression instead of a string to be replaced. if parameter is a regular expression, the global flag /g must be set.\ntext = text.replaceAll(\u0026#34;Cats\u0026#34;, \u0026#34;Dogs\u0026#34;); text = text.replaceAll(/Cats/g, \u0026#34;Dogs\u0026#34;);\r7. String to Array Conversion split(separator) The split() method splits a string into an array of substrings based on a separator. If no separator is provided, the entire string becomes a single element array, i.e the returned array will contain the whole string in index[0].\nEmpty string (\u0026quot;\u0026quot;) splits the string into an array of individual characters. let sentence = \u0026#34;Secretary Bird specialize in stomping\u0026#34;; let words = sentence.split(\u0026#34; \u0026#34;); // Splits by spaces console.log(words); // [\u0026#34;Secretary\u0026#34;, \u0026#34;Bird\u0026#34;, \u0026#34;specialize\u0026#34;, \u0026#34;in\u0026#34;, \u0026#34;stomping\u0026#34;] let chars = sentence.split(\u0026#34;\u0026#34;); // Splits into individual characters console.log(chars); // [\u0026#34;S\u0026#34;, \u0026#34;e\u0026#34;, \u0026#34;c\u0026#34;, \u0026#34;r\u0026#34;, \u0026#34;e\u0026#34;, \u0026#34;t\u0026#34;, \u0026#34;a\u0026#34;, \u0026#34;r\u0026#34;, \u0026#34;y\u0026#34;, \u0026#34; \u0026#34; ...] text.split(\u0026#34;,\u0026#34;) // split on commas text.split(\u0026#34;|\u0026#34;) // split on pipe join(separator) The join() method joins all elements of an array into a single string with the specified separator.\nlet words = [\u0026#34;Secretary\u0026#34;, \u0026#34;Bird\u0026#34;, \u0026#34;specialize\u0026#34;, \u0026#34;in\u0026#34;, \u0026#34;stomping\u0026#34;]; let sentence = words.join(\u0026#34; \u0026#34;); // Joins words with a space alert(sentence); // \u0026#34;Secretary Bird specialize in stomping\u0026#34; Reversing Arrays You can reverse an array before joining it to create a string in reverse order.\nlet sentence = \u0026#34;Secretary Bird specialize in stomping\u0026#34;; let reversedWords = sentence.split(\u0026#34; \u0026#34;).reverse().join(\u0026#34; \u0026#34;); console.log(reversedWords); // \u0026#34;stomping in specialize Bird Secretary\u0026#34; Summary These are some of the most common string manipulation methods in JavaScript:\nslice(), substring(), substr(): Extract substrings with different ways of specifying start and end. concat(): Join strings together. trim(), trimStart(), trimEnd(): Remove whitespace. padStart(), padEnd(): Add padding to strings. repeat(): Repeat the string a specified number of times. replace() and replaceAll(): Replace parts of strings. split() and join(): Convert strings to arrays and vice versa. Main reference for String\n","date":"2024-11-07","id":53,"permalink":"/personal-site/docs/java-script/js-language/1-data-types/js-01.07-modifying-string/","summary":"\u003cdiv class=\"expressive-code\"\u003e\r\n  \u003cfigure class=\"frame not-content\"\u003e\r\n  \u003cfigcaption class=\"header\"\u003e\r\n    \u003cspan class=\"title\"\u003e\u003c/span\u003e\r\n  \u003c/figcaption\u003e\r\n  \u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-js\" data-lang=\"js\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e// Getting a substring\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e\t\u003cspan class=\"nx\"\u003eslice\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"nx\"\u003estart\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"nx\"\u003eend\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e   \u003cspan class=\"c1\"\u003e// extract part and new string\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e\t\u003cspan class=\"nx\"\u003esubstring\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"nx\"\u003estart\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"nx\"\u003eend\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\u003cspan class=\"nx\"\u003esubstr\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"nx\"\u003estart\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"nx\"\u003elength\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"c1\"\u003e// slices on length given\t\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"o\"\u003e+\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"nx\"\u003econcat\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e \u003cspan class=\"s2\"\u003e\u0026#34; \u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"nx\"\u003etoJoin\u003c/span\u003e \u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"nx\"\u003etrim\u003c/span\u003e\u003cspan class=\"p\"\u003e()\u003c/span\u003e   \u003cspan class=\"nx\"\u003etrimStart\u003c/span\u003e\u003cspan class=\"p\"\u003e()\u003c/span\u003e  \u003cspan class=\"nx\"\u003etrimEnd\u003c/span\u003e\u003cspan class=\"p\"\u003e()\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"nx\"\u003epadStart\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"nb\"\u003eNumber\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"nx\"\u003eelement\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"nx\"\u003epadEnd\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"nb\"\u003eNumber\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"nx\"\u003eelement\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"nx\"\u003erepeat\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"nx\"\u003ecount\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"nx\"\u003ereplace\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"nx\"\u003etoReplace\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"nx\"\u003ereplacedWith\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"nx\"\u003ereplaceAll\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"nx\"\u003etoReplace\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"nx\"\u003ereplacedWith\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"nx\"\u003esplit\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"nx\"\u003eat\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"nx\"\u003ejoin\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"kd\"\u003ewith\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"nx\"\u003ereverse\u003c/span\u003e\u003cspan class=\"p\"\u003e()\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\r\n  \u003c/figure\u003e\r\n\u003c/div\u003e\r\n\u003ch3 id=\"string-manipulation-methods-in-javascript\"\u003eString Manipulation Methods in JavaScript\u003c/h3\u003e\n\u003ch3 id=\"1-extracting-substrings\"\u003e1. \u003cstrong\u003eExtracting Substrings\u003c/strong\u003e\u003c/h3\u003e\n\u003ch4 id=\"slicestart--end\"\u003e\u003ccode\u003eslice(start [, end])\u003c/code\u003e\u003c/h4\u003e\n\u003cp\u003eThe \u003ccode\u003eslice()\u003c/code\u003e method extracts a portion of a string and returns a new string. If the \u003ccode\u003eend\u003c/code\u003e parameter is omitted, it slices from the \u003ccode\u003estart\u003c/code\u003e to the end of the string.\u003c/p\u003e","tags":[],"title":"JS - 01.07 - Modifying String"},{"content":"Booleans are a primitive data type with only two possible values: true and false. They are commonly used to represent binary states such as \u0026ldquo;yes/no\u0026rdquo; or \u0026ldquo;on/off\u0026rdquo;.\nlet nameFieldChecked = true; let ageFieldChecked = false;\rComparisons (==, !=, \u0026gt;=, \u0026lt;=) Boolean values often come as the result of comparison operations.\nconsole.log(3 \u0026gt; 2); // true console.log(2 \u0026gt; 3); // false String Comparison When comparing strings, JavaScript compares their Unicode values from left to right, one character at a time. This means that uppercase letters are considered \u0026ldquo;less than\u0026rdquo; lowercase letters (because their Unicode values are smaller), and non-alphabetical characters are also considered.\nalert(\u0026#39;z\u0026#39; \u0026gt; \u0026#39;A\u0026#39;); // true (uppercase \u0026#39;A\u0026#39; \u0026lt; lowercase \u0026#39;z\u0026#39;) alert(\u0026#39;Glow\u0026#39; \u0026gt; \u0026#39;Glee\u0026#39;); // true (\u0026#39;Glow\u0026#39; is greater than \u0026#39;Glee\u0026#39; because \u0026#39;o\u0026#39; \u0026gt; \u0026#39;e\u0026#39;) alert(\u0026#39;Bee\u0026#39; \u0026gt; \u0026#39;Be\u0026#39;); // true (\u0026#39;Bee\u0026#39; is longer than \u0026#39;Be\u0026#39;, and longer strings are greater) alert(\u0026#34;Aardvark\u0026#34; \u0026lt; \u0026#34;Zoroaster\u0026#34;); // true (\u0026#39;A\u0026#39; \u0026lt; \u0026#39;Z\u0026#39; because of Unicode comparison) JavaScript compares strings character by character based on their Unicode values. Here\u0026rsquo;s the step-by-step process:\nCompare the first character. If they are the same, move to the next character and repeat. The first difference found determines the result. [[7_type_conversions]]\nStrict Comparison (===, !==) Regular check == cannot differentiate 0 from fasle. For strict equality comparisons, JavaScript offers the === (strict equality) and !== (strict inequality) operators. These operators do not perform type conversion.\n// Regular equality comparison (performs type conversion) alert(0 == false); // true (0 is falsy, so it converts to false) alert(\u0026#34;\u0026#34; == false); // true (empty string is falsy, so it converts to false) // Strict equality comparison (does not perform type conversion) alert(\u0026#34;\u0026#34; === false); // false (\u0026#34;\u0026#34; is a string, false is a boolean) alert(0 === false); // false (0 is a number, false is a boolean) When we use === or !==, JavaScript checks both the value and the type, so there\u0026rsquo;s no unexpected type conversion.\nComparison with null \u0026amp; undefined null and undefined are special values in JavaScript. They behave differently when used with comparison operators. Equality (==): null and undefined are considered equal to each other, but not equal to any other values. Strict Equality (===): null is not equal to undefined, because they are different types. alert(null == undefined); // true (only null == undefined is true) alert(null === undefined); // false (strict comparison) alert(null == 0); // false (null is not equal to 0) alert(null == false); // false (null is not equal to false) Testing for a valid value: To check if a variable is not null or undefined, use the == or != operators. This can be useful to determine if a value has been set.\nlet value = null; if (value == null) { alert(\u0026#34;Value is null or undefined\u0026#34;); }\rMath Comparisons (\u0026gt;, \u0026lt;, \u0026lt;=, \u0026gt;=) When performing mathematical comparisons involving null or undefined, JavaScript performs type coercion:\nnull becomes 0 when compared mathematically. undefined becomes NaN (Not-a-Number), which is never equal to any number. alert(null \u0026lt; 0); // false (null is treated as 0) alert(null == 0); // false (null is not equal to 0) alert(null \u0026gt;= 0); // true (null is treated as 0) alert(undefined == 0); // false (undefined is not equal to 0) alert(undefined \u0026lt; 0); // false (undefined becomes NaN, which is not less than 0) alert(undefined \u0026gt;= 0); // false (undefined becomes NaN, which is not greater than or equal to 0) Summary: Comparison == Behavior === Behavior null == undefined true false null == 0 false false undefined == 0 false false null \u0026lt; 0 false - null \u0026gt;= 0 true - undefined \u0026lt; 0 false - undefined \u0026gt;= 0 false - ","date":"2024-11-07","id":54,"permalink":"/personal-site/docs/java-script/js-language/1-data-types/js-01.08-boolean-type/","summary":"\u003cp\u003eBooleans are a primitive data type with only two possible values: \u003ccode\u003etrue\u003c/code\u003e and \u003ccode\u003efalse\u003c/code\u003e. They are commonly used to represent binary states such as \u0026ldquo;yes/no\u0026rdquo; or \u0026ldquo;on/off\u0026rdquo;.\u003c/p\u003e","tags":[],"title":"JS - 01.08 - Boolean Type"},{"content":"Unary, Binary Operators, and Operands Operand An operand is the value or entity that an operator acts upon. In simple terms, it is the input for an operation.\nIn the expression 5 * 2:\nThe operands are 5 (on the left) and 2 (on the right). The operator * (multiplication) operates on these two operands. Sometimes, operands are also referred to as \u0026ldquo;arguments\u0026rdquo;, especially in the context of functions or method calls.\nUnary Operator A unary operator is an operator that works with only one operand. It operates on a single value and typically performs an operation such as negation or increment.\nlet x = 5; x = -x; // Unary negation operator (-) reverses the sign of \u0026#39;x\u0026#39; Here, the unary negation operator - is applied to the operand x, and it changes the value of x from 5 to -5.\nBinary Operator A binary operator is an operator that works with two operands. It performs operations between two values, such as addition, subtraction, or comparison.\nlet x = 5, y = 3; alert(y - x); // Binary subtraction operator (-) subtracts \u0026#39;x\u0026#39; from \u0026#39;y\u0026#39;, returns -2 Here, the binary operator - is applied between two operands, y and x. The result is -2 (3 minus 5).\nOperator Precedence Operator precedence determines the order in which operators are evaluated in an expression with multiple operators. Operators with higher precedence are evaluated first.\nWhen operators have the same precedence, they are evaluated from left to right (except for certain operators like ** and =, which are evaluated from right to left).\nlet result = 2 + 3 * 4; // The multiplication happens first alert(result); // 14 (3 * 4 = 12, then 2 + 12 = 14) In this example, the multiplication (*) has higher precedence than addition (+), so 3 * 4 is calculated first.\nPrecedence of Common Operators: Unary plus (+): Precedence level 14 (higher than addition) Addition (+): Precedence level 12 Assignment (=): Precedence level 2 (lowest, so assignments happen last) operator precedence table\nModify in Place Certain operators in JavaScript allow you to modify the value of a variable in place. These operators simplify assignments by performing an operation on a variable and immediately storing the result back in the same variable.\nlet n = 2; n = n + 5; // standard way n += 5; // shorthand equivalent (same result) The += operator is a shorthand for adding to a variable and assigning the result back. This is true for all arithmetic and bitwise operators like -, *, /, and %.\nn = n * 2; // standard multiplication n *= 2; // shorthand multiplication Increment / Decrement Operators The increment (++) and decrement (--) operators increase or decrease a variable’s value by 1, respectively. They can be used in two forms:\nPostfix: counter++\nThe postfix form increases the value after the current expression is evaluated. Prefix: ++counter\nThe prefix form increases the value before the current expression is evaluated. let counter = 1; alert( 2 * ++counter ); // 4 (counter is incremented first, then used in the multiplication) In this example, ++counter increments the value of counter to 2 before multiplying by 2.\nlet counter = 1; alert( 2 * counter++ ); // 2 (counter is used first, then incremented) Here, counter++ uses the current value of counter (1), and then it gets incremented after the multiplication.\nRules: Postfix: Returns the value before the increment/decrement. Prefix: Returns the value after the increment/decrement. Note: You cannot increment or decrement a constant or non-variable, such as 5++, which will result in a syntax error.\nBitwise Operators Bitwise operators are used to perform operations on the binary representation of numbers. These operators treat operands as 32-bit integers and work on the bit-level. While they are rarely used in everyday JavaScript programming, they are essential for low-level programming or working with data manipulation at the binary level.\nList of Bitwise Operators: AND (\u0026amp;): Compares each bit of two numbers and returns 1 if both bits are 1, otherwise 0. OR (|): Compares each bit of two numbers and returns 1 if at least one of the bits is 1. XOR (^): Compares each bit of two numbers and returns 1 if the bits are different, otherwise 0. NOT (~): Inverts all bits of a number (flips 1 to 0 and 0 to 1). Left Shift (\u0026lt;\u0026lt;): Shifts the bits of a number to the left by a specified number of positions, filling with zeros. Right Shift (\u0026gt;\u0026gt;): Shifts the bits of a number to the right, keeping the sign bit (for negative numbers). Zero-Fill Right Shift (\u0026gt;\u0026gt;\u0026gt;): Shifts the bits of a number to the right, filling with zeros (ignores sign bit). let a = 5; // 0101 in binary let b = 3; // 0011 in binary console.log(a \u0026amp; b); // 1 (0101 \u0026amp; 0011 = 0001) console.log(a | b); // 7 (0101 | 0011 = 0111) console.log(a ^ b); // 6 (0101 ^ 0011 = 0110) console.log(~a); // -6 (inverts all bits of 5, result in 32-bit two\u0026#39;s complement representation) console.log(a \u0026lt;\u0026lt; 1); // 10 (shift left, 0101 becomes 1010) console.log(a \u0026gt;\u0026gt; 1); // 2 (shift right, 0101 becomes 0010) console.log(a \u0026gt;\u0026gt;\u0026gt; 1); // 2 (shift right, zero-fill shift) ","date":"2024-11-07","id":55,"permalink":"/personal-site/docs/java-script/js-language/1-data-types/js-01.09-operators/","summary":"\u003ch3 id=\"unary-binary-operators-and-operands\"\u003eUnary, Binary Operators, and Operands\u003c/h3\u003e\n\u003ch4 id=\"operand\"\u003eOperand\u003c/h4\u003e\n\u003cp\u003eAn \u003cstrong\u003eoperand\u003c/strong\u003e is the value or entity that an operator acts upon. In simple terms, it is the input for an operation.\u003c/p\u003e","tags":[],"title":"JS - 01.09 - Operators"},{"content":"JavaScript automatically converts values between different types when necessary. This is commonly known as type coercion. It happens in a variety of scenarios, such as when performing mathematical operations or comparisons.\nAutomatic Type Conversion: Comparison with Different Types: JavaScript will convert values to the same type when doing comparisons, which can sometimes produce unexpected results.\nalert(\u0026#39;2\u0026#39; \u0026gt; 1); // true, because \u0026#39;2\u0026#39; is automatically converted to a number alert(\u0026#39;01\u0026#39; == 1); // true, because \u0026#39;01\u0026#39; is automatically converted to 1 (string to number) alert(true == 1); // true, because \u0026#39;true\u0026#39; is converted to 1 alert(false == 0); // true, because \u0026#39;false\u0026#39; is converted to 0 Boolean Conversion: When converting values to Boolean, JavaScript considers certain values as falsy (which become false) and others as truthy (which become true).\nFalsy values:\n0 \u0026quot;\u0026quot; (empty string) null undefined NaN Truthy values:\nNon-zero numbers Non-empty strings Objects, arrays, functions, etc. alert(Boolean(1)); // true alert(Boolean(0)); // false alert(Boolean(\u0026#34;0\u0026#34;)); // true alert(Boolean(\u0026#34;\u0026#34;)); // false alert(Boolean(\u0026#34;Hello\u0026#34;));// true alert(Boolean(null)); // false alert(Boolean([])); // true (empty array is truthy) Explicit Type Conversion There are situations where you might need to explicitly convert values between types, which can be done using functions like String(), Number(), and Boolean().\nString Conversion To convert a value to a string explicitly, you can use the String() function.\nlet value = true; value = String(value); // \u0026#34;true\u0026#34; alert(typeof value); // \u0026#34;string\u0026#34; Alternatively, you can use string concatenation to convert any value to a string:\nlet number = 123; let str = number + \u0026#34;\u0026#34;; // converts 123 to \u0026#34;123\u0026#34; Numeric Conversion When performing mathematical operations, JavaScript automatically converts strings to numbers if they represent valid numeric values. For explicit conversion, you can use the Number() function.\nlet str = \u0026#34;123\u0026#34;; let num = Number(str); alert(num); // 123 alert(typeof num); // \u0026#34;number\u0026#34; If the value is not a valid number, Number() will return NaN.\nlet str = \u0026#34;Hello\u0026#34;; let num = Number(str); alert(num); // NaN Common automatic conversions:\nundefined becomes NaN null becomes 0 Strings containing a valid numeric value are converted to numbers (e.g., \u0026quot;123\u0026quot; becomes 123). Non-numeric strings become NaN. Numeric Conversion with Unary + The unary + operator is a shorthand for converting a value to a number, similar to Number().\nalert(+true); // 1 alert(+false); // 0 alert(+\u0026#34;\u0026#34;); // 0 alert(+undefined); // NaN In the case of strings that are numbers, it works like Number():\nlet apple = \u0026#34;2\u0026#34;; let orange = \u0026#34;3\u0026#34;; alert(apple + orange); // \u0026#34;23\u0026#34; (concatenation, as both are strings) alert(+apple + +orange); // 5 (conversion to number, then addition) Summary of Common Type Conversions String Conversion:\nString(value) or concatenating with an empty string (value + \u0026quot;\u0026quot;) will convert any value to a string. Numeric Conversion:\nNumber(value) or unary + will convert values to numbers. If the value is not a valid number, it will return NaN. Boolean Conversion:\nBoolean(value) converts any value to true or false, based on its truthiness. Common Conversion Examples: let num = \u0026#34;100\u0026#34;; // string let bool = \u0026#34;false\u0026#34;; // string alert(Number(num)); // 100 (string to number) alert(Boolean(num)); // true (non-empty string is truthy) alert(String(num)); // \u0026#34;100\u0026#34; (number to string) alert(Number(bool)); // NaN (string \u0026#34;false\u0026#34; is not a valid number) alert(Boolean(bool)); // true (non-empty string is truthy) ","date":"2024-11-07","id":56,"permalink":"/personal-site/docs/java-script/js-language/1-data-types/js-01.10-auto-type-conversions/","summary":"\u003cp\u003eJavaScript automatically converts values between different types when necessary. This is commonly known as \u003cstrong\u003etype coercion\u003c/strong\u003e. It happens in a variety of scenarios, such as when performing mathematical operations or comparisons.\u003c/p\u003e","tags":[],"title":"JS - 01.10 - Auto Type Conversions"},{"content":"","date":"2024-11-07","id":57,"permalink":"/personal-site/docs/java-script/js-language/2-control-flow/conditionals/","summary":"","tags":[],"title":"Conditionals"},{"content":"","date":"2024-11-07","id":58,"permalink":"/personal-site/docs/java-script/js-language/2-control-flow/","summary":"","tags":[],"title":"Control Flow"},{"content":"Conditional Execution / Branching if() Statement The if statement allows you to execute a block of code only if a specified condition is true. The condition is typically a Boolean expression that evaluates to either true or false.\nif (condition) { // Code to execute if condition is true }\rlet hour = 14; // Example hour value let greeting; if (hour \u0026lt; 18) { greeting = \u0026#34;Good Day\u0026#34;; } console.log(greeting); // Output: Good Day let theNumber = Number(prompt(\u0026#34;Pick a number\u0026#34;)); if (!Number.isNaN(theNumber)) { console.log(\u0026#34;Your number is the square root of \u0026#34; + (theNumber * theNumber)); }\rNumber() converts the user input to a number. If the input is not a valid number (i.e., NaN). Number.isNaN() is a standard function that returns true only if the argument is NaN. The condition !Number.isNaN(theNumber) ensures that the block is executed only if the value is a valid number. So \u0026lsquo;unless theNumber is not-a-number, do this\u0026rsquo; Note: Number.isNaN() is more reliable than isNaN() because it specifically checks for NaN values, whereas isNaN() can produce unexpected results for non-numeric strings.\nBlock vs Single Statement When there’s only one statement to execute after if, curly braces {} can be omitted:\nif (1 + 1 === 2) console.log(\u0026#34;It\u0026#39;s true\u0026#34;);\rHowever, it\u0026rsquo;s considered good practice to always use curly braces for clarity and to avoid errors when adding additional statements.\nelse Clause The else clause is used to specify what should happen if the if condition evaluates to false.\nif (condition) { // Code if condition is true } else { // Code if condition is false }\rlet theNumber = Number(prompt(\u0026#34;Pick a number\u0026#34;)); if (!Number.isNaN(theNumber)) { console.log(\u0026#34;Your number is the square root of \u0026#34; + (theNumber * theNumber)); } else { console.log(\u0026#34;Why didn\u0026#39;t you give me a number?\u0026#34;); }\relse if Statement The else if statement is used when you have multiple conditions to check. It allows you to chain multiple conditions together.\nif (condition1) { // Code for condition1 } else if (condition2) { // Code for condition2 } else { // Code if none of the above conditions are true }\rlet num = Number(prompt(\u0026#34;Pick a number\u0026#34;)); if (num \u0026lt; 10) { console.log(\u0026#34;Small\u0026#34;); } else if (num \u0026lt; 100) { console.log(\u0026#34;Medium\u0026#34;); } else { console.log(\u0026#34;Large\u0026#34;); }\rNote: If num is less than 10, it prints \u0026quot;Small\u0026quot; and does not check further conditions. The evaluation stops after the first true condition.\nCommon Pitfalls String and Number Conversion\nIt’s important to handle type conversion carefully, especially when working with user inputs. For example, the Number() function can produce unexpected results if the user enters something that isn’t a valid number.\nTip: Always ensure to check that the input is valid before performing mathematical operations.\nFizzBuzz for (let number = 1; number \u0026lt;= 100; number++) { if ((number % 3) === 0 \u0026amp;\u0026amp; (number % 5) === 0) { console.log(\u0026#34;fizzbuzz\u0026#34;); } else if (number % 5 === 0) { console.log(\u0026#34;buzz\u0026#34;); } else if (number % 3 === 0) { console.log(\u0026#34;fizz\u0026#34;); } else { console.log(number); } }\r","date":"2024-11-07","id":59,"permalink":"/personal-site/docs/java-script/js-language/2-control-flow/conditionals/js-02.01-if-else/","summary":"\u003ch2 id=\"conditional-execution--branching\"\u003e\u003cstrong\u003eConditional Execution / Branching\u003c/strong\u003e\u003c/h2\u003e\n\u003ch3 id=\"if-statement\"\u003e\u003cstrong\u003e\u003ccode\u003eif()\u003c/code\u003e Statement\u003c/strong\u003e\u003c/h3\u003e\n\u003cp\u003eThe \u003ccode\u003eif\u003c/code\u003e statement allows you to execute a block of code only if a specified condition is true. The condition is typically a Boolean expression that evaluates to either \u003ccode\u003etrue\u003c/code\u003e or \u003ccode\u003efalse\u003c/code\u003e.\u003c/p\u003e","tags":[],"title":"JS - 02.01 - if, else"},{"content":"switch Statements The switch statement is a more concise and readable way to handle multiple conditional checks based on a single value. It is often used as an alternative to multiple if...else if statements, particularly when you have many conditions to check against a single expression.\nswitch (expression) { case value1: // code to execute if expression === value1 break; case value2: // code to execute if expression === value2 break; default: // code to execute if no cases match break; }\rSwitch takes single expression or value as an input, and then compares with several case values until they find one that matches that value. When the equality is found switch starts executing, starting from the correspondingcase. Execution continues till the nearest break, or end of switch. As many number of case can be put inside the block opened by switch if no case is matched, then default code is executed if exists. If there is no break then the execution continues with the next case without any checks Note: switch statements use strict equality (===), meaning both value and type must match. '3' !== 3, so a string '3' would not match the number 3.\nBasic switch Statement let a = 2 + 2; switch (a) { case 3: alert(\u0026#39;Too small\u0026#39;); break; case 4: alert(\u0026#39;Exactly\u0026#39;); break; default: alert(\u0026#39;I don’t know such values\u0026#39;); }\rExplanation: The variable a is evaluated as 4. The switch checks the cases: It doesn’t match case 3, so it moves to the next case. It matches case 4, so the corresponding code alert('Exactly') is executed. The break statement prevents further case evaluation, exiting the switch block. Weather Application switch (prompt(\u0026#34;What is the weather like?\u0026#34;)) { case \u0026#34;rainy\u0026#34;: console.log(\u0026#34;Remember to bring an umbrella.\u0026#34;); break; case \u0026#34;sunny\u0026#34;: console.log(\u0026#34;Dress lightly.\u0026#34;); break; case \u0026#34;cloudy\u0026#34;: console.log(\u0026#34;Go outside.\u0026#34;); break; default: console.log(\u0026#34;Unknown weather type!\u0026#34;); break; }\rFall-through Behavior If a break statement is not included in a case, JavaScript will execute the code for that case, but then continue executing subsequent case blocks without further checks until a break or the end of the switch is reached. This is called fall-through behavior.\nNote: Fall-through can be useful when multiple case values should trigger the same block of code. However, it is generally considered good practice to be explicit with break statements to avoid unintended fall-through.\nGrouping case Blocks You can group multiple case values that should run the same code. This allows you to combine cases that share identical behavior.\nlet a = 3; switch(a) { case 4: alert(\u0026#39;Right!\u0026#39;); break; case 3: case 5: alert(\u0026#39;Wrong\u0026#39;); alert(\u0026#34;Why don\u0026#39;t you take a math class?\u0026#34;); break; default: alert(\u0026#39;The result is strange.\u0026#39;); }\rKey Points to Remember switch uses strict equality (===): Ensure that both the value and type match. For example, '3' !== 3. break is optional: Without it, execution will \u0026ldquo;fall through\u0026rdquo; to the next case. default is optional: It provides a fallback when no cases match. Multiple case values can share the same block: You can group cases that should execute the same code. switch is generally more readable: When dealing with many conditions based on a single value, switch can improve readability compared to long chains of if...else statements. ","date":"2024-11-07","id":60,"permalink":"/personal-site/docs/java-script/js-language/2-control-flow/conditionals/js-02.02-switch-case/","summary":"\u003ch2 id=\"switch-statements\"\u003e\u003cstrong\u003e\u003ccode\u003eswitch\u003c/code\u003e Statements\u003c/strong\u003e\u003c/h2\u003e\n\u003cp\u003eThe \u003ccode\u003eswitch\u003c/code\u003e statement is a more concise and readable way to handle multiple conditional checks based on a single value. It is often used as an alternative to multiple \u003ccode\u003eif...else if\u003c/code\u003e statements, particularly when you have many conditions to check against a single expression.\u003c/p\u003e","tags":[],"title":"JS - 02.02 - switch-case"},{"content":"Ternary Operator / Conditional Operator The ? operator is called \u0026ldquo;ternary\u0026rdquo; because it has three operands, making it unique in JavaScript. It\u0026rsquo;s often referred to as the conditional or question mark operator. It provides a shorthand for if-else statements.\nThe basic syntax of the ternary operator is:\nlet result = condition ? value1 : value2; boolean ? runIfTrue : runIfFalse\rIf the condition is true, the expression returns value1; otherwise, it returns value2.\nlet accessAllowed = (age \u0026gt; 18) ? true : false;\rThis is equivalent to:\nif (age \u0026gt; 18) { accessAllowed = true; } else { accessAllowed = false; }\rThe ? operator has low precedence, meaning it runs after operators like \u0026gt;. console.log(true ? 1 : 2); // 1 console.log(false ? 1 : 2); // 2 const greeting = isBirthday ? \u0026#34;Happy birthday\u0026#34; : \u0026#34;Good morning\u0026#34;;\r// switching b/w black and white theme select.value === \u0026#34;black\u0026#34; ? update(\u0026#34;black\u0026#34;, \u0026#34;white\u0026#34;) : update (\u0026#34;white\u0026#34;, \u0026#34;black\u0026#34;); // make black to white, or white to black Multiple ? Operators (Chaining) You can chain multiple ternary operators together to handle more complex conditions:\nlet age = prompt(\u0026#34;How old are you?\u0026#34;, 18); let message = (age \u0026lt; 3) ? \u0026#34;Hi, baby\u0026#34; : // If true, \u0026#34;Hi, baby\u0026#34; (age \u0026lt; 18) ? \u0026#34;Hello\u0026#34; : // If true, \u0026#34;Hello\u0026#34; (age \u0026lt; 100) ? \u0026#34;Greetings\u0026#34; : // If true, \u0026#34;Greetings\u0026#34; \u0026#34;What an unusual age\u0026#34;; // Default message alert(message);\rThe operator evaluates the condition before the ? and selects one of the two options after the ? based on the result. In a ? b : c, it returns b if a is true, and c if a is false. This is equivalent to using if...else:\nif (age \u0026lt; 3) { message = \u0026#39;Hi, baby\u0026#39;; } else if (age \u0026lt; 18) { message = \u0026#39;Hello\u0026#39;; } else if (age \u0026lt; 100) { message = \u0026#39;Greetings\u0026#39;; } else { message = \u0026#39;What an unusual age\u0026#39;; }\rNon-traditional Use of ? It’s possible to use the ternary operator without assigning a value to a variable, though it\u0026rsquo;s generally discouraged. For example:\nlet company = prompt(\u0026#39;Which company?\u0026#39;, \u0026#39;\u0026#39;); (company == \u0026#39;Netscape\u0026#39;) ? alert(\u0026#39;Right!\u0026#39;) : alert(\u0026#39;Wrong.\u0026#39;);\rHowever, this usage is not recommended because:\nIt sacrifices readability and clarity. The purpose of the ternary operator is to return one of two values, not to execute different branches of code. For branching logic, an if...else is more appropriate. Our eyes scan the code vertically. Code blocks which span several lines are easier to understand than a long, horizontal instruction set.\nLimitations of ? No break or continue with ? The ternary operator only works with expressions and cannot handle statements like break or continue.\nif (i \u0026gt; 5) { alert(i); } else { continue; // Invalid } // This will result in an error: (i \u0026gt; 5) ? alert(i) : continue; // \u0026#39;continue\u0026#39; is not allowed here In such cases, use an if...else statement instead.\nSummary: The ternary operator is a concise way to write if-else logic. Use it to choose between two values based on a condition. Avoid using the ternary operator for executing code blocks (e.g., with alert or continue), as it reduces readability. Remember that the ternary operator has low precedence, so its evaluation order is important. ","date":"2024-11-07","id":61,"permalink":"/personal-site/docs/java-script/js-language/2-control-flow/conditionals/js-02.03-ternary-operator/","summary":"\u003ch3 id=\"ternary-operator--conditional-operator\"\u003e\u003cstrong\u003eTernary Operator / Conditional Operator\u003c/strong\u003e\u003c/h3\u003e\n\u003cp\u003eThe \u003ccode\u003e?\u003c/code\u003e operator is called \u0026ldquo;ternary\u0026rdquo; because it has \u003cstrong\u003ethree\u003c/strong\u003e operands, making it unique in JavaScript. It\u0026rsquo;s often referred to as the \u003cstrong\u003econditional\u003c/strong\u003e or \u003cstrong\u003equestion mark\u003c/strong\u003e operator. It provides a shorthand for \u003ccode\u003eif-else\u003c/code\u003e statements.\u003c/p\u003e","tags":[],"title":"JS - 02.03 - Ternary Operator"},{"content":"Logical operators are used to reason about Boolean values. They can be applied to values of any type, not just Boolean. ||(OR) \u0026amp;\u0026amp;(AND) !(NOT) ??(Nullish Coalescing)\n1. || (OR) The || (OR) operator evaluates to true if any of its operands are true.\nReturns the first truthy value.\nresult = a || b; // a or b The operands are evaluated left to right. Each operand is converted to boolean. The operator returns the first truthy value it finds, or the last value if no truthy value is found. if (1 || 0) { // Equivalent to true || false alert(\u0026#39;truthy!\u0026#39;); }\rlet hour = 9; let isWeekend = true; if (hour \u0026lt; 10 || hour \u0026gt; 18) { alert(\u0026#39;The office is closed.\u0026#39;); } if (hour \u0026lt; 10 || hour \u0026gt; 18 || isWeekend) { alert(\u0026#39;The office is closed.\u0026#39;); }\ralert(1 || 0); // 1 (truthy) alert(null || 1); // 1 (truthy) alert(null || 0 || 1); // 1 (truthy) alert(undefined || null || 0); // 0 (falsy) alert(first || last || Nickname || \u0026#34;Anonymous\u0026#34;); // \u0026#34;Anonymous\u0026#34; (if all fail) Short-Circuit Evaluation: Once the first truthy value is found, the evaluation stops, and further operands aren\u0026rsquo;t evaluated. Used to execute the command only if the left is false/falsey.\ntrue || alert(\u0026#34;not printed\u0026#34;); // alert won\u0026#39;t run false || alert(\u0026#34;printed\u0026#34;); // alert will run 2. \u0026amp;\u0026amp; (AND) \u0026amp;\u0026amp; finds the first falsy value.\nThe operator returns the first falsy value it encounters, or the last value if all operands are truthy. The \u0026amp;\u0026amp; (AND) operator evaluates to true only if both operands are true. From left to right, converting each operand to Boolean. If the result is false, stops and returns the original value of that operand. If all are truthy, then the last one is returned.\nif (hour == 12 \u0026amp;\u0026amp; minute == 30) { alert(\u0026#34;The time is 12:30\u0026#34;); } if (1 \u0026amp;\u0026amp; 0) { alert(\u0026#34;Won\u0026#39;t work as one of them is falsy\u0026#34;); }\rresult = value1 \u0026amp;\u0026amp; value2 \u0026amp;\u0026amp; value3; alert(1 \u0026amp;\u0026amp; 0); // 0 (falsy) alert(1 \u0026amp;\u0026amp; 5); // 5 (truthy) alert(null \u0026amp;\u0026amp; 5); // null (falsy) alert(0 \u0026amp;\u0026amp; \u0026#34;whatever\u0026#34;); // 0 (falsy) alert(1 \u0026amp;\u0026amp; 2 \u0026amp;\u0026amp; null \u0026amp;\u0026amp; 3); // null (falsy) alert(1 \u0026amp;\u0026amp; 2 \u0026amp;\u0026amp; 3); // 3 (truthy) Operator Precedence: The \u0026amp;\u0026amp; operator has higher precedence than ||, so it is evaluated first in expressions. a \u0026amp;\u0026amp; b || c \u0026amp;\u0026amp; d // both are equal (a \u0026amp;\u0026amp; b) || (c \u0026amp;\u0026amp; d) alert(null || 2 \u0026amp;\u0026amp; 3 || 4); // 2 \u0026amp;\u0026amp; 3 evaluates to 3 // null || 3 || 4 evaluates to 3 3. ! (NOT) The ! (NOT) operator negates the Boolean value of its operand. It flips true to false and false to true.\nresult = !value; alert(!true); // false alert(!0); // true (0 is falsy) if (!(age \u0026gt;= 14 \u0026amp;\u0026amp; age \u0026lt;= 90)) { // Age is not between 14 and 90 }\rThis is equivalent to:\nif (age \u0026lt; 14 || age \u0026gt; 90) { // Age is not between 14 and 90 }\rOperator Precedence: The ! operator has higher precedence than both \u0026amp;\u0026amp; and ||, so it is evaluated first. if (-1 || 0) alert(\u0026#39;first\u0026#39;); if (-1 \u0026amp;\u0026amp; 0) alert(\u0026#39;second\u0026#39;); if (null || -1 \u0026amp;\u0026amp; 1) alert(\u0026#39;third\u0026#39;); // \u0026#34;first\u0026#34; and \u0026#34;third\u0026#34; will execute as -1 is truthy Important Notes: Avoid Replacing if with || or \u0026amp;\u0026amp;:\nLogical operators are often used for short-circuit evaluations, not for complex branching. It’s recommended to use if...else when the logic requires more than just a true/false check. 4. Nullish Coalescing (??) The ?? (Nullish Coalescing) operator returns the right-hand operand if the left-hand operand is null or undefined. A value is considered “defined” when it’s neither null nor undefined.\nresult = a ?? b; // returns b if a is null or undefined console.log(0 ?? 100); // 0 (0 is defined, so it returns 0) console.log(null ?? 100); // 100 (null is not defined, so it returns 100) console.log(undefined ?? 100); // 100 (undefined is not defined, so it returns 100) If the left operand is not null or undefined, the ?? operator will return it:\nlet user = null; alert(user ?? \u0026#34;Anonymous\u0026#34;); // \u0026#34;Anonymous\u0026#34; (user is null) let username = null; let defaultName = \u0026#34;Guest\u0026#34;; let name = username ?? defaultName; alert(name); // \u0026#34;Guest\u0026#34; (because username is null) let username = \u0026#34;John\u0026#34;; let defaultName = \u0026#34;Guest\u0026#34;; let name = username ?? defaultName; alert(name); // \u0026#34;John\u0026#34; (because username is not null/undefined) Difference between ?? and || (OR Operator) While both the nullish coalescing operator (??) and the logical OR operator (||) check for falsy values, there is an important difference:\n?? only returns the right operand if the left operand is either null or undefined. || returns the right operand for any falsy value (including 0, false, \u0026quot;\u0026quot;, NaN, etc.). ?? is more preferable than || as it is more predictable. console.log(0 || 100); // 100 (0 is falsy, so returns 100) console.log(0 ?? 100); // 0 (0 is defined, so returns 0) console.log(null ?? 100); // 100 (null is not defined, so returns 100) console.log(\u0026#39;\u0026#39; ?? 100); // \u0026#39;\u0026#39; (empty string is defined, so returns \u0026#39;\u0026#39;) Using ?? with \u0026amp;\u0026amp; or || For safety reasons, JavaScript forbids combining ?? with \u0026amp;\u0026amp; or || without explicitly specifying precedence using parentheses. This is because the behavior of the combined operators can be ambiguous.\nlet x = 1 \u0026amp;\u0026amp; 2 ?? 3; // Syntax Error: Invalid use of ?? with \u0026amp;\u0026amp; To avoid the error, use parentheses to clarify the precedence:\nlet x = (1 \u0026amp;\u0026amp; 2) ?? 3; // Correct! The AND operation happens first if (-1 || 0) alert (\u0026#39;first\u0026#39;); if (-1 \u0026amp;\u0026amp; 0) alert (\u0026#39;second\u0026#39;): if (null || -1 \u0026amp;\u0026amp; 1) alert (\u0026#39;third\u0026#39;); // first and third will become true and execute // -1 is truthy if ( (iceCreamVanOutside || houseStatus === \u0026#34;on fire\u0026#34;)) { console.log(\u0026#34;you should leave the house quickly\u0026#34;); } else { console.log(\u0026#34;you should just stay in then\u0026#34;) } if ( !(iceCreamVanOutside || houseStatus === \u0026#34;on fire\u0026#34;)) { console.log(\u0026#34;you should just stay in then\u0026#34;); } else { console.log(\u0026#34;you should leave the house quickly\u0026#34;) }\rPassword Verification (using logical operators)\nlet userName = prompt(\u0026#34;Who\u0026#39;s there?\u0026#34;, \u0026#39;\u0026#39;); if (userName === \u0026#34;Admin\u0026#34;) { let pass = prompt(\u0026#39;Password?\u0026#39;, \u0026#39;\u0026#39;); if (pass === \u0026#39;TheMaster\u0026#39;) { alert(\u0026#34;Welcome!\u0026#34;); } else if (pass === \u0026#39;\u0026#39; || pass === null) { alert(\u0026#39;Canceled\u0026#39;); } else { alert(\u0026#39;Wrong password\u0026#39;); } } else if (userName === \u0026#39;\u0026#39; || userName === null) { alert(\u0026#39;Cancelled\u0026#39;); } else { alert(\u0026#34;I don\u0026#39;t know you\u0026#34;); }\rSummary of Logical Operators: || (OR): Returns the right operand if the left operand is any falsy value (including 0, false, \u0026quot;\u0026quot;, etc.). \u0026amp;\u0026amp; (AND): Returns the first falsy value, or the last operand if all are truthy. ! (NOT): Flips the Boolean value of its operand. ?? (Nullish Coalescing): Returns the right operand if the left operand is null or undefined. Safety with ??: Don’t combine ?? with \u0026amp;\u0026amp; or || without parentheses. Ensure proper precedence to avoid syntax errors. ","date":"2024-11-07","id":62,"permalink":"/personal-site/docs/java-script/js-language/2-control-flow/conditionals/js-02.04-logical-operators/","summary":"\u003cp\u003eLogical operators are used to reason about \u003cstrong\u003eBoolean\u003c/strong\u003e values. They can be applied to values of any type, not just Boolean.\n\u003ccode\u003e||(OR)  \u0026amp;\u0026amp;(AND)  !(NOT)  ??(Nullish Coalescing)\u003c/code\u003e\u003c/p\u003e","tags":[],"title":"JS - 02.04 - Logical Operators"},{"content":"Logical operators like \u0026amp;\u0026amp;, ??, and || handle values of different types in a unique way. They convert the left-hand value to a Boolean to decide how to proceed. These operators might return either the original left-hand value or the right-hand value, based on the evaluation.\n1. || (OR) Operator The || (OR) operator will return the left-hand value if it can be converted to true. If not, it returns the right-hand value.\nValues that are considered falsy in JavaScript (like 0, NaN, \u0026quot;\u0026quot;, null, undefined) will cause || to return the right-hand value. Otherwise, it returns the left-hand value. console.log(null || \u0026#34;user\u0026#34;); // \u0026#34;user\u0026#34; (null is falsy) console.log(\u0026#34;Agnes\u0026#34; || \u0026#34;user\u0026#34;); // \u0026#34;Agnes\u0026#34; (non-empty string is truthy) Fallback to Default Values The || operator is often used to provide default values when a variable might be empty or falsy.\nlet username = \u0026#34;\u0026#34;; let defaultName = \u0026#34;Guest\u0026#34;; let name = username || defaultName; console.log(name); // \u0026#34;Guest\u0026#34; (since username is falsy, defaultName is returned) In this example, if username is falsy (empty string, null, etc.), \u0026quot;Guest\u0026quot; is used as a fallback value.\n2. \u0026amp;\u0026amp; (AND) Operator The \u0026amp;\u0026amp; (AND) operator works oppositely to || and ??:\nIf the value on the left side is falsy (like 0, null, undefined), \u0026amp;\u0026amp; immediately returns the left-hand value. If the value on the left side is truthy, it returns the right-hand value. console.log(0 \u0026amp;\u0026amp; \u0026#34;user\u0026#34;); // 0 (0 is falsy) console.log(\u0026#34;Agnes\u0026#34; \u0026amp;\u0026amp; \u0026#34;user\u0026#34;); // \u0026#34;user\u0026#34; (both are truthy) This can be useful for chaining conditions or using a default value if the left operand is truthy:\nlet user = \u0026#34;John\u0026#34;; let role = \u0026#34;admin\u0026#34;; let userRole = user \u0026amp;\u0026amp; role; // \u0026#34;admin\u0026#34; If user is falsy (e.g., null, undefined, \u0026quot;\u0026quot;), userRole would be assigned the falsy value of user.\n3. ?? (Nullish Coalescing) Operator The ?? operator behaves similarly to ||, but with a key difference: it only considers null and undefined as falsy values. Other falsy values like 0, false, or \u0026quot;\u0026quot; are treated as valid values.\nconsole.log(null ?? \u0026#34;default\u0026#34;); // \u0026#34;default\u0026#34; (null is considered \u0026#34;undefined\u0026#34; here) console.log(0 ?? \u0026#34;default\u0026#34;); // 0 (0 is not null or undefined) console.log(undefined ?? \u0026#34;default\u0026#34;); // \u0026#34;default\u0026#34; (undefined is treated as \u0026#34;missing\u0026#34;) This allows for a more predictable behavior when you need a fallback only for missing or undefined values, rather than for all falsy values.\nShort-Circuit Evaluation All three logical operators (\u0026amp;\u0026amp;, ||, and ??) support short-circuit evaluation. This means that the right-hand operand is only evaluated if necessary.\nFor true || x, x is not evaluated because the left-hand operand is already truthy (the result is true). For false \u0026amp;\u0026amp; x, x is not evaluated because the left-hand operand is falsy (the result is false). console.log(true || alert(\u0026#34;This will not be evaluated\u0026#34;)); // The alert is not triggered. console.log(false \u0026amp;\u0026amp; alert(\u0026#34;This will not be evaluated either\u0026#34;)); // The alert is not triggered. let x = null; console.log(x ?? \u0026#34;default\u0026#34;); // \u0026#34;default\u0026#34; (null is treated as missing, so the right side is used) Conditional Operator (Ternary) and Short-Circuiting The conditional operator (? :) also behaves similarly in terms of short-circuiting. Only the second or third values are evaluated depending on the condition:\nconsole.log(true ? 1 : 2); // 1 (the second value is not evaluated) console.log(false ? 1 : 2); // 2 (the first value is not evaluated) If the condition is true, the first value is returned and the second value is ignored. If the condition is false, the second value is returned and the first value is ignored. Summary of Short-Circuiting Behavior: || (OR): Returns the first truthy value, or the second operand if the first is falsy. \u0026amp;\u0026amp; (AND): Returns the first falsy value, or the second operand if the first is truthy. ?? (Nullish Coalescing): Returns the right operand only if the left operand is null or undefined. Short-Circuiting: The right operand is only evaluated when necessary, allowing for efficient evaluations and conditional operations. ","date":"2024-11-07","id":63,"permalink":"/personal-site/docs/java-script/js-language/2-control-flow/conditionals/js-02.05-short-circuiting/","summary":"\u003cp\u003eLogical operators like \u003ccode\u003e\u0026amp;\u0026amp;\u003c/code\u003e, \u003ccode\u003e??\u003c/code\u003e, and \u003ccode\u003e||\u003c/code\u003e handle values of different types in a unique way. They \u003cstrong\u003econvert\u003c/strong\u003e the left-hand value to a Boolean to decide how to proceed. These operators might \u003cstrong\u003ereturn\u003c/strong\u003e either the original left-hand value or the right-hand value, based on the evaluation.\u003c/p\u003e","tags":[],"title":"JS - 02.05 - Short Circuiting"},{"content":"while and do...while Loops 1. while Loop The while loop executes the code inside its body as long as the condition evaluates to truthy. The condition is checked before each iteration.\ninitializer / counter variable; while (condition) { // code to run in the loop body final-expression; // increment or other operation }\rA single execution of the loop body is called an iteration.\nlet number = 0; while (number \u0026lt;= 12) { console.log(number); number = number + 2; // Increment by 2 } // Output: 0, 2, 4, 6, 8, 10, 12 let result = 1; let counter = 0; while (counter \u0026lt; 10) { result = 2 * result; // Multiply result by 2 each time counter = counter + 1; // Increment counter } console.log(result); // Output: 1024 (2^10) Shortened while condition: shorter way to write while (i != 0) is while(i) If the condition is just a variable (e.g., i), it can be simplified:\nlet i = 3; while (i) { alert(i); // Alert the current value of i i--; // Decrement i } // Output: Alerts 3, 2, 1, then stops as i becomes 0 let hash = \u0026#34;\u0026#34;; // Start with an empty string while (hash.length \u0026lt; 7) { hash += \u0026#34;#\u0026#34;; // Append one \u0026#34;#\u0026#34; to the string console.log(hash); // Output the current string } // Output: // \u0026#34;#\u0026#34; // \u0026#34;##\u0026#34; // \u0026#34;###\u0026#34; // \u0026#34;####\u0026#34; // \u0026#34;#####\u0026#34; // \u0026#34;######\u0026#34; // \u0026#34;#######\u0026#34; 2. do...while Loop The do...while loop guarantees at least one execution of its body. It first executes the code block, then checks the condition. If the condition is truthy, it continues; otherwise, it stops.\ninitializer / counter variable; do { // code to run in the loop body final-expression; // increment or other operation } while (condition);\rlet i = 0; do { alert(i); // Alert the current value of i i++; // Increment i } while (i \u0026lt; 3); // Output: Alerts 0, 1, 2 Ensuring user input:\nlet yourName; do { yourName = prompt(\u0026#34;Who are you?\u0026#34;); // Prompt the user for their name } while (!yourName); // Continue if the input is falsy (e.g., empty string) console.log(\u0026#34;Hello \u0026#34; + yourName); // Output: \u0026#34;Hello \u0026lt;user\u0026#39;s name\u0026gt;\u0026#34; In this example, the program will force the user to enter a name that isn’t an empty string or null. The ! operator converts the value to a Boolean, and any non-empty string is considered truthy.\nIndenting Code Although indentation is not required in JavaScript, proper indentation makes the code more readable for humans. Even though JavaScript can run code in a single line, using proper indentation is a best practice to maintain clarity.\nWithout indentation:\nif (true != false) {console.log(\u0026#34;That makes sense.\u0026#34;); if (1 \u0026lt; 2) {console.log(\u0026#34;No surprise there.\u0026#34;);}}\rWith proper indentation:\nif (true != false) { console.log(\u0026#34;That makes sense.\u0026#34;); if (1 \u0026lt; 2) { console.log(\u0026#34;No surprise there.\u0026#34;); } }\rThis structure makes the logic clearer and helps other developers (or your future self) easily understand your code.\nSummary while loop: Checks the condition before executing the code block. It runs as long as the condition is truthy. do...while loop: Executes the code block at least once and checks the condition after execution. Indentation: While optional, proper indentation makes code more readable and maintainable. ","date":"2024-11-07","id":64,"permalink":"/personal-site/docs/java-script/js-language/2-control-flow/loops/js-02.11-do-while-loop/","summary":"\u003ch2 id=\"while-and-dowhile-loops\"\u003e\u003cstrong\u003e\u003ccode\u003ewhile\u003c/code\u003e and \u003ccode\u003edo...while\u003c/code\u003e Loops\u003c/strong\u003e\u003c/h2\u003e\n\u003ch3 id=\"1-while-loop\"\u003e\u003cstrong\u003e1. \u003ccode\u003ewhile\u003c/code\u003e Loop\u003c/strong\u003e\u003c/h3\u003e\n\u003cp\u003eThe \u003ccode\u003ewhile\u003c/code\u003e loop executes the code inside its body \u003cstrong\u003eas long as\u003c/strong\u003e the condition evaluates to \u003cstrong\u003etruthy\u003c/strong\u003e. The condition is checked \u003cstrong\u003ebefore\u003c/strong\u003e each iteration.\u003c/p\u003e","tags":[],"title":"JS - 02.11 - do-while Loop"},{"content":"","date":"2024-11-07","id":65,"permalink":"/personal-site/docs/java-script/js-language/2-control-flow/loops/","summary":"","tags":[],"title":"Loops"},{"content":"for Loop The for loop is typically used when you know in advance how many times you need to repeat an action. It provides a concise way to initialize, check the condition, and update the loop counter in one line.\nfor (initializer; condition; final-expression) { // code to run on each iteration }\rInitializer: Initializes the loop, typically setting a counter variable. Condition: Expression that is evaluated before each iteration. If it’s false, the loop stops. Final-expression: This is executed after every iteration, usually to update the loop counter (increment or decrement). Example 1: Simple Loop with Counter for (let number = 0; number \u0026lt;= 12; number = number + 2) { console.log(number); } // Output: 0, 2, 4, 6, 8, 10, 12 In this example, number starts at 0 and increments by 2 after each iteration, stopping when it exceeds 12.\nExample 2: Loop with a Counter and Calculation let result = 1; for (let counter = 0; counter \u0026lt; 10; counter++) { result = result * 2; } console.log(result); // Output: 1024 (2^10) Here, we calculate 2^10 by doubling the result each time, using counter as the iteration variable.\nInline Variable Declaration You can declare the loop counter variable directly inside the for loop, making it local to the loop.\nfor (let i = 1; i \u0026lt; 10; i++) { const newResult = `${i} x ${i} = ${i * i}`; console.log(newResult); // Logs the square of each number }\rIn this example, each iteration calculates and prints the square of i.\nExample 3: Looping Over an Array (for...of vs for) Using for...of Loop: const cats = [\u0026#34;Lepord\u0026#34;, \u0026#34;Jaguar\u0026#34;, \u0026#34;Tiger\u0026#34;, \u0026#34;Lion\u0026#34;]; for (const cat of cats) { console.log(cat); } // Output: Lepord, Jaguar, Tiger, Lion The for...of loop is a simpler way to iterate over arrays (or other iterable objects).\nUsing Traditional for Loop: for (let i = 0; i \u0026lt; cats.length; i++) { console.log(cats[i]); } // Output: Lepord, Jaguar, Tiger, Lion This is the traditional for loop, which uses an index to access array elements.\nExample 4: Adding \u0026ldquo;and\u0026rdquo; Before the Last Item in an Array const cats = [\u0026#34;Lepord\u0026#34;, \u0026#34;Jaguar\u0026#34;, \u0026#34;Tiger\u0026#34;, \u0026#34;Lion\u0026#34;]; let myFavouriteCats = \u0026#34;My cats are called \u0026#34;; for (let i = 0; i \u0026lt; cats.length; i++) { if (i === cats.length - 1) { myFavouriteCats += `and ${cats[i]}.`; // Add \u0026#34;and\u0026#34; before last cat } else { myFavouriteCats += `${cats[i]}, `; } } console.log(myFavouriteCats); // Output: \u0026#34;My cats are called Lepord, Jaguar, Tiger, and Lion.\u0026#34; This example demonstrates how to add \u0026ldquo;and\u0026rdquo; before the last item in a list.\nUpdating Counter Variables You can update the loop counter using shorthand operators:\ncounter = counter + 1; // equivalent to counter++; counter -= 1; // equivalent to counter--; result *= 2; // equivalent to result = result * 2; These are more concise ways to update variables in loops.\nSkipping Parts of the for Loop Any part of the for loop (initializer, condition, or final-expression) can be skipped:\nSkipping Initializer:\nlet i = 0; // Initializer outside the loop for (; i \u0026lt; 3; i++) { alert(i); // Output: 0, 1, 2 }\rSkipping Final-Expression:\nlet i = 0; for (; i \u0026lt; 3;) { alert(i); // Output: 0, 1, 2 i++; // Incrementing inside the loop body }\rIn these examples, you can omit parts of the loop declaration, but the loop still functions as expected.\nChessboard Pattern To print a chessboard pattern, you can use a nested loop:\nlet size = 8; // Chessboard size (8x8) let board = \u0026#34;\u0026#34;; // Start with an empty string for (let y = 0; y \u0026lt; size; y++) { for (let x = 0; x \u0026lt; size; x++) { if ((x + y) % 2 === 0) { board += \u0026#34; \u0026#34;; // White square } else { board += \u0026#34;#\u0026#34;; // Black square } } board += \u0026#34;\\n\u0026#34;; // Newline after each row } console.log(board);\rThis code generates an 8x8 chessboard pattern using a combination of two loops. Each square is determined by whether the sum of x and y is even or odd.\nSummary for loop: Ideal when you know the exact number of iterations or need to iterate over a collection. Shorthand updates: Use ++, --, and += for more concise code. Skipping loop parts: You can omit parts of the loop (initializer, condition, final-expression) if needed. Nested loops: Useful for tasks like printing patterns (e.g., chessboard). ","date":"2024-11-07","id":66,"permalink":"/personal-site/docs/java-script/js-language/2-control-flow/loops/js-02.12-for-loop/","summary":"\u003ch2 id=\"for-loop\"\u003e\u003cstrong\u003e\u003ccode\u003efor\u003c/code\u003e Loop\u003c/strong\u003e\u003c/h2\u003e\n\u003cp\u003eThe \u003ccode\u003efor\u003c/code\u003e loop is typically used when you know in advance how many times you need to repeat an action. It provides a concise way to initialize, check the condition, and update the loop counter in one line.\u003c/p\u003e","tags":[],"title":"JS - 02.12 - for Loop"},{"content":"for…of and iterables for looping over arrays and iterable objects. [[6_Iterables|Iterable]]\nfor...of Loop The for...of loop is a convenient and modern syntax for iterating over iterable objects (e.g., arrays, strings, maps, sets). It\u0026rsquo;s a simpler way to loop through elements in a collection, without needing to manually handle indices.\nfor (const element of iterable) { // code to run for each element }\riterable: An object that can be iterated over (arrays, strings, etc.) element: The variable that will hold the value of each item in the iterable on each iteration. Example 1: Looping Through an Array const cats = [\u0026#34;Lepord\u0026#34;, \u0026#34;Jaguar\u0026#34;, \u0026#34;Tiger\u0026#34;]; for (const cat of cats) { console.log(cat); } // Output: // Lepord // Jaguar // Tiger In this example, the for...of loop iterates through the array cats, logging each cat name to the console.\nIterables An iterable is any object that can be used in a for...of loop. While arrays are commonly iterated with for...of, other iterable objects include:\nStrings: Each character can be iterated over. Maps: Iterate through key-value pairs. Sets: Iterate through values. Looping through a string:\nlet word = \u0026#34;Hello\u0026#34;; for (const char of word) { console.log(char); } // H // e // l // l // o Maps: const map = new Map([ [\u0026#39;key1\u0026#39;, \u0026#39;value1\u0026#39;], [\u0026#39;key2\u0026#39;, \u0026#39;value2\u0026#39;] ]); for (const [key, value] of map) { console.log(`${key}: ${value}`); } // key1: value1 // key2: value2 Sets: const set = new Set([1, 2, 3, 4, 5]); for (const number of set) { console.log(number); } // 1 // 2 // 3 // 4 // 5 Create a Function unique(arr) The for...of loop can be helpful for tasks such as removing duplicates from an array. Here\u0026rsquo;s an example of a function that returns an array of unique items from the input array:\nfunction unique(arr) { let result = []; for (let str of arr) { if (!result.includes(str)) { result.push(str); } } return result; } let strings = [\u0026#39;hare\u0026#39;, \u0026#39;krisna\u0026#39;, \u0026#39;hare\u0026#39;, \u0026#39;krishna\u0026#39;, \u0026#39;krishna\u0026#39;, \u0026#39;krishna\u0026#39;, \u0026#39;hare\u0026#39;, \u0026#39;hare\u0026#39;, \u0026#39;:-0\u0026#39;]; alert(unique(strings)); // Output: hare, krisna, krishna, :-0 This function iterates through the arr using for...of and checks if each element is already in the result array using the includes() method. If the element is not present, it\u0026rsquo;s added to the result.\nNote: This approach has repeated comparisons (includes()), which is inefficient for large arrays because includes() has a time complexity of O(n). A more optimized solution might involve using a Set (which guarantees uniqueness and has O(1) lookup time) or leveraging other data structures.\nOptimized Version Using Set Instead of using an array and includes(), you can use a Set, which automatically handles uniqueness for you:\nfunction unique(arr) { return [...new Set(arr)]; } let strings = [\u0026#39;hare\u0026#39;, \u0026#39;krisna\u0026#39;, \u0026#39;hare\u0026#39;, \u0026#39;krishna\u0026#39;, \u0026#39;krishna\u0026#39;, \u0026#39;krishna\u0026#39;, \u0026#39;hare\u0026#39;, \u0026#39;hare\u0026#39;, \u0026#39;:-0\u0026#39;]; alert(unique(strings)); // Output: hare, krisna, krishna, :-0 This version is much more efficient because the Set data structure automatically removes duplicates.\nSummary The for...of loop is a great way to iterate over iterables such as arrays, strings, maps, and sets. It\u0026rsquo;s simpler and cleaner than using traditional for loops when you don\u0026rsquo;t need the index. Iterables allow objects to be used in for...of loops, and they include more than just arrays. For handling unique values, using Set is a more optimized approach compared to manually checking with includes(). ","date":"2024-11-07","id":67,"permalink":"/personal-site/docs/java-script/js-language/2-control-flow/loops/js-02.13-for-of-loop/","summary":"\u003cp\u003e\u003ca href=\"https://javascript.info/array#loops\"\u003efor…of\u003c/a\u003e and \u003ca href=\"https://javascript.info/iterable\"\u003eiterables\u003c/a\u003e for looping over arrays and iterable objects.\n[[6_Iterables|Iterable]]\u003c/p\u003e\n\u003ch2 id=\"forof-loop\"\u003e\u003cstrong\u003e\u003ccode\u003efor...of\u003c/code\u003e Loop\u003c/strong\u003e\u003c/h2\u003e\n\u003cp\u003eThe \u003ccode\u003efor...of\u003c/code\u003e loop is a convenient and modern syntax for iterating over \u003cstrong\u003eiterable objects\u003c/strong\u003e (e.g., arrays, strings, maps, sets). It\u0026rsquo;s a simpler way to loop through elements in a collection, without needing to manually handle indices.\u003c/p\u003e","tags":[],"title":"JS - 02.13 - for-of Loop"},{"content":"The for…in loop is used to iterate over the keys/properties of an object. It allows us to walk through the keys (or property names) in an object.\nThe in Operator The in operator is used to check if a specific property exists in an object. It returns true if the property is present, and false otherwise.\n\u0026#34;property\u0026#34; in object\r\u0026quot;property\u0026quot;: The name of the property as a string (it can also be a variable holding the name). object: The object to check for the property. let user = {name: \u0026#34;John\u0026#34;, age: 30}; alert(\u0026#34;age\u0026#34; in user); // true (the property \u0026#39;age\u0026#39; exists in user) alert(\u0026#34;bla\u0026#34; in user); // false (the property \u0026#39;bla\u0026#39; does not exist in user) Using Variables with in: If we omit quotes it refers to a variable, that variable should contain the actual name to be tested.\nlet user = {age: 30}; let key = \u0026#34;age\u0026#34;; alert(key in user); // true (the property \u0026#39;age\u0026#39; exists in user) Handling undefined: The in operator will return true even if a property exists but its value is undefined.\nlet obj = { test: undefined }; alert(obj.test); // undefined (the property exists with value \u0026#39;undefined\u0026#39;) alert(\u0026#34;test\u0026#34; in obj); // true (the property \u0026#39;test\u0026#39; exists) for..in Loop: The for..in loop is specifically designed for iterating over the keys of an object. It allows us to access each property name (key) one by one.\nfor (key in object) { // Code to execute for each property of the object }\rkey: The variable that will hold the name of the current property. object: The object whose properties are being iterated. To iterate over the properties of an object and output both the property names (keys) and their corresponding values:\nlet user = { name: \u0026#34;John\u0026#34;, age: 30, isAdmin: true, }; for (let key in user) { alert(key); // Outputs the name of the property alert(user[key]); // Outputs the value of the property } // name // John // age // 30 // isAdmin // true Note: The looping variable (key in this case) can be named anything you prefer, such as prop, field, etc. The example for (let prop in user) is also widely used.\nOrder of Properties in Objects The order in which properties are looped over in an object depends on whether the property names are integers or non-integers.\nInteger property names are ordered by their numeric value, regardless of whether they are stored as strings. Non-integer property names (i.e., strings that are not numbers) are listed in the order they were created. Example of Integer vs Non-integer Order:\nlet codes = { \u0026#34;+49\u0026#34;: \u0026#34;Germany\u0026#34;, \u0026#34;+41\u0026#34;: \u0026#34;Switzerland\u0026#34;, \u0026#34;+44\u0026#34;: \u0026#34;Britain\u0026#34;, \u0026#34;+1\u0026#34;: \u0026#34;USA\u0026#34; }; for (let code in codes) { alert(+code); // Outputs the numeric value of the country code } // Output: // 49 // 41 // 44 // 1 When you iterate over properties with integer names (like \u0026quot;1\u0026quot;, \u0026quot;44\u0026quot;, \u0026quot;49\u0026quot;), JavaScript converts them to numbers and orders them numerically. In this case, if we want to preserve the order of non-integer property names, we can prefix the integer strings with a + (e.g., \u0026quot;+49\u0026quot; becomes \u0026quot;49\u0026quot;). Use Case of for..in The for..in loop is typically used when you need to iterate over object properties and doesn\u0026rsquo;t work with arrays in most cases (as array indices are considered numeric and for..in might return unexpected results).\nFor arrays, the for...of loop is preferred since it directly iterates over the values rather than the keys.\nSummary in operator: Used to check if a property exists in an object, even if its value is undefined. for..in loop: Loops through the keys of an object. It\u0026rsquo;s useful for working with object properties but not typically used for arrays. Order of object properties: Properties with numeric-like names are sorted numerically, while other properties are listed in the creation order. Integer properties: JavaScript automatically converts string numbers into integers and sorts them accordingly. ","date":"2024-11-07","id":68,"permalink":"/personal-site/docs/java-script/js-language/2-control-flow/loops/js-02.14-for-in-loop/","summary":"\u003cp\u003eThe \u003ca href=\"https://javascript.info/object#forin\"\u003efor…in\u003c/a\u003e loop is used to iterate over the \u003cstrong\u003ekeys/properties\u003c/strong\u003e of an object. It allows us to walk through the keys (or property names) in an object.\u003c/p\u003e","tags":[],"title":"JS - 02.14 - for-in Loop"},{"content":"break Statement The break statement is used to immediately exit from a loop, switch statement, or even a try...catch block. When encountered, the loop or block is terminated, and execution continues with the code after the loop.\nbreak in Loops:\nfor (let current = 20; current \u0026lt;= 30; current++) { if (current % 7 == 0) { console.log(current); // Outputs 21 break; // Exit the loop } }\rThe loop starts from current = 20 and increments by 1. It checks if the number is divisible by 7. When 21 is found (the first number greater than 20 and divisible by 7), it prints 21 and exits the loop with break. let sum = 0; while(true) { let value = +prompt(\u0026#34;Enter a number\u0026#34;, \u0026#39;\u0026#39;); if (!value) break; // break if empty line sum += value; } alert( \u0026#39;sum: \u0026#39; + sum );\rcontinue Statement The continue statement is used to skip the current iteration of a loop and proceed with the next iteration. The rest of the code inside the loop body is skipped for that iteration.\ncontinue in Loops:\nfor (let i = 0; i \u0026lt; 10; i++) { if (i % 2 === 0) continue; // Skip even numbers alert(i); // Outputs: 1, 3, 5, 7, 9 }\rThe loop runs from 0 to 9. The continue statement skips the even numbers (when i % 2 === 0), so the alert(i) is only executed for odd numbers. Note: continue cannot be used in ternary (? :) operators. It is only applicable within loops.\nLabels for break and continue When we need to break or continue multiple loops at once, labels come in handy.\nA label is an identifier followed by a colon (:) before a loop.\nA label is a way to name a specific loop in order to control the flow of execution in nested loops.\nlabelName: for (...){ ... } labelName: for (...){ ... }\rUsing break with Labels: To break out of a nested loop and jump directly to the code after the outer loop, you can use a label with break.\nThe break labelName breaks out of the named loop. break directive must be inside the code block.\nlabel: { // ... break label; // ... }\router: // Label for the outer loop for (let i = 0; i \u0026lt; 3; i++) { for (let j = 0; j \u0026lt; 3; j++) { let input = prompt(`Value at coords (${i},${j})`, \u0026#39;\u0026#39;); if (!input) break outer; // Exit both loops if input is empty or canceled } } alert(\u0026#39;Done!\u0026#39;);\rIn this example, if the user enters an empty string or cancels the prompt, the break outer will stop both the inner and outer loops, and the message 'Done!' will be displayed. Using continue with Labels: Similarly, you can use continue with labels to skip to the next iteration of a labeled loop.\nouter: // Label for the outer loop for (let i = 0; i \u0026lt; 3; i++) { for (let j = 0; j \u0026lt; 3; j++) { if (i === 1 \u0026amp;\u0026amp; j === 1) continue outer; // Skip the rest of the outer loop for i = 1, j = 1 console.log(`i=${i}, j=${j}`); } }\rThis example uses continue outer to skip the remaining part of the outer loop when i === 1 \u0026amp;\u0026amp; j === 1, causing the program to jump directly to the next iteration of the outer loop. Using break and continue Inside Code Blocks: You can also use break and continue inside blocks of code by labeling the block itself. This is useful when you need to break out of specific code sections rather than the entire loop.\nlabel: { // Some code before console.log(\u0026#39;Before break\u0026#39;); break label; // Exit the block console.log(\u0026#39;After break\u0026#39;); // This won\u0026#39;t run }\rHere, the break label exits the block of code before the console.log('After break') line is executed. Summary: break: Exits a loop (or switch statement, etc.) immediately, regardless of the loop\u0026rsquo;s condition. continue: Skips the current iteration of a loop and moves to the next iteration. Labels: Used to control the flow of execution in nested loops. Labels can be applied to both break and continue to exit or continue multiple loops at once. break label: Breaks out of the labeled loop. continue label: Skips to the next iteration of the labeled loop. ","date":"2024-11-07","id":69,"permalink":"/personal-site/docs/java-script/js-language/2-control-flow/loops/js-02.15-break-continue-label/","summary":"\u003ch2 id=\"break-statement\"\u003e\u003cstrong\u003e\u003ccode\u003ebreak\u003c/code\u003e Statement\u003c/strong\u003e\u003c/h2\u003e\n\u003cp\u003eThe \u003ccode\u003ebreak\u003c/code\u003e statement is used to \u003cstrong\u003eimmediately exit\u003c/strong\u003e from a loop, switch statement, or even a \u003ccode\u003etry...catch\u003c/code\u003e block. When encountered, the loop or block is terminated, and execution continues with the code after the loop.\u003c/p\u003e","tags":[],"title":"JS - 02.15 - break-continue-label"},{"content":"Iterable Objects that can be used in for..of are called iterable. To be considered iterable, an object must implement the method Symbol.iterator, which returns an iterator.\nExample: Arrays, Strings, Maps, Sets, and even custom objects that implement Symbol.iterator. Symbol.iterator Method The Symbol.iterator method is a built-in symbol in JavaScript that returns an iterator object. This iterator object must have a method called next(), which provides the logic for iteration.\nThe next() method returns an object with two properties: done: A boolean that indicates whether the iteration has completed. value: The current value of the iteration. If done is true, the iterator has finished iterating, otherwise, done will be false, and value will hold the next item in the iteration.\nlet range = { from: 1, to: 5, [Symbol.iterator]() { this.current = this.from; // Start from \u0026#34;from\u0026#34; return this; }, next() { if (this.current \u0026lt;= this.to) { return { done: false, value: this.current++ }; // Return value and increment } else { return { done: true }; // End of iteration } } }; for (let num of range) { console.log(num); // Outputs: 1, 2, 3, 4, 5 }\rIn this example, range is an object that implements Symbol.iterator. The next() method returns each number from 1 to 5. Once the value exceeds to, done: true is returned to signal the end of the iteration. String is Iterable Strings are iterable in JavaScript, meaning they can be used directly in a for..of loop. The loop iterates over each character of the string.\nfor (let char of \u0026#34;test\u0026#34;) { console.log(char); // Outputs: t, e, s, t }\rA string is considered array-like, as it has an index and a length property, but it is also iterable. Each character in the string is treated as an element that can be iterated over in a for..of loop. Surrogate Pairs in Strings JavaScript strings are Unicode-compliant, meaning they support surrogate pairs (characters that require more than one code unit to represent in UTF-16). The for..of loop correctly handles these surrogate pairs, unlike traditional array-like indexing.\nlet emoji = \u0026#34;😊\u0026#34;; for (let char of emoji) { console.log(char); // Outputs: 😊 }\rIn this case, the for..of loop properly handles the emoji as a single character, even though it might require multiple code units internally.\nArray-like Objects An array-like object is an object that has indexed properties (such as 0, 1, etc.) and a length property, but it lacks the built-in methods of arrays (like .push(), .pop(), etc.). These objects are not true arrays but are structured similarly.\nlet arrayLike = { 0: \u0026#34;Hello\u0026#34;, 1: \u0026#34;World\u0026#34;, length: 2 }; console.log(arrayLike[0]); // Outputs: Hello console.log(arrayLike[1]); // Outputs: World Although arrayLike looks like an array (because it has a length and indexed properties), it’s not a real array, so you can\u0026rsquo;t call array methods like .pop() or .push() on it directly.\nArray.from Method Array.from is a universal method that allows you to convert an iterable or array-like object into a proper JavaScript Array. After conversion, the resulting array can use all the array methods like .map(), .filter(), .reduce(), etc.\nConverting an Array-like Object to an Array\nlet arrayLike = { 0: \u0026#34;Hello\u0026#34;, 1: \u0026#34;World\u0026#34;, length: 2 }; let arr = Array.from(arrayLike); console.log(arr); // Outputs: [\u0026#39;Hello\u0026#39;, \u0026#39;World\u0026#39;] console.log(arr.pop()); // Outputs: World Converting a String to an Array You can also use Array.from to convert a string into an array of its characters:\nlet str = \u0026#34;hello\u0026#34;; let arr = Array.from(str); console.log(arr); // Outputs: [\u0026#39;h\u0026#39;, \u0026#39;e\u0026#39;, \u0026#39;l\u0026#39;, \u0026#39;l\u0026#39;, \u0026#39;o\u0026#39;] Using mapFn with Array.from Array.from accepts a second argument called mapFn, which is a mapping function applied to each element before adding it to the resulting array.\nlet numbers = [1, 2, 3]; let squaredNumbers = Array.from(numbers, num =\u0026gt; num * num); console.log(squaredNumbers); // Outputs: [1, 4, 9] In this example, Array.from creates an array from the numbers array and applies the mapFn to square each number before storing it in the new array. Syntax of Array.from: Array.from(obj[, mapFn, thisArg])\robj: The iterable or array-like object. mapFn (Optional): A function to apply to each element in the array. thisArg (Optional): A value to use as this inside the mapFn function. Summary Iterables are objects that can be iterated over using a for..of loop. They must implement the Symbol.iterator method. Strings are iterable objects, meaning you can loop over them character by character using for..of. Array-like objects are objects that have indexed properties and a length property but are not true arrays. Array.from is a powerful method that converts iterable or array-like objects into actual arrays, enabling array methods like .map(), .filter(), and more. ","date":"2024-11-07","id":70,"permalink":"/personal-site/docs/java-script/js-language/2-control-flow/loops/js-02.16-iterables/","summary":"\u003ch2 id=\"iterablehttpsjavascriptinfoiterable\"\u003e\u003ca href=\"https://javascript.info/iterable\"\u003e\u003cstrong\u003eIterable\u003c/strong\u003e\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003eObjects that can be used in \u003ccode\u003efor..of\u003c/code\u003e are called \u003cem\u003eiterable\u003c/em\u003e.\nTo be considered iterable, an object must implement the method \u003ccode\u003eSymbol.iterator\u003c/code\u003e, which returns an \u003cstrong\u003eiterator\u003c/strong\u003e.\u003c/p\u003e","tags":[],"title":"JS - 02.16 - Iterables"},{"content":"Expressions vs Statements Expression: A fragment of code that produces a value. Expressions can contain other expressions, allowing for nesting.\n1; // Expression !false; // Expression Statement: A complete instruction that stands on its own, corresponding to a full sentance. The simplest statement is an expression followed by a semicolon.\n1; // Statement !false; // Statement Side Effects: When an expression or statement produces a value but does not affect the program\u0026rsquo;s state or produce a lasting impact (i.e., the value is discarded).\n1; // No side effect, value is produced and discarded Functions in JavaScript Environment: The collection of bindings (variables) and their values that exist at any given time during the execution of a program. The environment is not empty when a program starts, as it includes built-in values and functions.\nFunctions: A function is essentially a program wrapped in a value. When you assign a function to a variable or pass it as an argument, you are using the function as a value.\nA function can be invoked, called, or applied to run the program inside it.\nprompt(\u0026#39;Enter detail\u0026#39;); // Invokes the prompt function console.log(\u0026#34;hello\u0026#34;); // Invokes the console.log function Arguments: The values provided inside the parentheses () when invoking a function. These are given to the program inside the function to be used.\nReturn Values: Functions can return values, which are values the function produces when it completes. These returned values can be used in further expressions.\nconsole.log(Math.max(2, 4)); // 4 console.log(Math.min(2, 4) + 100); // 102 Side Effects of Functions: Functions like alert(), prompt(), or console.log() often have side effects because they perform actions such as displaying a dialog box or printing to the console.\nNaming Functions Function Names: Functions typically represent actions, so their names should usually be verbs. The name should briefly describe what the function does. It\u0026rsquo;s often helpful to start with a prefix that conveys the function\u0026rsquo;s purpose:\nshow... (e.g., showMessage()) get... (e.g., getUserInput()) calc... (e.g., calcTotal()) create... (e.g., createElement()) check... (e.g., checkEligibility()) Clarity: A function\u0026rsquo;s name should clearly indicate what the function does. If a function performs multiple actions, it might be a good idea to break it into smaller functions. If two functions need to be called together, create a third function that calls both.\nBest Practices Keep functions focused: A function should do exactly what its name implies. If it does more than one thing, consider splitting it into smaller functions.\nAvoid repetition: Functions allow you to structure larger programs by reusing code, so you should use functions to reduce code repetition and isolate different parts of your program.\nOrganize functions logically: Group related functions together to make the code more readable and maintainable.\nUse descriptive names: A function\u0026rsquo;s name should give a clear idea of its purpose. Use meaningful and consistent naming conventions throughout your codebase.\n","date":"2024-11-09","id":71,"permalink":"/personal-site/docs/java-script/js-language/3-functions/js-03.01-function/","summary":"\u003ch3 id=\"expressions-vs-statements\"\u003e\u003cstrong\u003eExpressions vs Statements\u003c/strong\u003e\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003eExpression\u003c/strong\u003e: A fragment of code that produces a value. Expressions can contain other expressions, allowing for nesting.\u003c/p\u003e","tags":[],"title":"JS - 03.01 - Function"},{"content":"","date":"2024-11-07","id":72,"permalink":"/personal-site/docs/java-script/js-language/3-functions/","summary":"","tags":[],"title":"Functions"},{"content":"There are three ways to define a function in JavaScript:\nFunction Expressions, Function Declarations, and Arrow Functions.\n1. Function Expression A Function Expression is when a function is defined as part of an expression.\nThe function itself is assigned to a variable, which can then be called later.\nSince the function is part of an expression, it cannot be used before it is defined. This allows for creating a function in the middle of any expression.\nAs the function creation happens in the context of the assignment expression (to the right side of =), this is a Function Expression.\nThe function is created when the execution reaches it, meaning you cannot call it before it is declared. Function Expressions are anonymous or named functions assigned to variables. const square = function(x) { return x * x; }; console.log(square(12)); // 144 Function for square is defined as an expression and assigned to the variable square. It can be called later after the definition.\nA function starts with the function keyword, followed by a set of parameters inside parentheses (), and then a body inside curly braces {}. Functions can have no parameters or multiple parameters. The return keyword is used to return a value from the function. If no return statement is provided, the function returns undefined by default. Example with no parameters:\nconst makeNoise = function() { console.log(\u0026#34;Ping!\u0026#34;); }; makeNoise(); // Ping! Example with multiple parameters:\nconst roundTo = function(n, step) { let remainder = n % step; return n - remainder + (remainder \u0026lt; step / 2 ? 0 : step); }; console.log(roundTo(23, 10)); // 20 If the remainder is less than half of step, it rounds down; otherwise, it rounds up.\nPython Equivalent: def makeNoise(): print(\u0026#34;Ping!\u0026#34;) makeNoise() def roundTo(n, step): remainder = n % step if remainder \u0026gt;= step / 2: return (n - remainder) + step return (n - remainder) print(roundTo(23, 10)) # 20\rImportant Note:\nA Function Expression typically ends with a semicolon (;) since it\u0026rsquo;s part of an assignment statement. But function declaration do not. A Function Expression is created here as function(…) {…} inside the = assignment statement: let sayHi = …;. The semicolon ; is recommended at the end of the statement, it’s not a part of the function syntax.\nlet sayHi = function() { // function body }; // semicolon required 2. Function Declaration A Function Declaration is the classic way to define a function in JavaScript. It starts with the function keyword, followed by the function name, parameters, and the function body enclosed in curly braces.\nfunction functionName(parameter1, parameter2, ...parameterN) { // body }\rfunction square(x) { return x * x; } console.log(square(12)); // 144 //function expression let square = function(x) { return x * x; };\rA Function Declaration does not require a semicolon after it, because it\u0026rsquo;s a complete statement by itself. The function name must be valid (cannot start with a number, etc.). The function is created when the script is loaded and is hoisted to the top of its scope. This means it can be called before its actual declaration in the code. Hoisting Behavior: Function Declarations are hoisted to the top of their scope, so they can be called before they are defined in the code. Function Expressions, on the other hand, are not hoisted and can only be called after they are defined.\nconsole.log(\u0026#34;The future says: \u0026#34;, future()); function future() { return \u0026#34;You will never have flying cars\u0026#34;; }\rIn this example, the function future() can be called before it\u0026rsquo;s defined because the function declaration is hoisted to the top.\nFunction Declarations are useful when you want your functions to be accessible throughout the entire scope. Function Expressions are useful when you need to define functions dynamically (such as inside loops, conditionals, or callbacks). Function Declarations and Scope A Function Declaration is visible throughout the entire scope it’s defined in (whether in a block, function, or global scope). If a function is declared within a block (e.g., inside if or for statements), it\u0026rsquo;s only visible inside that block, not outside of it. So calling it from outside is not possible. So better to declare a function using function expression outside a code block first, and reassign it inside the code block. This makes the function visible from outside also.\nFunction Declaration Inside Code Blocks:\nlet age = 18; let welcome; // Declare the variable to hold the function if (age \u0026lt; 18) { welcome = function() { alert(\u0026#34;Hello\u0026#34;); }; } else { welcome = function() { alert(\u0026#34;Greetings\u0026#34;); }; } welcome(); // Outputs either \u0026#34;Hello\u0026#34; or \u0026#34;Greetings\u0026#34; based on the age Alternative with Ternary Operator: let age = prompt(\u0026#34;What is your age?\u0026#34;, 18); let welcome = (age \u0026lt; 18) ? function() { alert(\u0026#34;Hello\u0026#34;); } : function() { alert(\u0026#34;Greetings\u0026#34;); }; welcome(); // Outputs based on age Key Differences Between Function Expressions and Function Declarations Feature Function Declaration Function Expression Hoisting Hoisted to the top, can be called before declaration. Not hoisted, can only be called after definition. Syntax function name() {} let name = function() {} Semicolon No semicolon required after function body. Semicolon is required after function expression. Use Case Ideal for globally accessible functions. Ideal for dynamically defined functions or passing functions as arguments. Summary Function Expressions are functions assigned to variables and are only usable after their definition. Function Declarations are hoisted, meaning they can be used before the declaration in the code. Choose Function Declarations for global accessibility and Function Expressions for dynamic or localized functions. ","date":"2024-11-09","id":73,"permalink":"/personal-site/docs/java-script/js-language/3-functions/js-03.02-defining-function/","summary":"\u003cp\u003eThere are \u003cstrong\u003ethree ways\u003c/strong\u003e to define a function in JavaScript:\u003cbr\u003e\n\u003cstrong\u003eFunction Expressions\u003c/strong\u003e, \u003cstrong\u003eFunction Declarations\u003c/strong\u003e, and \u003cstrong\u003eArrow Functions\u003c/strong\u003e.\u003c/p\u003e\n\u003chr\u003e\n\u003ch3 id=\"1-function-expression\"\u003e\u003cstrong\u003e1. Function Expression\u003c/strong\u003e\u003c/h3\u003e\n\u003cp\u003eA \u003cstrong\u003eFunction Expression\u003c/strong\u003e is when a function is defined as part of an expression.\u003cbr\u003e\nThe function itself is assigned to a variable, which can then be called later.\u003cbr\u003e\nSince the function is part of an expression, it cannot be used before it is defined.\nThis allows for creating a function in the middle of any expression.\u003c/p\u003e","tags":[],"title":"JS - 03.02 - Defining Function"},{"content":"Arrow functions are a concise syntax for defining functions using the =\u0026gt; syntax, rather than the traditional function keyword. They offer several advantages, such as more concise syntax and different behavior for this.\nlet func = (arg1, arg2, ..., argN) =\u0026gt; expression;\rThis defines a function func that takes parameters arg1, arg2, ..., argN, and evaluates the given expression.\nRegular Function Expression:\nlet func = function(arg1, arg2, ..., argN) { return expression; };\rArrow Function:\nlet func = (arg1, arg2, ..., argN) =\u0026gt; expression;\rExamples of Arrow Functions Basic Arrow Functions Simple return (no block): let sum = (a, b) =\u0026gt; a + b; // Single expression, returns result automatically let double = n =\u0026gt; n * 2; // Single parameter, no need for parentheses around the parameter const square = x =\u0026gt; x * x; // Short form for single expression function let sayHi = () =\u0026gt; alert(\u0026#34;Hello\u0026#34;); // No parameters When there is only one parameter, () can be omitted. If body is single expression, rather than a block in braces, that expression will be returned from the function even without return statement.\nlet age = prompt(\u0026#34;What is your age?\u0026#34;, 18); let welcome = (age \u0026lt; 18) ? () =\u0026gt; alert(\u0026#39;Hello\u0026#39;) : () =\u0026gt; alert(\u0026#39;Greetings\u0026#39;); Welcome(); // 18 is default, // if less than 18, hello // otherwise greetings Arrow Function with a Block (Multi-line) If you need multiple statements in the function body, you must use curly braces {} and explicitly include the return statement.\nconst roundTo = (n, step) =\u0026gt; { let remainder = n % step; return n - remainder; }; let sum = (a, b) =\u0026gt; { let result = a + b; return result; }; alert(sum(1, 2)); // 3 Arrow Function with No Parameters When there are no parameters, use empty parentheses ():\nconst horn = () =\u0026gt; { console.log(\u0026#34;Toot\u0026#34;); };\rArrow Function as Arguments Arrow functions can be used in the same way as regular functions, including as arguments to other functions.\nfunction ask(question, yes, no) { if (confirm(question)) yes(); else no(); } ask( \u0026#34;Do you agree?\u0026#34;, () =\u0026gt; alert(\u0026#34;You agreed.\u0026#34;), () =\u0026gt; alert(\u0026#34;You canceled the execution.\u0026#34;) );\rask( \u0026#34;Do you agree?\u0026#34;, function() { alert(\u0026#34;You agreed.\u0026#34;);}, function() { alert(\u0026#34;You canceled the execution.\u0026#34;); } );\rArrow Functions and this Arrow functions behave differently from regular functions when it comes to the this keyword. They do not have their own this. Instead, they inherit this from the lexical scope (i.e., the surrounding context).\nArrow Functions Inheriting this\nlet user = { firstName: \u0026#34;John\u0026#34;, sayHi() { let arrow = () =\u0026gt; alert(this.firstName); // `this` refers to the `user` object arrow(); } }; user.sayHi(); // Output: \u0026#34;John\u0026#34; In this example, the arrow() function inherits this from the sayHi() method, which refers to the user object.\nArrow Functions in forEach and Similar Methods Arrow functions are useful in methods like forEach because they preserve the this context from the surrounding code:\nlet group = { title: \u0026#34;Our Group\u0026#34;, students: [\u0026#34;John\u0026#34;, \u0026#34;Pete\u0026#34;, \u0026#34;Alice\u0026#34;], showList() { this.students.forEach( student =\u0026gt; alert(this.title + \u0026#39;: \u0026#39; + student) // `this` refers to `group` ); } }; group.showList(); // Output: \u0026#34;Our Group: John\u0026#34;, \u0026#34;Our Group: Pete\u0026#34;, \u0026#34;Our Group: Alice\u0026#34; In this case, the arrow function inside forEach inherits this from the showList() method, which refers to the group object.\nRegular Function in forEach If we use a regular function inside forEach, the value of this changes to undefined in strict mode, or the global object (window in browsers) in non-strict mode:\nlet group = { title: \u0026#34;Our Group\u0026#34;, students: [\u0026#34;John\u0026#34;, \u0026#34;Pete\u0026#34;, \u0026#34;Alice\u0026#34;], showList() { this.students.forEach(function(student) { alert(this.title + \u0026#39;: \u0026#39; + student); // Error: `this` is undefined or refers to the global object }); } }; group.showList(); // Error: Cannot read property \u0026#39;title\u0026#39; of undefined Error because when forEach runs function with this=undefined by default. This doesn\u0026rsquo;t affect arrow functions because they don\u0026rsquo;t have this.\nHere, the function passed to forEach does not have its own this and refers to the global context instead of the group object, leading to an error.\nRegular functions create their own this context, which means inside the forEach method, this is no longer the group object. Arrow functions do not create their own this; instead, they inherit it from the surrounding scope, making them ideal for cases like the forEach method where you want to preserve the context. Arrow Functions Cannot Be Used as Constructors Since arrow functions do not have their own this, they cannot be used as constructors. You cannot call an arrow function with new.\nconst Person = (name) =\u0026gt; { this.name = name; }; let john = new Person(\u0026#34;John\u0026#34;); // Error: Person is not a constructor In this example, Person is an arrow function, and calling it with new will throw an error because arrow functions don\u0026rsquo;t have their own this, which is required for object creation via new.\nSummary of Arrow Functions Syntax: Arrow functions use the =\u0026gt; syntax, making them more concise than regular function expressions. No this binding: Arrow functions do not have their own this. Instead, they inherit it from the surrounding scope, making them useful for methods like forEach. Single-expression functions: If the body is a single expression, the return keyword is implicit, and you can omit the curly braces. Cannot be used as constructors: Arrow functions cannot be invoked with new because they do not have their own this. Arrow Function Quick Reference Feature Arrow Function Regular Function Syntax () =\u0026gt; expression function() { return expression; } this Binding Inherited from the outer scope (lexical this) this is dynamic, based on the call site Constructor Cannot be used as a constructor (new is not allowed) Can be used as a constructor Implicit return Yes, for single expressions No, needs an explicit return statement Parameter Parentheses Omit parentheses for a single parameter Always require parentheses ","date":"2024-11-09","id":74,"permalink":"/personal-site/docs/java-script/js-language/3-functions/js-03.03-arrow-function/","summary":"\u003cp\u003eArrow functions are a concise syntax for defining functions using the \u003ccode\u003e=\u0026gt;\u003c/code\u003e syntax, rather than the traditional \u003ccode\u003efunction\u003c/code\u003e keyword. They offer several advantages, such as more concise syntax and different behavior for \u003ccode\u003ethis\u003c/code\u003e.\u003c/p\u003e","tags":[],"title":"JS - 03.03 - Arrow Function"},{"content":"Bindings and Scopes In JavaScript, the scope refers to the context in which variables (bindings) are accessible.\nLocal Variables A local variable is declared inside a function or block (e.g., {}) and is only accessible within that function or block. Each time the function is called, a new instance of the local variables is created.\nfunction showMessage() { let message = \u0026#34;Hello, JS\u0026#34;; alert(message); } showMessage(); // Hello, JS alert(message); // Error: message is not defined outside the function message is local to the showMessage() function, so it cannot be accessed outside of it.\nVariables declared inside control structures like if, for, or while using let or const are also block-scoped, meaning they are only visible within that block.\nif (true) { let blockScoped = \u0026#34;This is block-scoped\u0026#34;; console.log(blockScoped); // This will work inside the block } console.log(blockScoped); // Error: blockScoped is not defined outside the block Variables declared using var, however, have a function scope, meaning they are visible within the function and outside of it if not enclosed in any other block.\nOuter Variables (Closure) A function in JavaScript can access variables from its outer scope (the scope in which it was defined). This allows functions to modify and use variables from the outer environment. This concept is often called closure.\nlet userName = \u0026#39;John\u0026#39;; function showMessage() { let message = \u0026#34;Hello, \u0026#34; + userName; // Accesses outer variable `userName` alert(message); } showMessage(); // Hello, John You can also modify outer variables inside a function:\nlet userName = \u0026#39;John\u0026#39;; function showMessage() { userName = \u0026#34;Bob\u0026#34;; // Outer variable `userName` is overwritten let message = \u0026#34;Hello, \u0026#34; + userName; alert(message); // Hello, Bob } alert(userName); // John (before the function call) showMessage(); alert(userName); // Bob (after the function call) If the function defines a variable with the same name as an outer variable, the inner variable shadows the outer one, meaning the function will use the local variable instead of the outer one.\nlet userName = \u0026#39;John\u0026#39;; function showMessage() { let userName = \u0026#34;Bob\u0026#34;; // Local variable shadows the outer variable let message = \u0026#34;Hello, \u0026#34; + userName; alert(message); // Hello, Bob } alert(userName); // John showMessage(); // Hello, Bob alert(userName); // John Nested Scope In JavaScript, functions and blocks can be nested within other functions and blocks, creating nested scopes. Each function or block can access variables from its outer scope, but outer scopes cannot access variables from inner scopes.\nconst hummus = function(factor) { const ingredient = function(amount, unit, name) { let ingredientAmount = amount * factor; if (ingredientAmount \u0026gt; 1) { unit += \u0026#34;s\u0026#34;; // Pluralize the unit if the amount is greater than 1 } console.log(`${ingredientAmount} ${unit} of ${name}`); }; ingredient(1, \u0026#34;can\u0026#34;, \u0026#34;Chickpeas\u0026#34;); ingredient(0.25, \u0026#34;cup\u0026#34;, \u0026#34;Tahini\u0026#34;); ingredient(0.25, \u0026#34;cup\u0026#34;, \u0026#34;Lemon Juice\u0026#34;); }; hummus(1); // Calls hummus and prints ingredient details The inner function ingredient can access the factor argument of the outer hummus function, because the inner function is within the scope of the outer function. The outer function cannot access the local bindings of the inner function, such as ingredientAmount. This form of scoping is called lexical scoping, meaning that the scope of variables is determined by the position of functions and blocks in the code.\nMaking a Counter (Closure Example) A common example of using closures is creating a counter function, which keeps track of the count even after the function has returned. This works because the inner function maintains a reference to the variables in the outer function\u0026rsquo;s scope.\nfunction makeCounter() { let count = 0; return function() { return count++; // Accesses and modifies the `count` variable }; } let counter = makeCounter(); alert(counter()); // 0 alert(counter()); // 1 alert(counter()); // 2 Here, the inner function \u0026ldquo;remembers\u0026rdquo; the count variable even after the makeCounter() function has finished executing. This is an example of a closure, where the inner function has access to the variables of its outer function. random number generator\nGlobal Variables and the Global Object A global variable is a variable that is declared outside any function or block. Its scope is the entire program, meaning it is accessible from any function or block within that program (unless shadowed by a local variable with the same name).\nlet globalVar = \u0026#39;I am a global variable\u0026#39;; function checkGlobal() { alert(globalVar); // Accessible inside any function } checkGlobal(); // I am a global variable Global variables are often stored in a global object:\nIn a browser, the global object is window. In Node.js, the global object is global. For better compatibility across different environments (e.g., browsers, Node.js), the globalThis keyword is used, which provides a standard way to access the global object in any JavaScript environment. // Example in a browser environment window.globalVar = \u0026#34;I am a global variable\u0026#34;; // This variable is a property of the `window` object console.log(globalThis.globalVar); // I am a global variable (works in both Node.js and browsers) Best Practices:\nMinimize the use of global variables. Having many global variables can lead to potential conflicts and bugs, especially in large applications. Local variables should be preferred wherever possible to avoid polluting the global scope. Summary of Scoping Rules Local Scope: Variables declared inside a function or block are local and only accessible within that function or block. Outer Scope: Functions can access variables from their outer scope. This is known as lexical scoping. Shadowing: If a local variable has the same name as an outer variable, the local variable shadows the outer variable within that function or block. Global Scope: Variables declared outside of any function or block are global and accessible from anywhere in the program. In a browser, they are properties of the window object. Closure: A function that remembers the environment in which it was created, including variables from its outer scope. ","date":"2024-11-09","id":75,"permalink":"/personal-site/docs/java-script/js-language/3-functions/js-03.04-scope-of-variable/","summary":"\u003ch2 id=\"bindings-and-scopes\"\u003e\u003cstrong\u003eBindings and Scopes\u003c/strong\u003e\u003c/h2\u003e\n\u003cp\u003eIn JavaScript, the \u003cstrong\u003escope\u003c/strong\u003e refers to the context in which variables (bindings) are accessible.\u003c/p\u003e\n\u003ch3 id=\"local-variables\"\u003e\u003cstrong\u003eLocal Variables\u003c/strong\u003e\u003c/h3\u003e\n\u003cp\u003eA \u003cstrong\u003elocal variable\u003c/strong\u003e is declared inside a function or block (e.g., \u003ccode\u003e{}\u003c/code\u003e) and is only accessible within that function or block. Each time the function is called, a new instance of the local variables is created.\u003c/p\u003e","tags":[],"title":"JS - 03.04 - Scope of Variable"},{"content":" Parameter: A variable listed inside the () in a function declaration. This is a term at declaration time. Argument: The actual value passed to the function when it is called. This is a term at call time. function showMessage(from, text) { from = \u0026#39;*\u0026#39; + from + \u0026#39;*\u0026#39;; // Modify local `from` alert(from + \u0026#34;: \u0026#34; + text); } let from = \u0026#39;Ann\u0026#39;; showMessage(from, \u0026#34;Hello\u0026#34;); // *Ann*: Hello alert(from); // Ann (the outer `from` remains unchanged) from and text are parameters of the function showMessage. The value of from is modified locally inside the function, but the outer variable from remains unchanged after the function call. Default Value for Parameters If a function is called without an argument for a parameter, the parameter\u0026rsquo;s value becomes undefined.\nHowever, you can specify a default value for a parameter, which is used when no argument is provided.\nfunction minus(a, b) { if (b === undefined) return -a; // If no second argument, return -a else return a - b; // Otherwise, return a - b } console.log(minus(10)); // -10 (b is undefined) console.log(minus(10, 5)); // 5 (both arguments provided) b defaults to undefined when not passed. The function checks if b is undefined to decide its behavior. Default Parameter Values You can assign default values directly in the function declaration using =. If the argument is not provided (or is undefined), the default value will be used.\nfunction roundTo(n, step = 1) { let remainder = n % step; return n - remainder + (remainder \u0026lt; step / 2 ? 0 : step); } console.log(roundTo(4.5)); // 5 (step defaults to 1) console.log(roundTo(4.5, 2)); // 4 (step explicitly set to 2) step defaults to 1 if not provided. Default Value with Undefined Argument If undefined is explicitly passed for a parameter, the default value will still be applied:\nfunction showMessage(from, text = \u0026#34;No text given\u0026#34;) { alert(from + \u0026#34;: \u0026#34; + text); } showMessage(\u0026#34;Ann\u0026#34;); // Ann: No text given showMessage(\u0026#34;Ann\u0026#34;, undefined); // Ann: No text given (explicitly passing `undefined`) Even though undefined is passed explicitly, the default value \u0026quot;No text given\u0026quot; will still be used for text.\nPassing a Function as a Default Value You can also pass a function as a default value for a parameter. The function will execute if no value is provided.\nfunction showMessage(from, text = anotherFunction()) { // `anotherFunction()` is called if no value is passed for `text` alert(from + \u0026#34;: \u0026#34; + text); } function anotherFunction() { return \u0026#34;Generated text\u0026#34;; // Return a value if no argument is passed } showMessage(\u0026#34;Ann\u0026#34;); // Ann: Generated text anotherFunction() is executed only when text is not passed to showMessage. Extra Arguments JavaScript functions can accept more arguments than the number of parameters specified. These extra arguments are ignored, and only the specified parameters are used.\nfunction square(x) { return x * x; } console.log(square(4, true, \u0026#34;hog\u0026#34;)); // 16 (extra arguments are ignored) In this case, only the first argument 4 is used, and the extra arguments are ignored.\nAlternative Ways to Set Default Parameters Sometimes, you might want to set default values for parameters after the function declaration. You can achieve this using various techniques:\nUsing if to Set Default Values function showMessage(text) { if (text === undefined) { text = \u0026#34;Empty message\u0026#34;; // Set default manually } alert(text); } showMessage(); // Empty message Using || Operator You can also use the logical OR (||) operator to assign default values if the parameter is falsy (e.g., undefined, null, 0, false, or \u0026quot;\u0026quot;).\nfunction showMessage(text) { text = text || \u0026#34;Empty message\u0026#34;; // If `text` is falsy, assign default alert(text); } showMessage(); // Empty message showMessage(\u0026#34;\u0026#34;); // Empty message (\u0026#34;\u0026#34; is falsy) Using Nullish Coalescing Operator (??) The nullish coalescing operator (??) is a more precise way to set defaults, as it only triggers the default if the value is null or undefined, not for other falsy values like 0 or false.\nfunction showCount(count) { alert(count ?? \u0026#34;Unknown\u0026#34;); // Only replaces `null` or `undefined` with \u0026#34;Unknown\u0026#34; } showCount(0); // 0 (0 is not null or undefined, so it\u0026#39;s not replaced) showCount(null); // Unknown (null is replaced) count ?? \u0026quot;Unknown\u0026quot; ensures that the default value is used only when count is null or undefined. Summary of Parameter Techniques Default Parameters: You can set default values for parameters directly in the function declaration using =. undefined as a Default: If no argument is passed or undefined is passed, a parameter can take its default value. Extra Arguments: JavaScript functions can ignore extra arguments that are passed beyond the declared parameters. Alternative Default Techniques: Use if statements to manually check for undefined. Use the || operator to provide a fallback for any falsy value. Use the ?? (nullish coalescing) operator for default values only when null or undefined are encountered. ","date":"2024-11-09","id":76,"permalink":"/personal-site/docs/java-script/js-language/3-functions/js-03.05-parameters-arguments/","summary":"\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eParameter\u003c/strong\u003e: A variable listed inside the \u003ccode\u003e()\u003c/code\u003e in a function declaration. This is a term at \u003cstrong\u003edeclaration time\u003c/strong\u003e.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eArgument\u003c/strong\u003e: The actual value passed to the function when it is called. This is a term at \u003cstrong\u003ecall time\u003c/strong\u003e.\u003c/li\u003e\n\u003c/ul\u003e\n\r\n\r\n\r\n\u003cdiv class=\"expressive-code\"\u003e\r\n  \u003cfigure class=\"frame not-content\"\u003e\r\n  \u003cfigcaption class=\"header\"\u003e\r\n    \u003cspan class=\"title\"\u003e\u003c/span\u003e\r\n  \u003c/figcaption\u003e\r\n  \u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-js\" data-lang=\"js\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"kd\"\u003efunction\u003c/span\u003e \u003cspan class=\"nx\"\u003eshowMessage\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"nx\"\u003efrom\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"nx\"\u003etext\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e  \u003cspan class=\"nx\"\u003efrom\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"s1\"\u003e\u0026#39;*\u0026#39;\u003c/span\u003e \u003cspan class=\"o\"\u003e+\u003c/span\u003e \u003cspan class=\"nx\"\u003efrom\u003c/span\u003e \u003cspan class=\"o\"\u003e+\u003c/span\u003e \u003cspan class=\"s1\"\u003e\u0026#39;*\u0026#39;\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e  \u003cspan class=\"c1\"\u003e// Modify local `from`\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e  \u003cspan class=\"nx\"\u003ealert\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"nx\"\u003efrom\u003c/span\u003e \u003cspan class=\"o\"\u003e+\u003c/span\u003e \u003cspan class=\"s2\"\u003e\u0026#34;: \u0026#34;\u003c/span\u003e \u003cspan class=\"o\"\u003e+\u003c/span\u003e \u003cspan class=\"nx\"\u003etext\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"kd\"\u003elet\u003c/span\u003e \u003cspan class=\"nx\"\u003efrom\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"s1\"\u003e\u0026#39;Ann\u0026#39;\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"nx\"\u003eshowMessage\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"nx\"\u003efrom\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"s2\"\u003e\u0026#34;Hello\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e  \u003cspan class=\"c1\"\u003e// *Ann*: Hello\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"nx\"\u003ealert\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"nx\"\u003efrom\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e  \u003cspan class=\"c1\"\u003e// Ann (the outer `from` remains unchanged)\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\r\n  \u003c/figure\u003e\r\n\u003c/div\u003e\r\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003efrom\u003c/code\u003e and \u003ccode\u003etext\u003c/code\u003e are \u003cstrong\u003eparameters\u003c/strong\u003e of the function \u003ccode\u003eshowMessage\u003c/code\u003e.\u003c/li\u003e\n\u003cli\u003eThe value of \u003ccode\u003efrom\u003c/code\u003e is modified locally inside the function, but the outer variable \u003ccode\u003efrom\u003c/code\u003e remains unchanged after the function call.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"default-value-for-parameters\"\u003e\u003cstrong\u003eDefault Value for Parameters\u003c/strong\u003e\u003c/h3\u003e\n\u003cp\u003eIf a function is called without an argument for a parameter, the parameter\u0026rsquo;s value becomes \u003ccode\u003eundefined\u003c/code\u003e.\u003cbr\u003e\nHowever, you can specify a \u003cstrong\u003edefault value\u003c/strong\u003e for a parameter, which is used when no argument is provided.\u003c/p\u003e","tags":[],"title":"JS - 03.05 - Parameters \u0026 Arguments"},{"content":"returning values, callback functions, recursion, and closures.\nReturning a Value Functions and Side Effects Functions can serve two purposes: they can produce side effects (such as modifying a variable, printing to the console, or changing the DOM) or they can return values.\nFunctions that return values are more useful because their output can be reused in other parts of the program.\nfunction sum(a, b) { return a + b; } let result = sum(1, 2); alert(result); // 3 Here, sum returns a value (3) that is then stored in the variable result. This value can be used or passed around later.\nReturning Early The return statement immediately stops the function\u0026rsquo;s execution and optionally returns a value. If no value is returned, the function returns undefined by default.\nfunction showMovie(age) { if (!checkAge(age)) { return; // Early exit if age is not valid } alert(\u0026#34;Showing movie\u0026#34;); }\rPure Functions A pure function is one that:\nReturns a value based only on its input arguments. Has no side effects (does not modify global variables or interact with external state). Pure functions are easy to test and reason about, as their output depends only on the input.\nFunctions as Values In JavaScript, functions are first-class citizens. This means they can be:\nAssigned to variables. Passed as arguments to other functions. Returned from other functions. Functions as Values A function can be treated as a value (like a string or a number), meaning you can assign it to a variable and execute it later.\nfunction sayHi() { alert(\u0026#34;Hello\u0026#34;); } let func = sayHi; // Assign function to variable func(); // Executes sayHi() function sayHi();\rRegular values like strings or numbers represent the data. A function can be perceived as an action. We can pass it between variables and run when we want.\nPassing Functions as Arguments You can pass functions as arguments to other functions. These are often called callback functions.\nfunction ask(question, yes, no) { if (confirm(question)) yes(); // If yes is clicked, call the `yes` callback else no(); // If no is clicked, call the `no` callback } function showOk() { alert(\u0026#34;You agreed.\u0026#34;); } function showCancel() { alert(\u0026#34;You canceled.\u0026#34;); } ask(\u0026#34;Do you agree?\u0026#34;, showOk, showCancel);\rHere:\nThe ask function takes two callback functions (showOk and showCancel). The appropriate callback is executed based on the user\u0026rsquo;s response. Anonymous Functions as Callbacks You can also pass anonymous functions directly as arguments to another function.\nask( \u0026#34;Do you agree?\u0026#34;, function() { alert(\u0026#34;You agreed.\u0026#34;); }, function() { alert(\u0026#34;You canceled.\u0026#34;); } );\rThese anonymous functions are called immediately when the ask function executes. They are not assigned to any variables, so they exist only within the scope of the ask call.\nThe Call Stack When a function is called, the program must \u0026ldquo;remember\u0026rdquo; where it left off in order to return to that point after the function finishes executing. This is handled by the call stack.\nEvery time a function is called, its execution context is pushed onto the stack. When a function returns, its context is popped from the stack, and execution continues at the point where the function was called. function chicken() { return egg(); } function egg() { return chicken(); } console.log(chicken() + \u0026#34; came first.\u0026#34;);\rThis code causes infinite recursion. The functions chicken and egg keep calling each other, filling up the call stack until it overflows.\nStack Overflow If the call stack grows too large (due to excessive function calls like the example above), a stack overflow error occurs. This happens when the computer runs out of space to store execution contexts.\nClosures A closure is a function that retains access to variables from its lexical scope, even after the function that created those variables has finished executing.\nfunction wrapValue(n) { let local = n; return () =\u0026gt; local; // Returned function remembers the `local` variable } let wrap1 = wrapValue(1); let wrap2 = wrapValue(2); console.log(wrap1()); // 1 console.log(wrap2()); // 2 Here, the wrapValue function creates a closure. The returned function remembers the value of local from the scope in which it was created.\nClosures are powerful because they allow a function to \u0026ldquo;remember\u0026rdquo; the environment in which it was created, even if that function is called later.\nfunction multiplier(factor) { return number =\u0026gt; number * factor; // Closure capturing `factor` } let twice = multiplier(2); console.log(twice(5)); // 10 The multiplier function creates a closure by returning a function that uses the factor parameter. The twice function retains the environment where factor was set to 2. Recursion A function is recursive if it calls itself in order to solve a problem. Recursive functions are commonly used to solve problems that involve repetitive sub-problems (e.g., calculating factorials, traversing trees, etc.).\nfunction power(base, exponent) { if (exponent === 0) { return 1; // Base case: anything raised to the power of 0 is 1 } else { return base * power(base, exponent - 1); // Recursive case } } console.log(power(2, 3)); // 8 Solving a Problem with Recursion The problem asks for a sequence of operations (adding 5 or multiplying by 3) to reach a target number. Here\u0026rsquo;s how you could implement it recursively:\nfunction findSolution(target) { function find(current, history) { if (current === target) { return history; // Base case: return the history if we reach the target } else if (current \u0026gt; target) { return null; // Stop if we exceed the target } else { // Recursively try adding 5 or multiplying by 3 return find(current + 5, `${history} + 5`) || find(current * 3, `${history} * 3`); } } return find(1, \u0026#34;1\u0026#34;); } console.log(findSolution(24)); // \u0026#34;(((1 * 3) + 5) * 3)\u0026#34; Here, the function findSolution uses recursion to explore two possible operations at each step: adding 5 or multiplying by 3. It keeps track of the operations in the history variable.\nGrowing Functions When working with larger functions, it\u0026rsquo;s best to break them down into smaller, reusable pieces.\nFormatting Output To print the number of cows, chickens, and pigs on a farm, formatted with leading zeros.\nfunction zeroPad(number, width) { let string = String(number); while (string.length \u0026lt; width) { string = \u0026#34;0\u0026#34; + string; } return string; } function printFarmInventory(cows, chickens, pigs) { console.log(`${zeroPad(cows, 3)} Cows`); console.log(`${zeroPad(chickens, 3)} Chickens`); console.log(`${zeroPad(pigs, 3)} Pigs`); } printFarmInventory(7, 16, 3);\rHere:\nzeroPad ensures each number is padded with zeros to be exactly three digits long. printFarmInventory uses zeroPad to format and print each animal\u0026rsquo;s count. function min that returns the minimum of two numbers. function min(a, b) { return a \u0026lt; b ? a : b; }\rfunction countB that counts the number of B characters in a string. function countB(str) { let count = 0; for (let char of str) { if (char === \u0026#39;B\u0026#39; || char === \u0026#39;b\u0026#39;) count++; } return count; }\rfunction countChar that counts occurrences of a specific character in a string. function countChar(str, char) { let count = 0; for (let c of str) { if (c === char) count++; } return count; }\r","date":"2024-11-09","id":77,"permalink":"/personal-site/docs/java-script/js-language/3-functions/js-03.06-return-recursion-call-stack/","summary":"\u003cp\u003e\u003cstrong\u003ereturning values\u003c/strong\u003e, \u003cstrong\u003ecallback functions\u003c/strong\u003e, \u003cstrong\u003erecursion\u003c/strong\u003e, and \u003cstrong\u003eclosures\u003c/strong\u003e.\u003c/p\u003e\n\u003ch2 id=\"returning-a-value\"\u003e\u003cstrong\u003eReturning a Value\u003c/strong\u003e\u003c/h2\u003e\n\u003ch3 id=\"functions-and-side-effects\"\u003e\u003cstrong\u003eFunctions and Side Effects\u003c/strong\u003e\u003c/h3\u003e\n\u003cp\u003eFunctions can serve two purposes: they can produce \u003cstrong\u003eside effects\u003c/strong\u003e (such as modifying a variable, printing to the console, or changing the DOM) or they can \u003cstrong\u003ereturn values\u003c/strong\u003e.\u003c/p\u003e","tags":[],"title":"JS - 03.06 - Return, Recursion, Call Stack"},{"content":"Scheduling Function Calls with setTimeout and setInterval JavaScript provides the ability to schedule functions to be executed later or repeatedly using two methods: setTimeout and setInterval.\nsetTimeout allows us to run a function once after the interval of time.\nsetInterval allows us to run a function repeatedly, starting after the interval of time, then repeating continuously at that interval.\nsetTimeout( ) The setTimeout() method allows you to schedule a function to run once after a specified delay.\nlet timerId = setTimeout(func|code, delay, [arg1], [arg2], ...);\rfunc|code: Function or string of code to execute after the delay. Usually it\u0026rsquo;s a function. delay: The time to wait (in milliseconds) before executing the function. The default is 0 (run immediately) (1000 ms = 1 second). arg1, arg2, \u0026hellip;: Arguments to pass to the function when it executes (optional). function sayHi() { alert(\u0026#39;Hello\u0026#39;); } setTimeout(sayHi, 1000); // Executes sayHi after 1 second (1000 ms) You can pass arguments to the function using setTimeout.\nfunction sayHi(phrase, who) { alert(phrase + \u0026#39;, \u0026#39; + who); } setTimeout(sayHi, 1000, \u0026#34;Hello\u0026#34;, \u0026#34;John\u0026#34;); // \u0026#34;Hello, John\u0026#34; Here, sayHi is called with \u0026quot;Hello\u0026quot; and \u0026quot;John\u0026quot; after 1 second.\nIf the first argument is a string, the js creates a function from it.\nUsing Arrow Functions (Best Practice): It\u0026rsquo;s better to use arrow functions rather than passing a string of code:\nsetTimeout(() =\u0026gt; alert(\u0026#39;Hello\u0026#39;), 1000);\rPassing a string is not recommended because it has security and performance issues. It is safer and clearer to use a function or an arrow function.\nCommon Mistake (Calling Function Immediately): When you call the function immediately, it doesn\u0026rsquo;t work as expected. You need to pass the function reference, not the result of its execution.\nsetTimeout(sayHi(), 1000); // WRONG! sayHi is executed immediately // Correct way: setTimeout(sayHi, 1000); // Pass the function reference, don\u0026#39;t call it setTimeout expects a reference to a function. And here sayHi() runs the function, and the result of its execution is passed to setTimeout.\nIn the wrong example, sayHi() is executed immediately, and its return value (which is undefined) is passed to setTimeout. You should pass sayHi without parentheses to ensure it is executed later.\nclearTimeout( ) You can cancel a scheduled setTimeout() function before it executes by using clearTimeout().\nclearTimeout(timerId);\rtimerId is the identifier returned by setTimeout. let timerId = setTimeout(() =\u0026gt; alert(\u0026#34;never happens\u0026#34;), 1000); clearTimeout(timerId); // This cancels the timeout before it executes Even though clearTimeout(timerId) is called, the alert will never show because the execution was canceled.\nsetInterval( ) The setInterval() method is similar to setTimeout, but it runs the function repeatedly at the specified interval.\nlet timerId = setInterval(func, delay, [arg1], [arg2], ...);\rfunc: The function to execute repeatedly. delay: The time (in milliseconds) between each execution of the function. arg1, arg2, \u0026hellip;: Arguments to pass to the function (optional). let timerId = setInterval(() =\u0026gt; alert(\u0026#39;tick\u0026#39;), 2000); // Alerts \u0026#34;tick\u0026#34; every 2 seconds Stopping the Interval: You can stop the interval by calling clearInterval() and passing the timerId returned by setInterval.\nlet timerId = setInterval(() =\u0026gt; alert(\u0026#39;tick\u0026#39;), 2000); setTimeout(() =\u0026gt; { clearInterval(timerId); // Stops the interval after 5 seconds alert(\u0026#39;stop\u0026#39;); }, 5000);\rThe \u0026quot;tick\u0026quot; alert happens every 2 seconds. After 5 seconds, the interval is cleared, and \u0026quot;stop\u0026quot; is shown. Behavior in Browsers: In most browsers, including Chrome and Firefox, the internal timer continues to run even when a modal window (alert, confirm, etc.) is open. So, if you don’t dismiss the alert for a while, the next \u0026quot;tick\u0026quot; will be shown immediately after you close the current one, making the interval appear shorter. Nested setTimeout() Nested setTimeout\nYou can schedule the next function call within the function itself, creating a loop that behaves similarly to setInterval(), but with more flexibility.\nlet timerId = setTimeout(function tick() { alert(\u0026#39;tick\u0026#39;); timerId = setTimeout(tick, 2000); // Schedules the next tick after 2 seconds }, 2000);\rThis method allows you to control when the next function is called based on the results of the current execution. For example, you might want to vary the interval or conditionally stop the execution.\nThe key difference is that with setInterval, the next interval is always scheduled immediately, but with nested setTimeout, you can choose to delay the next call further or conditionally stop it based on some logic.\nImportant Notes on setTimeout and setInterval: Timers are not guaranteed to be precise. The delay is the minimum time before execution, and the actual execution might happen later due to factors like system load, other running scripts, or the browser\u0026rsquo;s event loop.\nAvoid using setTimeout and setInterval for high-precision tasks. For tasks that require high precision (like animations or real-time operations), it\u0026rsquo;s better to use requestAnimationFrame or other appropriate APIs.\nMemory leaks can occur. If intervals or timeouts are not cleared properly, they can continue to run in the background, consuming memory and resources.\nSummary setTimeout(func, delay) runs func once after delay milliseconds. setInterval(func, delay) runs func repeatedly every delay milliseconds. Use clearTimeout(timerId) or clearInterval(timerId) to stop a scheduled timeout or interval. Nested setTimeout() provides more flexibility over setInterval() and can help in cases where you need to control the timing more precisely. ","date":"2024-11-09","id":78,"permalink":"/personal-site/docs/java-script/js-language/3-functions/js-03.07-scheduling/","summary":"\u003ch2 id=\"scheduling-function-calls-with-settimeout-and-setinterval\"\u003e\u003cstrong\u003eScheduling Function Calls with \u003ccode\u003esetTimeout\u003c/code\u003e and \u003ccode\u003esetInterval\u003c/code\u003e\u003c/strong\u003e\u003c/h2\u003e\n\u003cp\u003eJavaScript provides the ability to schedule functions to be executed \u003cstrong\u003elater\u003c/strong\u003e or \u003cstrong\u003erepeatedly\u003c/strong\u003e using two methods: \u003cstrong\u003e\u003ccode\u003esetTimeout\u003c/code\u003e\u003c/strong\u003e and \u003cstrong\u003e\u003ccode\u003esetInterval\u003c/code\u003e\u003c/strong\u003e.\u003c/p\u003e","tags":[],"title":"JS - 03.07 - Scheduling"},{"content":"Decorators and function manipulation via methods like call, apply, and bind.\n1. Decorators in JavaScript Decorators in JavaScript are a design pattern that allows you to add behavior to an existing function without modifying its structure.\nTransparent Caching Decorator using a caching decorator to cache the results of a function call.\nOriginal slow Function: function slow(x) { // Simulate a slow process (e.g., network request, heavy calculation) alert(`called with ${x}`); return x; }\rThe function slow(x) simulates some slow operation and returns the value passed to it. We want to enhance it by caching the results of function calls to avoid redundant processing.\nCaching Decorator function cachingDecorator(func) { // decorator that takes another function let cache = new Map(); // cache to store computed results return function(x) { // returns a new function if (cache.has(x)) { // check if result is cached return cache.get(x); // return the cached result } let result = func(x); // otherwise, call the original function cache.set(x, result); // store the result in the cache return result; // return the computed result }; }\rIn this cachingDecorator:\nWe create a Map called cache to store results. We return a new function that checks if the result for the argument x is already cached. If the result exists in the cache, it\u0026rsquo;s returned directly. If not, the original function (func(x)) is called, the result is cached, and then the result is returned. Applying the Decorator to slow slow = cachingDecorator(slow); alert(slow(1)); // First time, slow(1) is computed and cached alert(\u0026#34;Again: \u0026#34; + slow(1)); // Cached result returned alert(slow(2)); // First time, slow(2) is computed and cached alert(\u0026#34;Again: \u0026#34; + slow(2)); // Cached result returned In this code:\nWhen you call slow(1) for the first time, the decorator caches the result. On subsequent calls with the same argument (like slow(1) again), the result is retrieved from the cache without re-running the slow function. Limitation of Caching Decorators As you pointed out, the caching decorator may not work well with object methods. This is because when you apply a decorator to a method, it may break the this context, which is particularly important for methods in objects.\nlet obj = { name: \u0026#34;Obj\u0026#34;, slow: function(x) { alert(\u0026#39;called with \u0026#39; + x); return x; } }; obj.slow = cachingDecorator(obj.slow); obj.slow(1); // Will not work properly if we need to access `this.name` in the method To make the caching decorator work with object methods, you\u0026rsquo;d need to preserve the this context, but that\u0026rsquo;s a more advanced use case involving bind.\n2. call(), apply(), and bind() Now, let\u0026rsquo;s go over the call, apply, and bind methods — they are all used to change the this context inside a function.\ncall() The call() method allows you to explicitly set the this value in a function. It also allows you to pass arguments one by one.\nfunc.call(context, arg1, arg2, ...);\rcontext: The value of this that you want to bind. arg1, arg2, ...: Arguments to pass to the function. function sayHi() { alert(this.name); } let user = { name: \u0026#34;John\u0026#34; }; let admin = { name: \u0026#34;Admin\u0026#34; }; sayHi.call(user); // John sayHi.call(admin); // Admin In this case, calling sayHi.call(user) changes the this inside sayHi to refer to the user object, and similarly for admin.\nIf we call sayHi() directly, it would use the global this (which, in non-strict mode, would be the window object in browsers).\napply() The apply() method is very similar to call(), but instead of passing arguments one by one, you pass them as an array.\nfunc.apply(context, [argsArray]);\rfunction say(phrase) { alert(this.name + \u0026#34;: \u0026#34; + phrase); } let user = { name: \u0026#34;John\u0026#34; }; say.apply(user, [\u0026#34;Hello\u0026#34;]); // John: Hello This is equivalent to calling:\nsay.call(user, \u0026#34;Hello\u0026#34;);\rapply is useful when you have an array or a list of arguments that you want to pass to the function.\nbind() The bind() method is similar to call and apply, but instead of immediately invoking the function, it returns a new function with this bound to a specific value and optionally pre-defined arguments.\nlet boundFunction = func.bind(context, arg1, arg2, ...);\rfunction say(phrase) { alert(this.name + \u0026#34;: \u0026#34; + phrase); } let user = { name: \u0026#34;John\u0026#34; }; let boundSay = say.bind(user); // Creates a new function with `this` set to `user` boundSay(\u0026#34;Hello\u0026#34;); // John: Hello The bind() method does not invoke the function immediately. You can also pass additional arguments to bind(), which will be prepended to the arguments when the function is called. This is useful for situations where you need to create a function that can be executed later but already has a fixed this value.\nhttps://javascript.info/call-apply-decorators\nfunc.apply(context, args)\nhttps://javascript.info/bind func.bind(user)\nSummary: call() and apply() are used to invoke a function with a specific this context, but apply() takes an array of arguments while call() takes arguments one by one. bind() creates a new function with a fixed this value and optional arguments, but does not invoke the function immediately. Decorators like your caching example allow you to enhance the behavior of existing functions, and they can be used to add features like memoization (caching), logging, or validation. ","date":"2024-11-09","id":79,"permalink":"/personal-site/docs/java-script/js-language/3-functions/js-03.08-decorators/","summary":"\u003cp\u003e\u003cstrong\u003eDecorators\u003c/strong\u003e and function manipulation via methods like \u003ccode\u003ecall\u003c/code\u003e, \u003ccode\u003eapply\u003c/code\u003e, and \u003ccode\u003ebind\u003c/code\u003e.\u003c/p\u003e\n\u003chr\u003e\n\u003ch2 id=\"1-decorators-in-javascript\"\u003e\u003cstrong\u003e1. Decorators in JavaScript\u003c/strong\u003e\u003c/h2\u003e\n\u003cp\u003eDecorators in JavaScript are a design pattern that allows you to add behavior to an existing function without modifying its structure.\u003c/p\u003e","tags":[],"title":"JS - 03.08 - Decorators"},{"content":"Functions as Objects In JavaScript, functions are first-class objects. This means that they are objects themselves, and you can treat them like any other object: assign them properties, pass them around as arguments, or even add methods to them.\nThe name Property The name property of a function refers to its name. This is especially useful for debugging or logging purposes.\nfunction sayHi() { alert(\u0026#34;Hi\u0026#34;); } alert(sayHi.name); // Outputs: sayHi Method Names in Objects Even methods defined inside objects have the name property, which reflects the name of the method.\nlet user = { sayHi() { alert(\u0026#34;Hi\u0026#34;); }, sayBye: function() { alert(\u0026#34;Bye\u0026#34;); } }; alert(user.sayHi.name); // Outputs: sayHi alert(user.sayBye.name); // Outputs: sayBye Anonymous Functions and the name Property If a function is anonymous (i.e., it doesn\u0026rsquo;t have a name), the name property will be an empty string.\nlet arr = [function() {}]; alert(arr[0].name); // Outputs: \u0026lt;empty string\u0026gt; This is because anonymous functions do not have a name by default. But interestingly, in some cases, modern JavaScript engines will try to infer the function name based on the variable or context it\u0026rsquo;s assigned to.\nThe length Property The length property of a function returns the number of parameters that the function expects (i.e., the number of parameters in its declaration). This does not include the rest parameters or any other arguments passed dynamically.\nExamples: function f1(a) {} function f2(a, b) {} function f3(a, b, ...more) {} alert(f1.length); // 1 alert(f2.length); // 2 alert(f3.length); // 2 (Rest parameters aren\u0026#39;t counted) Here, f1 has one parameter, so f1.length is 1. f3 uses a rest parameter (...more), but it still counts only the non-rest parameters (a and b), so f3.length is 2.\nhttps://javascript.info/function-object\nhttps://javascript.info/new-function Creating Functions Dynamically with new Function You can create a function dynamically from a string using the new Function() constructor. This is the only way to create functions from code that is not defined directly in your source code.\nlet func = new Function([arg1, arg2, ..., argN], functionBody);\rlet sum = new Function(\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;return a + b\u0026#39;); alert(sum(1, 2)); // 3 'a' and 'b' are the arguments. 'return a + b' is the function body. Function Without Arguments: let sayHi = new Function(\u0026#39;alert(\u0026#34;Hello\u0026#34;)\u0026#39;); sayHi(); // Outputs: Hello Here, sayHi is a function that displays an alert with the string \u0026quot;Hello\u0026quot; when called.\nDynamic Functions from Strings (e.g., from a Server): You can also create functions dynamically from strings received from a server, which makes this feature quite powerful but also potentially dangerous (see below for security concerns).\nlet str = \u0026#39;alert(\u0026#34;This is dynamic!\u0026#34;)\u0026#39;; // Code string from the server let func = new Function(str); func(); // Outputs: This is dynamic! This is useful when you want to evaluate or execute code that might not be hard-coded into your script.\nSecurity Concerns with new Function While the new Function() constructor can be powerful, it introduces security risks because it allows execution of dynamically generated code (often received from external sources, like a server). This can open the door to code injection attacks if the string is not carefully validated or sanitized.\nIf you create a function from user input without sanitizing it, it could execute malicious code.\nlet userInput = \u0026#39;alert(\u0026#34;Hacked!\u0026#34;)\u0026#39;; // Simulating user input let func = new Function(userInput); // Dangerous! func(); // This will run the malicious alert! To avoid this, never use new Function() with unsanitized input from untrusted sources.\nClosure with new Function Functions created using new Function() behave slightly differently from regular functions in terms of closures. When a function is created using the new Function constructor, its lexical environment is set to the global context (window in browsers, global in Node.js), not the local context where the function is created.\nExample of new Function and Closure: function getFunc() { let value = \u0026#34;test\u0026#34;; // Creating a function with `new Function` won\u0026#39;t have access to the local `value` let func = new Function(\u0026#39;alert(value)\u0026#39;); return func; } getFunc(); // Error: value is not defined Here, value is not accessible in the function because new Function() creates the function in the global scope and doesn\u0026rsquo;t capture the local variables (value in this case) as a closure would.\nSummary: Functions are objects in JavaScript, meaning they can have properties like name and length, and can be treated as first-class objects. The name property gives the name of the function, and length tells how many parameters the function expects (excluding rest parameters). The new Function() constructor allows you to create functions from strings, enabling dynamic function generation, but this can introduce security risks if not used carefully. Closures created with new Function() have a different lexical environment and don\u0026rsquo;t capture variables from the local scope like normal functions do. ","date":"2024-11-09","id":80,"permalink":"/personal-site/docs/java-script/js-language/3-functions/js-03.09-function-object/","summary":"\u003ch2 id=\"functions-as-objects\"\u003e\u003cstrong\u003eFunctions as Objects\u003c/strong\u003e\u003c/h2\u003e\n\u003cp\u003eIn JavaScript, \u003cstrong\u003efunctions are first-class objects\u003c/strong\u003e. This means that they are \u003cstrong\u003eobjects\u003c/strong\u003e themselves, and you can treat them like any other object: assign them properties, pass them around as arguments, or even add methods to them.\u003c/p\u003e","tags":[],"title":"JS - 03.09 - Function Object"},{"content":"Objects in JavaScript Primitive types: These can only hold a single value (e.g., numbers, strings, booleans). Object types: These are collections of key-value pairs and can store multiple values. An object is a collection of key-value pairs, where:\nKey is a string. Value can be any data type. Syntax for defining an object:\nlet user = { key: value };\rBraces {} in JavaScript {} can denote: A block of statements in control structures like loops or conditionals. An object literal when defining an object. Creating an empty object:\nlet user = new Object(); // \u0026#34;object constructor\u0026#34; syntax let user = {}; // \u0026#34;object literal\u0026#34; syntax References and Copies of Objects When defining objects, they hold references to the data, not copies. This means multiple variables can reference the same object. When a primitive variable is defined, it will contain a copy of the information provided to it.\nconst obj = { data: 42 }; const objCopy = obj; // objCopy points to the same object as obj objCopy.data = 43; console.log(obj); // { data: 43 } console.log(objCopy); // { data: 43 } This is how the DOM object gets edited using storing its references in js variables.\nconst element = document.querySelector(\u0026#34;#container\u0026#34;); element.style.backgroundColor = \u0026#39;red\u0026#39;; // Changes the actual DOM element Literals and Properties An object literal is a shorthand for creating objects by directly defining key-value pairs inside {}. Each property has a keyor name before the colon:\nEach property seperated by a , comma.\nEach property in an object consists of:\nA key (or property name). A value associated with that key. let user = { name: \u0026#34;John\u0026#34;, age: 30, \u0026#34;likes birds\u0026#34;: true, // property name with spaces must be in quotes }; alert(user.name); // \u0026#34;John\u0026#34; user.isAdmin = true; // Assigning a new property delete user.age; // Deletes the \u0026#39;age\u0026#39; property Note: Property names can be any string, number, or symbol, including reserved words or multi-word names. Properties whose name are not valid bindings and multi word has to be in \u0026quot;\u0026quot;quotes. \u0026quot;touch wood\u0026quot;: \u0026quot;touched\u0026quot;\nObject Literals with Functions Objects can also have methods (functions). These are functions stored as properties of an object.\nconst person = { name: [\u0026#34;Bob\u0026#34;, \u0026#34;Smith\u0026#34;], age: 32, bio: function () { console.log(`${this.name[0]} ${this.name[1]} is ${this.age} years old.`); }, introduceSelf: function () { console.log(`Hi! I\u0026#39;m ${this.name[0]}.`); }, }; // Calling the methods person.bio(); // \u0026#34;Bob Smith is 32 years old.\u0026#34; An object like this is called an object literal - we have written out the object contents as we\u0026rsquo;ve come to create it.\nsimplified syntax for functions inside an object:\nbio: function () {...}, introduceSelf: function() {...}, // simpler is omitting the function bio() { ... }, introduceSelf() { ... },\rAccessing Properties of Objects Dot Notation The dot notation is the most common way to access properties of an object:\nperson.age; // Accessing a property person.bio(); // Calling a method The object name acts as the namespace - entered first to access anything inside the object. Next is a dot . , then what needs to be accessed.\nNested Objects: Objects can contain other objects, and to access nested properties, you chain dot notations:\nconst person = { name: { first: \u0026#34;Bob\u0026#34;, last: \u0026#34;Smith\u0026#34;, }, }; console.log(person.name.first); // \u0026#34;Bob\u0026#34; // using bracket notation person[\u0026#34;name\u0026#34;][\u0026#34;first\u0026#34;];\rSquare Bracket Notation Square bracket notation is similar to array indexing but is used for object properties. Instead of index numbers to select an item, name associated with each member\u0026rsquo;s value is used. This allows:\nDynamic property names. Accessing multi-word properties (those with spaces or special characters). Objects are also called as associative arrays\nDot notation is preferred as it is more easy to read but, if an object property name is held in a variable, then dot notation cannot be used to access the value.\nconst person = { name: [\u0026#34;Bob\u0026#34;, \u0026#34;Smith\u0026#34;], age: 32, }; function logProperty(propertyName) { console.log(person[propertyName]); // Access using a variable } logProperty(\u0026#34;name\u0026#34;); // [\u0026#34;Bob\u0026#34;, \u0026#34;Smith\u0026#34;] logProperty(\u0026#34;age\u0026#34;); // 32 Multi-word Property Names When property names are multi-word or contain special characters (like spaces), you must use square bracket notation:\nlet user = {}; user[\u0026#34;likes birds\u0026#34;] = true; // valid alert(user[\u0026#34;likes birds\u0026#34;]); // true delete user[\u0026#34;likes birds\u0026#34;]; // deletes the property Using Variables to Access Properties Square bracket notation allows properties to be accessed dynamically using variables:\nlet key = \u0026#34;likes birds\u0026#34;; user[key] = true; // Same as user[\u0026#34;likes birds\u0026#34;] = true; let user = { name: \u0026#34;John\u0026#34;, age: 30 }; let key = prompt(\u0026#34;What do you know about user?\u0026#34;, \u0026#34;name\u0026#34;); // access by variable alert( user[key] ); // John ??? for..in loop [[4_for\u0026hellip;in_loop|Details here]]\nProperty Value Shorthand When creating objects, if the property name matches the variable name, you can use shorthand syntax:\nfunction makeUser(name, age) { return { name, // shorthand for name: name age, // shorthand for age: age }; } let user = makeUser(\u0026#34;John\u0026#34;, 30); alert(user.name); // \u0026#34;John\u0026#34; Shorthand Example: let user = { name, // same as name: name age: 30, };\rSummary Objects are collections of key-value pairs, often used to store structured data. Keys (or property names) are strings, and values can be any data type. Access properties using: Dot notation: obj.property Square bracket notation: obj[\u0026quot;property\u0026quot;] (use when key is dynamic or contains spaces) For-in loop can be used to iterate over object properties. Objects can have methods, and shorthand notation can simplify property definition. Additional operators:\nTo delete a property: delete obj.prop. To check if a property with the given key exists: \u0026quot;key\u0026quot; in obj. To iterate over an object: for (let key in obj) loop. What we’ve studied in this chapter is called a “plain object”, or just Object.\n","date":"2024-11-09","id":81,"permalink":"/personal-site/docs/java-script/js-language/4-objects/js-04.01-object/","summary":"\u003ch2 id=\"objects-in-javascript\"\u003e\u003cstrong\u003eObjects in JavaScript\u003c/strong\u003e\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003ePrimitive types\u003c/strong\u003e: These can only hold a single value (e.g., numbers, strings, booleans).\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eObject types\u003c/strong\u003e: These are collections of key-value pairs and can store multiple values.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eAn object is a collection of key-value pairs, where:\u003c/p\u003e","tags":[],"title":"JS - 04.01 - Object"},{"content":"","date":"2024-11-07","id":82,"permalink":"/personal-site/docs/java-script/js-language/4-objects/","summary":"","tags":[],"title":"Objects"},{"content":"Setting Object Members 1. Assigning Values to Object Properties You can set or change the values of an object\u0026rsquo;s properties using either dot notation or bracket notation and assignment operator.\n// Using dot notation person.age = 45; person[\u0026#34;name\u0026#34;][\u0026#34;last\u0026#34;] = \u0026#34;Cratch\u0026#34;; // Using bracket notation person[\u0026#34;eyes\u0026#34;] = \u0026#34;hazel\u0026#34;; person.farewell = function () { console.log(\u0026#34;Bye everybody!\u0026#34;); };\r2. Bracket Notation for Dynamic Property Names Bracket notation allows you to use variables as property names, making it useful when property names need to be dynamic or come from user input.\nconst dataName = nameInput.value; const dataValue = nameValue.value; // Using bracket notation to set the property person[dataName] = dataValue; // Example: Setting a dynamic property name and value const dataName = \u0026#34;height\u0026#34;; const dataValue = \u0026#34;1.70m\u0026#34;; person[dataName] = dataValue; // person.height = \u0026#34;1.70m\u0026#34; Note: Dot notation cannot use variables as property names:\nperson.dataName = \u0026#34;height\u0026#34;; // This is invalid, it assigns \u0026#34;height\u0026#34; as a string literal, not the value in the variable `dataName`. Working with Objects 1. Reading Properties If a property doesn’t exist on an object, JavaScript returns undefined.\nlet day1 = { squirrel: false, events: [\u0026#34;work\u0026#34;, \u0026#34;touched tree\u0026#34;, \u0026#34;pizza\u0026#34;, \u0026#34;running\u0026#34;] }; console.log(day1.squirrel); // false console.log(day1.wolf); // undefined (property doesn\u0026#39;t exist) day1.wolf = false; // Create the \u0026#34;wolf\u0026#34; property console.log(day1.wolf); // false delete day1.squirrel; // Remove the \u0026#34;squirrel\u0026#34; property console.log(day1.squirrel); // undefined (property no longer exists) 2. The delete Operator The delete operator removes a specified property from an object.\ndelete day1.squirrel; console.log(day1.squirrel); // undefined Computed Properties in Object Literals You can use square brackets [] inside object literals to dynamically set property names. This is known as computed properties.\nlet fruit = prompt(\u0026#34;Which fruit to buy?\u0026#34;, \u0026#34;apple\u0026#34;); // user input with default value \u0026#34;apple\u0026#34; let bag = { [fruit]: 5, // property name is dynamically taken from the `fruit` variable }; alert(bag.apple); // If user chooses \u0026#34;apple\u0026#34;, this alerts \u0026#34;5\u0026#34; // [fruit] menas property name is taken from fruit. // so bag will have { apple: 5} This works the same as:\nlet fruit = prompt(\u0026#34;Which fruit to buy?\u0026#34;, \u0026#34;apple\u0026#34;); let bag = {}; bag[fruit] = 5; // property name taken from `fruit` variable 3. Complex Expressions in Computed Properties You can use more complex expressions within the square brackets.\nlet fruit = \u0026#34;apple\u0026#34;; let bag = { [fruit + \u0026#39;Computers\u0026#39;]: 5 // property name is \u0026#34;appleComputers\u0026#34; }; console.log(bag.appleComputers); // 5 Mutability of Objects Objects are mutable, meaning their values can be changed after they are created.\nlet object1 = {value: 10}; object1.value = 15; // Modify the existing value Immutability of Primitive Types Primitive data types like strings, numbers, and booleans are immutable. This means their values cannot be changed directly after assignment.\nlet str = \u0026#34;hello\u0026#34;; str[0] = \u0026#34;H\u0026#34;; // This has no effect, as strings are immutable. console.log(str); // \u0026#34;hello\u0026#34; (not \u0026#34;Hello\u0026#34;) Summary Dot Notation: Used for setting and accessing object properties with known names. Bracket Notation: Useful for dynamic property names and setting properties using variables or expressions. Delete Operator: Removes a property from an object. Computed Properties: Allows using dynamic names when defining object properties. Mutability: Objects are mutable, meaning their properties can be changed; primitive types (e.g., strings, numbers) are immutable. ","date":"2024-11-09","id":83,"permalink":"/personal-site/docs/java-script/js-language/4-objects/js-04.02-object-properties/","summary":"\u003ch2 id=\"setting-object-members\"\u003e\u003cstrong\u003eSetting Object Members\u003c/strong\u003e\u003c/h2\u003e\n\u003ch3 id=\"1-assigning-values-to-object-properties\"\u003e\u003cstrong\u003e1. Assigning Values to Object Properties\u003c/strong\u003e\u003c/h3\u003e\n\u003cp\u003eYou can set or change the values of an object\u0026rsquo;s properties using either dot notation or bracket notation and assignment operator.\u003c/p\u003e","tags":[],"title":"JS - 04.02 - Object Properties"},{"content":"object references, cloning, and deep copying in JavaScript.\nObjects vs. Primitives Primitives (like strings, numbers, booleans, etc.) are always copied by value. This means when a primitive variable is assigned to another, a copy of the value is made.\nlet message = \u0026#34;hello\u0026#34;; let phrase = message; // phrase is a copy of message Objects are copied by reference. When you assign an object to a variable, that variable doesn\u0026rsquo;t hold the object itself but rather the memory address where the object is stored.\nlet user = { name: \u0026#34;John\u0026#34; }; let admin = user; // \u0026#39;admin\u0026#39; holds a reference to the same object as \u0026#39;user\u0026#39; admin.name = \u0026#34;Pete\u0026#34;; // Modifying \u0026#39;admin\u0026#39; also changes \u0026#39;user\u0026#39; console.log(user.name); // \u0026#34;Pete\u0026#34; Reference Behavior of Objects When you assign an object to another variable, the second variable holds a reference to the same object, meaning both variables point to the same object.\nlet object1 = { value: 10 }; let object2 = { value: 10 }; let object3 = object1; // object3 references object1 console.log(object1 == object2); // false (different objects, same structure) console.log(object1 == object3); // true (same object) Reassigning Object Variables Reassigning a variable that holds an object does not affect other variables pointing to the same object. Only the reference changes for the reassigned variable.\nlet animal = { species: \u0026#34;dog\u0026#34; }; let dog = animal; // both \u0026#39;animal\u0026#39; and \u0026#39;dog\u0026#39; reference the same object animal = { species: \u0026#34;cat\u0026#34; }; // \u0026#39;animal\u0026#39; is reassigned to a new object console.log(animal); // { species: \u0026#34;cat\u0026#34; } console.log(dog); // { species: \u0026#34;dog\u0026#34; } (dog still points to the original object) [[4_for\u0026hellip;in_loop|for..in loop]] Cloning and Merging Objects Shallow Copy (Copying References) When copying an object, only primitive values are copied by value, while objects inside the object are still copied by reference.\nlet user = { name: \u0026#34;John\u0026#34;, age: 30 }; let copy = {}; // Copying properties of \u0026#39;user\u0026#39; into \u0026#39;copy\u0026#39; for (let prop in user) { copy[prop] = user[prop]; } copy.name = \u0026#34;Pete\u0026#34;; // Changing copy does not affect user console.log(user.name); // \u0026#34;John\u0026#34; Using Object.assign for Shallow Copy Object.assign() performs a shallow copy. This means it copies the top-level properties, but nested objects are copied by reference. Object.assign(dest, ...sources)\rlet user = { name: \u0026#34;John\u0026#34; }; let permit1 = { canView: true }; let permit2 = { canEdit: true }; // Merging multiple objects into one Object.assign(user, permit1, permit2); console.log(user.name); // \u0026#34;John\u0026#34; console.log(user.canView); // true console.log(user.canEdit); // true Using Object.assign() to Clone Object.assign() can also be used to create a clone of an object. However, it only performs a shallow copy.\nlet user = { name: \u0026#34;John\u0026#34;, age: 30 }; let copy = Object.assign({}, user); // Creating a shallow copy console.log(copy.name); // \u0026#34;John\u0026#34; Spread syntax can also be used to clone an object.\nDeep Cloning (Nested Objects) Deep cloning is needed when an object contains other objects. A shallow copy will only copy references to nested objects, not the actual content.\nTo make a true deep copy, we must copy nested objects properly, and tools like structuredClone() can help with that. structuredClone()\nDeep Cloning with structuredClone() The structuredClone() method performs deep cloning of objects, copying both the object and its nested properties.\nlet user = { name: \u0026#34;John\u0026#34;, age: 30, sizes: { height: 182, width: 50 } }; let clone = structuredClone(user); console.log(user.sizes == clone.sizes); // false (they are different objects) user.sizes.width = 60; console.log(clone.sizes.width); // 50 (clone is unaffected) structuredClone() handles more than just objects. It can clone most data types, including arrays, primitive values, and supports circular references (where an object refers to itself).\nExample with Circular References:\nlet user = {}; user.me = user; // Circular reference let clone = structuredClone(user); console.log(clone.me === clone); // true (clone maintains circular reference) Limitations: structuredClone() cannot clone objects with functions, such as methods.\nstructuredClone({ f: function(){} }); // Error Summary Objects are stored and copied by reference, meaning variables point to the same object in memory. Primitives are copied by value, meaning variables hold independent copies of the value. Shallow copying (e.g., using Object.assign()) copies top-level properties, but nested objects are still referenced. Deep copying (e.g., using structuredClone()) creates independent copies of the object and all its nested properties. structuredClone() supports circular references but cannot clone functions. ","date":"2024-11-09","id":84,"permalink":"/personal-site/docs/java-script/js-language/4-objects/js-04.03-cloning-object/","summary":"\u003cp\u003e\u003cstrong\u003eobject references, cloning, and deep copying\u003c/strong\u003e in JavaScript.\u003c/p\u003e\n\u003ch2 id=\"objects-vs-primitives\"\u003e\u003cstrong\u003eObjects vs. Primitives\u003c/strong\u003e\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003ePrimitives\u003c/strong\u003e (like strings, numbers, booleans, etc.) are always copied \u003cstrong\u003eby value\u003c/strong\u003e. This means when a primitive variable is assigned to another, a \u003cstrong\u003ecopy\u003c/strong\u003e of the value is made.\u003c/p\u003e","tags":[],"title":"JS - 04.03 - Cloning Object"},{"content":"Object.keys(obj) Method Object.keys(obj) is a method that returns an array of the own enumerable property names (keys) of an object obj. This means it will list all the keys in the object, excluding any keys in the object\u0026rsquo;s prototype chain. let obj = { \u0026#34;a\u0026#34;: 1, \u0026#34;b\u0026#34;: 2 }; console.log(Object.keys(obj)); // [\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;] The object obj has two keys: \u0026quot;a\u0026quot; and \u0026quot;b\u0026quot;. The Object.keys(obj) method returns an array of those keys. Length of the Keys Array: The .length property of the array returned by Object.keys(obj) gives the number of keys (properties) in the object. If the object has no properties, the length will be 0. let emptyObj = {}; console.log(Object.keys(emptyObj).length); // 0 Usage in Code: Consider the following code:\nif (!Object.keys(obj).length) return null;\rRole of Object.keys() in the Code: Object.keys(obj) is used to get an array of the object\u0026rsquo;s own keys.\n.length checks how many keys the object has.\nif (!Object.keys(obj).length):\nThis condition checks if the object obj has no properties. If the object is empty (i.e., it has no own enumerable properties), Object.keys(obj).length will be 0, and the condition will be true. This check effectively verifies if the object is empty before proceeding with further logic. return null;:\nIf the object is empty, the function immediately returns null to avoid processing unnecessary operations for empty objects. [[2.2 modifying Practice#Create a tree from object|Question that uses this]]\nExample Use Case: This pattern is commonly used in scenarios where you need to create or process elements based on the properties of an object. For example, if you\u0026rsquo;re creating a DOM tree from an object and encounter an empty object, you might want to avoid creating any unnecessary DOM nodes.\nfunction createTree(obj) { // Check if the object is empty if (!Object.keys(obj).length) return null; // Return early if object has no properties let tree = document.createElement(\u0026#34;ul\u0026#34;); // Create list items for each property for (let key in obj) { let item = document.createElement(\u0026#34;li\u0026#34;); item.textContent = key; tree.appendChild(item); } return tree; }\rIn this example, if the obj passed to createTree() is empty, Object.keys(obj).length will be 0, and the function will return null, avoiding any DOM manipulation.\nSummary: Object.keys(obj) provides a convenient way to obtain all the keys of an object. You can check if an object is empty by checking if the length of the keys array is 0. This technique helps to optimize code by avoiding unnecessary processing or DOM manipulation for empty objects. Useful in various scenarios, like creating elements dynamically or processing data structures based on the presence of object keys.\n","date":"2024-11-09","id":85,"permalink":"/personal-site/docs/java-script/js-language/4-objects/js-04.04-object.keys/","summary":"\u003ch2 id=\"objectkeysobj-method\"\u003e\u003cstrong\u003e\u003ccode\u003eObject.keys(obj)\u003c/code\u003e Method\u003c/strong\u003e\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e\u003ccode\u003eObject.keys(obj)\u003c/code\u003e\u003c/strong\u003e is a method that returns an \u003cstrong\u003earray\u003c/strong\u003e of the \u003cstrong\u003eown enumerable property names (keys)\u003c/strong\u003e of an object \u003ccode\u003eobj\u003c/code\u003e.\u003c/li\u003e\n\u003cli\u003eThis means it will list all the keys in the object, excluding any keys in the object\u0026rsquo;s prototype chain.\u003c/li\u003e\n\u003c/ul\u003e\n\r\n\r\n\r\n\u003cdiv class=\"expressive-code\"\u003e\r\n  \u003cfigure class=\"frame not-content\"\u003e\r\n  \u003cfigcaption class=\"header\"\u003e\r\n    \u003cspan class=\"title\"\u003e\u003c/span\u003e\r\n  \u003c/figcaption\u003e\r\n  \u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-js\" data-lang=\"js\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"kd\"\u003elet\u003c/span\u003e \u003cspan class=\"nx\"\u003eobj\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e \u003cspan class=\"s2\"\u003e\u0026#34;a\u0026#34;\u003c/span\u003e\u003cspan class=\"o\"\u003e:\u003c/span\u003e \u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"s2\"\u003e\u0026#34;b\u0026#34;\u003c/span\u003e\u003cspan class=\"o\"\u003e:\u003c/span\u003e \u003cspan class=\"mi\"\u003e2\u003c/span\u003e \u003cspan class=\"p\"\u003e};\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"nx\"\u003econsole\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nx\"\u003elog\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"nb\"\u003eObject\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nx\"\u003ekeys\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"nx\"\u003eobj\u003c/span\u003e\u003cspan class=\"p\"\u003e));\u003c/span\u003e  \u003cspan class=\"c1\"\u003e// [\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;]\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\r\n  \u003c/figure\u003e\r\n\u003c/div\u003e\r\n\u003cul\u003e\n\u003cli\u003eThe object \u003ccode\u003eobj\u003c/code\u003e has two keys: \u003ccode\u003e\u0026quot;a\u0026quot;\u003c/code\u003e and \u003ccode\u003e\u0026quot;b\u0026quot;\u003c/code\u003e. The \u003ccode\u003eObject.keys(obj)\u003c/code\u003e method returns an array of those keys.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"length-of-the-keys-array\"\u003e\u003cstrong\u003eLength of the Keys Array\u003c/strong\u003e:\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eThe \u003ccode\u003e.length\u003c/code\u003e property of the array returned by \u003ccode\u003eObject.keys(obj)\u003c/code\u003e gives the number of keys (properties) in the object.\u003c/li\u003e\n\u003cli\u003eIf the object has no properties, the length will be \u003ccode\u003e0\u003c/code\u003e.\u003c/li\u003e\n\u003c/ul\u003e\n\r\n\r\n\r\n\u003cdiv class=\"expressive-code\"\u003e\r\n  \u003cfigure class=\"frame not-content\"\u003e\r\n  \u003cfigcaption class=\"header\"\u003e\r\n    \u003cspan class=\"title\"\u003e\u003c/span\u003e\r\n  \u003c/figcaption\u003e\r\n  \u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-js\" data-lang=\"js\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"kd\"\u003elet\u003c/span\u003e \u003cspan class=\"nx\"\u003eemptyObj\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"p\"\u003e{};\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"nx\"\u003econsole\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nx\"\u003elog\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"nb\"\u003eObject\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nx\"\u003ekeys\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"nx\"\u003eemptyObj\u003c/span\u003e\u003cspan class=\"p\"\u003e).\u003c/span\u003e\u003cspan class=\"nx\"\u003elength\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e  \u003cspan class=\"c1\"\u003e// 0\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\r\n  \u003c/figure\u003e\r\n\u003c/div\u003e\r\n\u003chr\u003e\n\u003ch2 id=\"usage-in-code\"\u003e\u003cstrong\u003eUsage in Code:\u003c/strong\u003e\u003c/h2\u003e\n\u003cp\u003eConsider the following code:\u003c/p\u003e","tags":[],"title":"JS - 04.04 - Object.keys()"},{"content":"Concepts of methods, this, and chaining in JavaScript:\nMethods Method: A method is a function that is a property of an object. Methods allow objects to \u0026ldquo;act\u0026rdquo; in a specific way by performing actions based on the object’s properties or behavior. let user = { name: \u0026#34;John\u0026#34;, sayHi: function() { alert(\u0026#34;Hello\u0026#34;); } }; user.sayHi(); // Hello sayHi is a method of the user object. When user.sayHi() is called, it alerts \u0026quot;Hello\u0026quot;.\nPre-Declaring a Function and Adding it as a Method:\nfunction sayHi() { alert(\u0026#34;Hello\u0026#34;); } let user = {}; user.sayHi = sayHi; user.sayHi(); // Hello Method Shorthand In ES6, there’s a shorthand for defining methods within an object literal. You can omit the function keyword and just use the method name followed by parentheses:\nlet user = { sayHi() { alert(\u0026#34;Hello\u0026#34;); } };\rThis is equivalent to the following, but shorter:\nlet user = { sayHi: function() { alert(\u0026#34;Hello\u0026#34;); } };\rthis in Methods The this keyword is commonly used inside methods to refer to the object the method belongs to.\nthis refers to the object that owns the method. In the following example, the sayHi method uses this.name to access the name property of the user object:\nlet user = { name: \u0026#34;John\u0026#34;, sayHi() { alert(this.name); // \u0026#34;this\u0026#34; refers to the user object } }; user.sayHi(); // John During execution, the value of this will be user. this refers to the user object, and this.name accesses the name property.\nthis is Not Bound (Dynamic) In JavaScript, the value of this is determined at runtime and depends on how the function is called, not where it is declared.\nThis means that if this is used in a method, its value can change based on the context of the call. Using this, it allows for same method definition to be used in multiple objects.\nlet user = { name: \u0026#34;John\u0026#34;, introduceSelf() { console.log(`Hi! I\u0026#39;m ${this.name}`); } }; user.introduceSelf(); // \u0026#34;Hi! I\u0026#39;m John\u0026#34; However, if you call the method in a different context, this will refer to the new context:\nlet introduce = user.introduceSelf; introduce(); // \u0026#34;Hi! I\u0026#39;m undefined\u0026#34; or throws an error in strict mode. In this case, this no longer refers to the user object because the function introduce was called without an object context.\nthis in Constructors You can use this to create methods inside a constructor function, which allows for object reuse across multiple instances:\nfunction Person(name) { this.name = name; this.introduceSelf = function() { console.log(`Hi! I\u0026#39;m ${this.name}`); }; } let person1 = new Person(\u0026#34;Chris\u0026#34;); let person2 = new Person(\u0026#34;Deepthi\u0026#34;); person1.introduceSelf(); // \u0026#34;Hi! I\u0026#39;m Chris\u0026#34; person2.introduceSelf(); // \u0026#34;Hi! I\u0026#39;m Deepthi\u0026#34; In this case, this.name and this.introduceSelf work because this refers to each specific instance of Person.\nArrow Functions and this [[3.2_arrow_function#Arrow function have no this.|Arrow functions have no \u0026rsquo;this\u0026rsquo;]] Unlike regular functions, arrow functions do not have their own this. They inherit this from the surrounding context (lexical scoping). This can lead to unexpected behavior when used in methods.\nlet user = { name: \u0026#34;John\u0026#34;, sayHi: () =\u0026gt; { alert(this.name); // `this` is not bound to user, it\u0026#39;s inherited from the surrounding scope } }; user.sayHi(); // undefined (or error in strict mode) In the example above, this in the arrow function is inherited from the global context (or undefined in strict mode), not from the user object.\nA Simple Calculator Object Here\u0026rsquo;s an example of how you can use methods and this to create a simple calculator object with read(), sum(), and multiply() methods:\nlet calculator = { read() { this.a = +prompt(\u0026#39;Give a?\u0026#39;, 0); this.b = +prompt(\u0026#39;Give b?\u0026#39;, 0); }, sum() { return this.a + this.b; }, multiply() { return this.a * this.b; } }; calculator.read(); // Prompt the user for inputs alert(calculator.sum()); // Show the sum alert(calculator.multiply()); // Show the product Method Explanation: read(): Prompts the user for two values and stores them as properties a and b of the calculator object. sum(): Returns the sum of a and b. multiply(): Returns the product of a and b. Method Chaining JavaScript allows for method chaining, where multiple method calls are linked together in a single line. For this to work, each method must return the object itself (this), so the next method can be called on it.\nHere\u0026rsquo;s an example using an object that represents a ladder:\nlet ladder = { step: 0, up() { this.step++; return this; // Return the object to enable chaining }, down() { this.step--; return this; // Return the object to enable chaining }, showStep() { alert(this.step); return this; // Return the object to enable chaining } }; // Chaining method calls ladder.up().up().down().showStep().down(); // step = 1 In the example:\nladder.up() increments the step. ladder.down() decrements the step. ladder.showStep() displays the current step. By returning this from each method, you can chain calls together. Summary: Methods: Functions that are properties of an object. this: Refers to the object that owns the method and allows access to its properties. Arrow Functions: Do not have their own this; they inherit it from the surrounding context. Chaining: Multiple method calls on the same object can be chained by returning this from each method. ","date":"2024-11-09","id":86,"permalink":"/personal-site/docs/java-script/js-language/4-objects/js-04.05-methods-this-chaining/","summary":"\u003cp\u003eConcepts of \u003cstrong\u003emethods\u003c/strong\u003e, \u003cstrong\u003e\u003ccode\u003ethis\u003c/code\u003e\u003c/strong\u003e, and \u003cstrong\u003echaining\u003c/strong\u003e in JavaScript:\u003c/p\u003e\n\u003chr\u003e\n\u003ch2 id=\"methods\"\u003e\u003cstrong\u003eMethods\u003c/strong\u003e\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eMethod\u003c/strong\u003e: A method is a function that is a property of an object. Methods allow objects to \u0026ldquo;act\u0026rdquo; in a specific way by performing actions based on the object’s properties or behavior.\u003c/li\u003e\n\u003c/ul\u003e\n\r\n\r\n\r\n\u003cdiv class=\"expressive-code\"\u003e\r\n  \u003cfigure class=\"frame not-content\"\u003e\r\n  \u003cfigcaption class=\"header\"\u003e\r\n    \u003cspan class=\"title\"\u003e\u003c/span\u003e\r\n  \u003c/figcaption\u003e\r\n  \u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-js\" data-lang=\"js\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"kd\"\u003elet\u003c/span\u003e \u003cspan class=\"nx\"\u003euser\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e  \u003cspan class=\"nx\"\u003ename\u003c/span\u003e\u003cspan class=\"o\"\u003e:\u003c/span\u003e \u003cspan class=\"s2\"\u003e\u0026#34;John\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e  \u003cspan class=\"nx\"\u003esayHi\u003c/span\u003e\u003cspan class=\"o\"\u003e:\u003c/span\u003e \u003cspan class=\"kd\"\u003efunction\u003c/span\u003e\u003cspan class=\"p\"\u003e()\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"nx\"\u003ealert\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"s2\"\u003e\u0026#34;Hello\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e  \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e};\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"nx\"\u003euser\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nx\"\u003esayHi\u003c/span\u003e\u003cspan class=\"p\"\u003e();\u003c/span\u003e \u003cspan class=\"c1\"\u003e// Hello\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\r\n  \u003c/figure\u003e\r\n\u003c/div\u003e\r\n\u003cp\u003e\u003ccode\u003esayHi\u003c/code\u003e is a method of the \u003ccode\u003euser\u003c/code\u003e object. When \u003ccode\u003euser.sayHi()\u003c/code\u003e is called, it alerts \u003ccode\u003e\u0026quot;Hello\u0026quot;\u003c/code\u003e.\u003c/p\u003e","tags":[],"title":"JS - 04.05 - Methods, this, Chaining"},{"content":"Constructor Functions and the new Operator Constructor functions are used to create multiple similar objects with the same properties and methods, without having to manually repeat the object structure each time.\nBy using a constructor function, you define the blueprint for creating objects, allowing you to instantiate them efficiently using the new operator.\nThe regular {...} syntax allows us to create one object.\nUsing constructor functions and the \u0026quot;new\u0026quot; operator, many similar objects, like multiple users or menu items can be made.\nConstructor Function Basics Naming Convention: Constructor functions should be named with an uppercase letter to distinguish them from regular functions. Usage with new: Constructor functions are meant to be invoked with the new operator. function User(name) { this.name = name; this.isAdmin = false; } // constructor function let person = new User(\u0026#34;Jack\u0026#34;); //constructor console.log(person.name); // \u0026#34;Jack\u0026#34; console.log(person.isAdmin); // false When new User(\u0026quot;Jack\u0026quot;) is called: A new object is created. The this keyword inside the constructor function refers to that new object. The constructor function runs, setting the properties and methods on the new object. The new object is returned. Creating Multiple Similar Objects A constructor function allows you to create multiple similar objects by defining the properties and methods that each object will share. For instance, you can create multiple users using the same constructor function.\nfunction User(name) { this.name = name; this.isAdmin = false; } let user1 = new User(\u0026#34;Jack\u0026#34;); let user2 = new User(\u0026#34;Anna\u0026#34;); console.log(user1.name); // \u0026#34;Jack\u0026#34; console.log(user2.name); // \u0026#34;Anna\u0026#34; In this case, user1 and user2 are separate objects with the same constructor (User), but they have different values for the name property.\nConstructor vs Regular Function for Object Creation Before the introduction of constructor functions, people would use regular functions to create objects manually:\nfunction createPerson(name) { const obj = {}; // create object obj.name = name; // add property obj.introduceSelf = function() { // add method console.log(`Hi! I\u0026#39;m ${this.name}`); }; return obj; } const frank = createPerson(\u0026#34;Frank\u0026#34;); frank.introduceSelf(); // \u0026#34;Hi! I\u0026#39;m Frank.\u0026#34; This approach works but is less efficient compared to using a constructor function. If multiple objects need the same introduceSelf method, it will be recreated each time an object is created. This can lead to inefficient memory usage.\nBenefits of Constructor Functions By using a constructor function, you can define methods that are shared by all instances, without having to recreate them for each individual object. Constructor functions allow you to define the shape of the object and instantiate multiple objects with the same properties and methods.\nfunction Person(name) { this.name = name; this.introduceSelf = function() { console.log(`Hi! I\u0026#39;m ${this.name}.`); }; } const frankie = new Person(\u0026#34;Frankie\u0026#34;); frankie.introduceSelf(); // \u0026#34;Hi! I\u0026#39;m Frankie.\u0026#34; Here, Person acts as a blueprint for creating new objects, each with their own name property and introduceSelf method.\nUnderstanding this in Constructors Inside a constructor function, the this keyword refers to the newly created object. You can use this to set properties and methods for that object.\nFor example:\nfunction Person(name) { this.name = name; this.introduceSelf = function() { console.log(`Hi! I\u0026#39;m ${this.name}.`); }; } const john = new Person(\u0026#34;John\u0026#34;); john.introduceSelf(); // \u0026#34;Hi! I\u0026#39;m John.\u0026#34; When new Person(\u0026quot;John\u0026quot;) is called, it creates a new object, and inside the constructor, this refers to that object. The properties and methods (name and introduceSelf) are assigned to that new object. Constructor for Accumulator Example Here’s an example of a constructor that uses a method to accumulate values:\nfunction Accumulator(startingValue) { this.value = startingValue; this.read = function() { this.value += +prompt(\u0026#39;How much to add?\u0026#39;, 0); }; } let accumulator = new Accumulator(1); accumulator.read(); alert(accumulator.value); // Displays the new accumulated value this.value is initialized to the startingValue. The read() method prompts the user for a value and adds it to this.value. Each time a new instance of Accumulator is created, the value property and read method are set on the object, allowing for different instances with their own accumulated values.\nObjects Are Everywhere JavaScript is an object-oriented language, and even primitive types like strings, numbers, and arrays are automatically wrapped in their respective object types. This allows them to have methods and properties associated with them.\nFor example, strings are objects, and they have methods like .split():\nlet myString = \u0026#34;apple,banana,orange\u0026#34;; let fruits = myString.split(\u0026#34;,\u0026#34;); console.log(fruits); // [\u0026#34;apple\u0026#34;, \u0026#34;banana\u0026#34;, \u0026#34;orange\u0026#34;] Here, myString is treated as a String object, and the .split() method is available because strings in JavaScript are instances of the String object.\nAdditional Features of Objects Optional Chaining (?.) The optional chaining operator (?.) allows you to access deeply nested properties of an object without worrying about whether intermediate properties exist. If any property in the chain is null or undefined, it safely returns undefined instead of throwing an error.\nExample:\nlet user = { name: \u0026#34;Alice\u0026#34;, address: { city: \u0026#34;New York\u0026#34; } }; console.log(user.address?.city); // \u0026#34;New York\u0026#34; console.log(user.contact?.phone); // undefined (doesn\u0026#39;t throw an error) Symbol Type as Property Key Symbol is a unique and immutable data type that can be used as a property key in objects. It is often used to create private object properties.\nconst sym = Symbol(\u0026#39;unique\u0026#39;); let obj = { [sym]: \u0026#39;value\u0026#39; }; console.log(obj[sym]); // \u0026#34;value\u0026#34; Each Symbol is unique, so even if two symbols have the same description, they will not be equal.\nObject to Primitive Conversion JavaScript allows objects to be converted into primitive values when needed. This is achieved via special methods like valueOf() and toString().\nExample:\nlet obj = { value: 5, valueOf() { return this.value; } }; console.log(obj + 1); // 6, `obj.valueOf()` is called valueOf() is used when an object needs to be converted to a number. toString() is used for string conversions. Optional Chaining \u0026lsquo;?\u0026rsquo; Feature to access properties without throwing error of it doesn\u0026rsquo;t exist. use when needed for \u0026rsquo;non existing user problem\u0026rsquo;\nSymbol type as property key\nObject to primitive conversion\nSummary Constructor Functions: Used to create multiple instances of similar objects. These functions define the properties and methods shared across all objects. this in Constructors: Refers to the newly created object inside a constructor, allowing you to set its properties and methods. Methods and Properties: By using constructors, you can define shared methods for all instances of the object. Additional Features: Optional chaining (?.), Symbols as property keys, and object-to-primitive conversion methods are important features when working with JavaScript objects. ","date":"2024-11-09","id":87,"permalink":"/personal-site/docs/java-script/js-language/4-objects/js-04.06-constructor-new/","summary":"\u003ch3 id=\"constructor-functions-and-the-new-operator\"\u003eConstructor Functions and the \u003ccode\u003enew\u003c/code\u003e Operator\u003c/h3\u003e\n\u003cp\u003eConstructor functions are used to create multiple similar objects with the same properties and methods, without having to manually repeat the object structure each time.\u003c/p\u003e","tags":[],"title":"JS - 04.06 - Constructor new"},{"content":"JavaScript arrays are a special type of object used to store ordered sequences of values. Unlike regular objects, which use named keys (like strings), arrays use numeric indexes.\nCreating Arrays 1. Empty Arrays You can create an empty array using either of these two methods:\nlet arr = new Array(); // Using the Array constructor let arr = []; // Using array literal (preferred) 2. Array with Values An array can be initialized with values inside square brackets ([]):\nlet listOfNumbers = [2, 3, 4, 5]; console.log(listOfNumbers[2]); // 4 (indexing starts from 0) console.log(listOfNumbers[2 - 1]); // 3 (same as listOfNumbers[1]) Array elements can be accessed using their index values. Arrays are zero-indexed. You can also use arithmetic expressions as indices.\nconst cars = [\u0026#34;Volvo\u0026#34;, \u0026#34;BMW\u0026#34;, \u0026#34;Tata\u0026#34;]; let car = cars[0]; // \u0026#34;Volvo\u0026#34; const cars = []; cars[0] = \u0026#34;Volvo\u0026#34;; cars[1] = \u0026#39;BMW\u0026#39;;\rAssociative Arrays in JavaScript Although arrays in JavaScript are indexed by numbers, you can technically assign a value to a string index.\nArrays with named indexes are called associative arrays or hashes, but JavaScript does not support arrays with named indexes, it always uses Numbered Index.\nIf named indexes are used, js converts array to an object. Then array methods and properties will produce incorrect result.\nExample of incorrect usage (for associative arrays):\nconst person = []; person[\u0026#34;first\u0026#34;] = \u0026#34;John\u0026#34;; person[\u0026#34;last\u0026#34;] = \u0026#34;Doe\u0026#34;; console.log(person.length); // 0 (wrong, since it\u0026#39;s an object now) console.log(person[\u0026#34;first\u0026#34;]); // \u0026#34;John\u0026#34; console.log(person[0]); // undefined If you need associative arrays, consider using an object instead.\nArrays of Objects, Arrays in Arrays, and Functions in Arrays Arrays in JavaScript can contain any type of data, including objects, functions, and even other arrays.\n1. Array of Objects You can store objects inside an array, which is a common pattern for structured data.\nlet journal = [ {event: [\u0026#34;work\u0026#34;, \u0026#34;touched tree\u0026#34;, \u0026#34;pizza\u0026#34;, \u0026#34;running\u0026#34;], squirrel: false}, {event: [\u0026#34;work\u0026#34;, \u0026#34;ice cream\u0026#34;, \u0026#34;lasagna\u0026#34;], squirrel: false}, {event: [\u0026#34;weekend\u0026#34;, \u0026#34;cycling\u0026#34;, \u0026#34;peanuts\u0026#34;], squirrel: true} ];\r2. Array of Functions You can also store functions within an array:\nlet functionsArray = [ function() { console.log(\u0026#34;Function 1\u0026#34;); }, function() { console.log(\u0026#34;Function 2\u0026#34;); }, function() { console.log(\u0026#34;Function 3\u0026#34;); } ];\r3. Arrays within Arrays Arrays can even contain other arrays, creating nested structures:\nlet arrayOfArrays = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ];\rlength Property The length property of an array returns the number of elements in the array. It’s important to note that length is not zero-based. When using [] the expression between the brackets are evaluated to get the property name.\nconst fruits = [\u0026#34;Banana\u0026#34;, \u0026#34;Orange\u0026#34;, \u0026#34;Mango\u0026#34;]; console.log(fruits.length); // 3 You can also use length to access the last element of an array:\nlet fruit = fruits[fruits.length - 1]; // \u0026#34;Mango\u0026#34; Looping Through Arrays 1. for Loop A traditional for loop is a common way to iterate through an array:\nfor (let i = 0; i \u0026lt; journal.length; i++) { let entry = journal[i]; console.log(entry); // Do something with each entry }\r2. for..of Loop The for..of loop is a simpler way to iterate over array elements. It gives you the value directly without needing the index.\nfor (let entry of journal) { console.log(`${entry.event.length} events.`); // logs the number of events }\r3. forEach() Method The forEach() method allows you to run a function for each item in the array:\narr.forEach(function(item, index, array) { // do something with item });\r[\u0026#34;Banana\u0026#34;, \u0026#34;Orange\u0026#34;, \u0026#34;Mango\u0026#34;].forEach(alert); // This will alert each fruit in the array const fruits = [\u0026#34;Bannana\u0026#34;, \u0026#34;Orange\u0026#34;, \u0026#34;Mango\u0026#34;]; fruits.forEach(alert);\r// making a list html item for each item const fruits = [\u0026#34;Bannana\u0026#34;, \u0026#34;Orange\u0026#34;, \u0026#34;Mango\u0026#34;]; function myFunction(value) { text += \u0026#34;\u0026lt;li\u0026gt;\u0026#34; + value + \u0026#34;\u0026lt;/li\u0026gt;\u0026#34;; } fruits.forEach(myFunction);\rYou can also access the current index and the full array within the callback function:\nfruits.forEach((item, index, array) =\u0026gt; { alert(`${item} is at index ${index} in ${array}`); });\rUsing Functions to Manipulate Array Data JavaScript provides several ways to work with arrays and manipulate their data.\n1. Function for Adding Entries to an Array If you want to simplify adding entries to an array of objects, you can use a function:\nlet journal = []; function addEntry(events, squirrel) { journal.push({events, squirrel}); } addEntry([\u0026#34;work\u0026#34;, \u0026#34;touched tree\u0026#34;, \u0026#34;pizza\u0026#34;, \u0026#34;running\u0026#34;], false); addEntry([\u0026#34;work\u0026#34;, \u0026#34;ice cream\u0026#34;, \u0026#34;lasagna\u0026#34;], false); addEntry([\u0026#34;weekend\u0026#34;, \u0026#34;cycling\u0026#34;, \u0026#34;peanuts\u0026#34;], true);\rThis is a shorthand for creating an object with properties named events and squirrel. Since the property names match the argument names, JavaScript will automatically assign them.\nSummary of Key Points Arrays in JavaScript are ordered lists of values, indexed by numbers. Arrays are not associative arrays (i.e., they cannot use string keys without being converted into objects). You can create arrays using both the array literal ([]) and the Array constructor (new Array()). Array properties and methods like length, forEach(), and push() are essential for manipulating data. JavaScript arrays can store different data types, including objects, functions, and even other arrays. Iterating through arrays can be done with for loops, for..of, and forEach() methods, each offering different levels of control and readability. ","date":"2024-11-09","id":88,"permalink":"/personal-site/docs/java-script/js-language/5-arrays/js-05.01-array/","summary":"\u003cp\u003eJavaScript arrays are a special type of object used to store ordered sequences of values.   Unlike regular objects, which use named keys (like strings), arrays use numeric indexes.\u003c/p\u003e","tags":[],"title":"JS - 05.01 - Array"},{"content":"","date":"2024-11-09","id":89,"permalink":"/personal-site/docs/java-script/js-language/5-arrays/","summary":"","tags":[],"title":"Arrays"},{"content":"Basic Array Methods Properties that contain functions are called methods of the value they belong to, as in .toUpperCase is a method of a string.\nlength // gives lengt of array at() // getting element with index // String to array with delimeted split() join() toString() // array to a comma seperated string concat() // new array including other arrays reverse() // reverses order of array // Add remove items // to remove and add to end pop() push() // to remove and ad to beginning shift() unshift()\tdelete() // makes things undefined // extracting parts of array slice() // make new subarray splice() // used to insert, remove, replace elements toSpliced() // searching in array indexOf() lastIndexOf() includes() find() findIndex() findLastIndex() copyWithin() // copy elements to other positions in array flat() flatMap() // flaten multidimensional array arr.length arr.at(pos) at() method returns an indexed element from an array. similar to [] but [] does not allow getting the last index using [-1], since [] is used for both objects and arrays, obj[-1] refers to key -1, not last property of object. at() was introduced to solve this problem.\nconst fruits = [\u0026#34;Bannana\u0026#34;, \u0026#34;Orange\u0026#34;, \u0026#34;Mango\u0026#34;]; let fruit = fruits.at(2); // Mango let fruit = fruits[2]; // Mango alert( fruits[-1] ); // error alert( fruits.at(-1) ); // Mango split and join str.split(delim) comma-delimited string of receivers: John, Pete, Mary To get an array of names from this string.\nsplit() splits the string into an array by the given delimiter delim.\nlet names = `John, Pete, Mary`; let arr = names.split(\u0026#39;, \u0026#39;); for (let name of arr) { alert( \u0026#39;A message to ${name}.\u0026#39;); }\rThe split method has an optional second numeric argument – a limit on the array length. If it is provided, then the extra elements are ignored.\nSplit into letters\nlet str = \u0026#39;test\u0026#39;; alert( str.split(\u0026#39;\u0026#39;) ); // t, e, s, t arr.join(glue) The call arr.join(glue) does the reverse to split. It creates a string of arr items joined by glue between them.\njoin() method allows joining all array elements into a string similar to toString but the separator can be assigned.\nconst arr = [\u0026#34;Bannana\u0026#34;, \u0026#34;Orange\u0026#34;, \u0026#34;Mango\u0026#34;]; let str = arr.join(\u0026#34; * \u0026#34;); // Bannana * Orange * Mango let str = arr.join(\u0026#39;;\u0026#39;); // glue the array into string using string using ; alert(str); // Bannana;Orange;Mango toString() Converting an Array to String of comma separated values. This is an automatic process when an outputting an array. All JavaScript objects have toString() method.\nconst fruits = [\u0026#34;Bannana\u0026#34;, \u0026#34;Orange\u0026#34;, \u0026#34;Mango\u0026#34;]; fruits.toString(); // Bannana,Orange,Mango alert(fruits) // same as above concat() arr.concat creates a new array that includes values from other arrays and additional items.\narr.cocat(arg1, arg2...)\raccepts any number of arguments - either arrays or values.\nUsed to create a new array by merging (concatenating) existing arrays and returns a new array without changing the old ones.\nconst myGirls = [\u0026#34;Cel\u0026#34;, \u0026#34;Lon\u0026#34;]; const myBoys = [\u0026#34;Em\u0026#34;, \u0026#34;Lin\u0026#34;]; const myPets = [\u0026#34;cat\u0026#34;, \u0026#39;Dog\u0026#39;]; const myChildren = myGirls.concat(myBoys); const family = myGirls.concat(myBoys, myPets); const myKids = myGirls.concat(\u0026#34;daisy\u0026#34;);\rIt can take strings also as arguments. Normally, it only copies elements from arrays. Other objects, even if they look like arrays, are added as a whole.\narr.reverse() The method arr.reverse reverses the order of elements in arr. It also returns the array after the reversal.\nlet arr = [1, 2, 3, 4, 5]; arr.reverse(); alert( arr ); // 5, 4, 3, 2, 1 Add / remove items push(...items) pop() The push method adds value to the end of an array, also returns new array length. The pop method removes the last value in the array and returns it. These are names used for stack data structure.\nlet sequence = [1, 2, 3]; sequence.push(4); sequence.push(\u0026#34;Banana\u0026#34;); console.log(sequence); // [1, 2, 3, 4, Banana] let length = sequence.push(\u0026#34;Mango\u0026#34;); // 6 console.log(sequence.pop()); // Mango let num = sequence.pop(); // Bannana sequence.pop();\runshift(...items) and shift() For adding and removing things at the start of an array. shift() method removes the first array element and shifts all other elements to a lower index. shift() returns the value that was shifted out.\nunshift() adds element to the beginning of an array and unshifts older elements. unshift() returns the new array length.\nconst fruits = [\u0026#34;Bannana\u0026#34;, \u0026#34;Orange\u0026#34;, \u0026#34;Mango\u0026#34;, \u0026#34;Kiwi\u0026#34;]; fruits.shift(); // removes Banana let fruit = fruits.shift(); // Orange fruits.unshift(\u0026#34;Lemon\u0026#34;); // adds lemon at front let num = fruits.unshift(\u0026#34;Lemon\u0026#34;); // 5 A To do list Managing a queue of stack\nlet todoList = []; function remember(task) { todoList.push(task); } function getTask() { return todoList.shift(); } function rememberUrgently(task) { todoList.unshift(task); }\rdelete() Using delete leaves undefined holes in the array. better to use pop or shift\nExtracting parts of array slice() arr.slice([start], [end])\rslice returns a new array copying to it all the elements from start to end (not including end but up to end). Doesn\u0026rsquo;t remove any element from original. makes a sub array. Both start and end can be negative, in that case position from the array end is assumed. When end index is not given, all elements after the start index is taken.\nconst fruits = [\u0026#34;Bannana\u0026#34;, \u0026#34;Orange\u0026#34;, \u0026#34;Lemon\u0026#34;, \u0026#34;Apple\u0026#34;, \u0026#34;Mango\u0026#34;] // copy from index 1 upto index 3, i.e 1,2 const citrus = fruits.slice(1,3); // [Orange, Lemon] // copy from index 2 till the end, including end const citrus = fruits.slice(2); // [Lemon, apple, mango] // copy from index 2 upto 4, 2,3 console.log([0, 1, 2, 3, 4].slice(2, 4)); // [2, 3] // copy from index 2 till end console.log([0, 1, 2, 3, 4].slice(2)); // [2, 3, 4] let arr = [ \u0026#34;t\u0026#34;, \u0026#34;e\u0026#34;, \u0026#34;s\u0026#34;, \u0026#34;t\u0026#34;] // copy from -2 till end aler( arr.slice(-2) ); // s, t alert( arr.slice(1, 3) ); // e, s splice() Used to Remove elements, Add new items to an array and Returns an array with deleted items (if any)\narr.splice(start[, deleteCount, elem1, ..., eleN])\rIt modifies arr starting from the index start: removes deleteCount elements and then inserts elem1, ..., elemN at their place. Returns the array of removed elements.\nUsing for deletion\nlet arr = [\u0026#34;I\u0026#34;, \u0026#34;study\u0026#34;, \u0026#34;JS\u0026#34;]; // from index 1 remove 1 element arr.splice(1, 1); alert( arr ); // [\u0026#34;I\u0026#34;, \u0026#34;JS\u0026#34;] Using for deletion and replacing\nlet arr = [\u0026#34;I\u0026#34;, \u0026#34;study\u0026#34;, \u0026#34;JS\u0026#34;, \u0026#34;right\u0026#34;, \u0026#34;Now\u0026#34;]; // remove starting from index 0, 3 elements and replace them with these arr.splice( 0, 3, \u0026#34;Let\u0026#39;s\u0026#34;, \u0026#34;Dance\u0026#34;); alert(arr) // [\u0026#34;Let\u0026#39;s\u0026#34;, \u0026#34;Dance\u0026#34;, \u0026#34;right\u0026#34;, \u0026#34;Now\u0026#34;] Returning Deleted Items\nlet arr = [\u0026#34;I\u0026#34;, \u0026#34;study\u0026#34;, \u0026#34;JS\u0026#34;, \u0026#34;right\u0026#34;, \u0026#34;Now\u0026#34;]; // remove starting from index 0, 2 elements. arr.splice( 0, 2); alert(arr) // [\u0026#34;I\u0026#34;, \u0026#34;study\u0026#34;] Inserting without removing elements\nlet arr = [\u0026#34;I\u0026#34;, \u0026#34;study\u0026#34;, \u0026#34;JS\u0026#34;, \u0026#34;right\u0026#34;, \u0026#34;Now\u0026#34;]; // starting from index 2, delete nothing, inser two elements there arr.splice(2, 0, \u0026#34;right\u0026#34;, \u0026#34;Now\u0026#34;) alert( arr); // [\u0026#34;I\u0026#34;, \u0026#34;study\u0026#34;, \u0026#34;JS\u0026#34;, \u0026#34;right\u0026#34;, \u0026#34;Now\u0026#34;] Negative index is allowed to count from the end\nlet arr = [1, 2, 5]; // from index -1 (onestep from the end), delete nothing, insert 3, 4 arr.splice(-1, 0, 3, 4); // [1,2,3,4,5] The first parameter defines the index in which the new element should be added (spliced). The second parameter defines how many elements should be removed. The rest of the parameters define the new elements to be added.\nconst fruits = [\u0026#34;Banana\u0026#34;, \u0026#34;Orange\u0026#34;, \u0026#34;Apple\u0026#34;, \u0026#34;Mango\u0026#34;]; // starting from index 2, remove nothing, add these two fruits.splice(2, 0, \u0026#34;Lemon\u0026#34;, \u0026#34;Kiwi\u0026#34;); // [\u0026#34;Banana\u0026#34;, \u0026#34;Orange\u0026#34;, \u0026#39;Lemon\u0026#39;, \u0026#39;kiwi\u0026#39; \u0026#34;Apple\u0026#34;, \u0026#34;Mango\u0026#34;] const fruits = [\u0026#34;Banana\u0026#34;, \u0026#34;Orange\u0026#34;, \u0026#34;Apple\u0026#34;, \u0026#34;Mango\u0026#34;]; // starting from index 2, remove 2, add these two fruits.splice(2, 2, \u0026#34;Lemon\u0026#34;, \u0026#34;kiwi\u0026#34;); // [Banana, Orange, Lemon, Kiwi] // removed items [apple, mango] finding range in place\n// iterate using for loop // if any one is true remove that one lement from that index // to avoid skipping an element as one element gets moved to left, move the pointer back function findInRange(arr, a, b) { for(let i =0; i\u0026lt;arr.length; i++) { if(arr[i] \u0026lt;a || arr[i] \u0026gt;b) { arr.splice(i, 1); i--; } } } // or do reverse looping using negative index function findRangeInPlace(arr, a, b) { for (let i = arr.length - 1; i \u0026gt;= 0; i--) { if (arr[i] \u0026lt; a || arr[i] \u0026gt; b) { arr.splice(i, 1); } } } let arr = [5, 3, 8, 1]; findRangeInPlace(arr, 1, 4); console.log(arr); // Output: [3, 1] arr.toSpliced() arr.splice(start[, deleteCount, elem1, ..., eleN])\rIs a safe way to splice an array without altering the original array. It creates a new array without changing the old one.\nconst fruits = [\u0026#34;Banana\u0026#34;, \u0026#34;Orange\u0026#34;, \u0026#34;Apple\u0026#34;, \u0026#34;Mango\u0026#34;]; const spliced = fruits.toSpliced (2,0,\u0026#34;Lemon\u0026#34;,\u0026#34;Kiwi\u0026#34;); // [\u0026#34;Banana\u0026#34;, \u0026#34;Orange\u0026#34;, \u0026#39;Lemon\u0026#39;, \u0026#39;kiwi\u0026#39; \u0026#34;Apple\u0026#34;, \u0026#34;Mango\u0026#34;] Searching in array indexOf() lastIndexOf() includes() Usually these methods are used with only one argument, the item to be found.\narr.indexOf(item, from)\rindexOf searches through the array for item starting from index from to end and returns the index at which the value was found. Otherwise -1 if not found.\nlastIndexOf searches from the end / right to left.\nconsole.log([1, 2, 3, 2, 1].indexOf(2)); // 1 console.log([1, 2, 3, 2, 1].lastIndexOf(2)); // 3 alert ( arr.indexOf(null) ); // -1 indexOf uses the strict equality === for comparison. So, if we look for false, it finds exactly false and not the zero.\nincludes() is preferred to check existence of item\narr.includes(item, from)\rsearches through the array for item starting from index from to end, and returns the true if found. It handles NaN properly.\nconst arr = [NaN]; alert( arr.indexOf(NaN) ); // -1 alert( arr.includes(NaN)); // true find() findIndex() findLastIndex() In an array of objects, to find an object with a specific condition.\nlet result = arr.find(function(item, index, array) { // if true is returned, item is returned and iteration is stopped // for falsy scenario returns undefined });\rlet users = [ {id:1, name: \u0026#34;John\u0026#34;}, {id:2, name: \u0026#34;Pete\u0026#34;}, {id:3, name: \u0026#34;John\u0026#34;}, ]; let user = users.find(item =\u0026gt; item.id == 1); alert(users.name); // John alert(users.findIndex(user =\u0026gt; user.name == \u0026#34;John\u0026#34;)); // 0 alert(users.findLastIndex(user =\u0026gt; user.name == \u0026#34;John\u0026#34;)); // 2 arr.findIndex() has the same syntax but returns the index where the element was found instead of the element itself. -1 if noting is found. arr.lastIndexOf() searches from right to left.\ncopyWithin() arr.copyWithin(target, start, end) – copies its elements from position start till position end into itself, at position target (overwrites existing).\narr.copyWithin(target, start, end)\rCopies array elements to another position in an array by overwriting the existing value.\ncopies its elements from position start till position end into itself, at position target (overwrites existing).\nIt cannot add items to an array so does not change the length of the array.\nconst fruits = [\u0026#34;Bannana\u0026#34;, \u0026#34;Orange\u0026#34;, \u0026#34;Mango\u0026#34;, \u0026#34;Kiwi\u0026#34;]; fruits.copyWithin(2,0); // copy to index[2], all elements from [0] // Bannana, Orange, Bannana, Orange fruits.copyWithin(2,0,2); //copy to index 2, the elements from 0 to 2 arr.flat(depth)/arr.flatMap(fn) create a new flat array from a multidimensional array.\nflat(depth) Creates a new flat array from a multidimensional array. The flat method creates a new array with sub-array elements concatenated to a specified depth.\nconst myArray = [ [1,2], [3,4], [5,6] ]; const newArray = myArray.flat(); // 1,2,3,4,5,6 flatMap(fn) it first maps all elements of an array and then creates a new array by flattening the array.\nconst myArray = [1,2,3,4,5,6]; const newArray = myArray.flatMap( x =\u0026gt; [x, x*10] ); // [1, 10, 2, 20, 3, 30, 4, 40, 5, 50, 6, 60] These methods are the most used ones, they cover 99% of use cases. But there are few others:\narr.some(fn) / arr.every(fn) check the array. The function fn is called on each element of the array similar to map. If any/all results are true, returns true, otherwise false.\nThese methods behave sort of like || and \u0026amp;\u0026amp; operators: if fn returns a truthy value, arr.some() immediately returns true and stops iterating over the rest of items; if fn returns a falsy value, arr.every() immediately returns false and stops iterating over the rest of items as well.\narr.fill(value, start, end) – fills the array with repeating value from index start to end.\nmanual.\n","date":"2024-11-09","id":90,"permalink":"/personal-site/docs/java-script/js-language/5-arrays/js-05.02-array-methods/","summary":"\u003ch1 id=\"basic-array-methods\"\u003eBasic Array Methods\u003c/h1\u003e\n\u003cp\u003eProperties that contain functions are called methods of the value they belong to,\nas in \u003ccode\u003e.toUpperCase\u003c/code\u003e is a method of a string.\u003c/p\u003e","tags":[],"title":"JS - 05.02 - Array Methods"},{"content":"filter() Method The filter() method is similar to map(), as it iterates over the array and applies a callback function on each item. However, instead of transforming the array elements, filter() returns a new array with only those elements for which the callback function returns true.\nThe callback function passed to filter() should return a boolean value (true or false). If true is returned, the element is included in the new array. If false is returned, the element is excluded from the new array. The method works without modifying the original array. This is a pure function, just like forEach(), as it does not alter the original data.\nlet results = arr.filter(function(item, index, array) { // returns true or false });\ritem: The current element being processed in the array. index: The index of the current element. array: The array filter() was called on. Example 1: Filter strings that start with \u0026ldquo;L\u0026rdquo; const cats = [\u0026#34;Lepord\u0026#34;, \u0026#34;Jaguar\u0026#34;, \u0026#34;Tiger\u0026#34;, \u0026#34;Lion\u0026#34;]; function lCat(cat) { return cat.startsWith(\u0026#34;L\u0026#34;); } const newList = cats.filter(lCat); console.log(newList); // [\u0026#34;Lepord\u0026#34;, \u0026#34;Lion\u0026#34;] Example 2: Filter out odd numbers const arr = [1, 2, 3, 4, 5]; function isOdd(num) { return num % 2 !== 0; } const oddNums = arr.filter(isOdd); console.log(oddNums); // [1, 3, 5] Example 3: Filter with a callback directly let users = [ {id: 1, name: \u0026#34;John\u0026#34;}, {id: 2, name: \u0026#34;Pete\u0026#34;}, {id: 3, name: \u0026#34;John\u0026#34;} ]; let someUser = users.filter(item =\u0026gt; item.id \u0026lt; 3); console.log(someUser.length); // 2 Example 4: Filter using an object method You can also use a method from an object to filter an array:\nlet army = { minAge: 18, maxAge: 27, canJoin(user) { return user.age \u0026gt;= this.minAge \u0026amp;\u0026amp; user.age \u0026lt; this.maxAge; } }; let users = [{age: 16}, {age: 20}, {age: 23}, {age: 30}]; let soldiers = users.filter(user =\u0026gt; army.canJoin(user)); alert(soldiers.length); // 2 alert(soldiers[0].age); // 20 alert(soldiers[1].age); // 23 You can also use filter() with a method like this:\nlet soldiers = users.filter(army.canJoin, army);\rExample 5: Filter values in a specified range You can filter values within a specific range using filter():\nfunction filterRange(arr, a, b) { return arr.filter(item =\u0026gt; item \u0026gt;= a \u0026amp;\u0026amp; item \u0026lt;= b); } let arr = [5, 3, 8, 1]; let filtered = filterRange(arr, 1, 4); console.log(filtered); // [3, 1] Key Points filter() returns a new array containing only elements that pass the test defined in the callback function. The original array remains unmodified. It is a pure function, meaning no side effects occur. You can use filter() to search for multiple matches in an array. If you need only the first matching element, use find() instead. ","date":"2024-11-09","id":91,"permalink":"/personal-site/docs/java-script/js-language/5-arrays/js-05.03-filter-method/","summary":"\u003ch3 id=\"filter-method\"\u003e\u003ccode\u003efilter()\u003c/code\u003e Method\u003c/h3\u003e\n\u003cp\u003eThe \u003ccode\u003efilter()\u003c/code\u003e method is similar to \u003ccode\u003emap()\u003c/code\u003e, as it iterates over the array and applies a callback function on each item. However, instead of transforming the array elements, \u003ccode\u003efilter()\u003c/code\u003e returns a \u003cstrong\u003enew array\u003c/strong\u003e with only those elements for which the callback function returns \u003ccode\u003etrue\u003c/code\u003e.\u003c/p\u003e","tags":[],"title":"JS - 05.03 - Filter Method"},{"content":"Transforming Arrays with map() The map() method allows you to transform an array by applying a callback function to each element. This method returns a new array where each element has been transformed based on the function provided, without modifying the original array.\nlet result = arr.map(function(item, index, array) { // returns the transformed value instead of item });\rmap() expects a callback as an argument, which means passing a function as a argument.\nitem: The current element being processed. index: The index of the current element. array: The array map() was called on. Example 1: Add 1 to each number in an array The map() method is commonly used when you need to transform an array by applying a function to each element. For instance, if we want to add 1 to each element of an array:\nconst arr = [1, 2, 3, 4, 5]; function addOne(num) { return num + 1; } const mappedArr = arr.map(addOne); console.log(mappedArr); // [2, 3, 4, 5, 6] Alternatively, you can use an inline arrow function:\nconst mappedArr = arr.map(num =\u0026gt; num + 1);\rThis creates a new array where each value has been incremented by 1, while the original array remains unchanged.\nExample 2: Map to lengths of strings You can also use map() to derive new data from an existing array. For example, if you want an array of string lengths:\nlet names = [\u0026#34;Bilbo\u0026#34;, \u0026#34;Gandalf\u0026#34;, \u0026#34;Nazgul\u0026#34;]; let lengths = names.map(item =\u0026gt; item.length); console.log(lengths); // [5, 7, 6] Here, map() iterates over the names array and returns the length of each string.\nExample 3: Transforming Strings to Uppercase The map() function can also be used to modify strings. For example, converting all the cat names to uppercase:\nconst cats = [\u0026#34;Leopard\u0026#34;, \u0026#34;Jaguar\u0026#34;, \u0026#34;Tiger\u0026#34;, \u0026#34;Lion\u0026#34;]; function toUpper(string) { return string.toUpperCase(); } const upperCats = cats.map(toUpper); console.log(upperCats); // [\u0026#34;LEOPARD\u0026#34;, \u0026#34;JAGUAR\u0026#34;, \u0026#34;TIGER\u0026#34;, \u0026#34;LION\u0026#34;] In this case, the toUpper() function is applied to each string in the cats array, returning a new array where all strings are capitalized.\nExample 4: Map to Names You can use map() to extract specific properties from objects in an array. For example, if you have an array of user objects and want to get an array of just the names:\nlet john = { name: \u0026#34;John\u0026#34;, age: 25}; let pete = { name: \u0026#34;Pete\u0026#34;, age: 30}; let mary = { name: \u0026#34;Mary\u0026#34;, age: 28}; let users = [john, pete, mary]; let names = users.map(user =\u0026gt; user.name); console.log(names); // [\u0026#34;John\u0026#34;, \u0026#34;Pete\u0026#34;, \u0026#34;Mary\u0026#34;] Example 5: Map to Objects with New Properties If you need to transform an array of objects into a new array with different properties, map() is useful. For example, you can combine a user\u0026rsquo;s name and surname into a fullName:\nlet john = { name: \u0026#34;John\u0026#34;, surname: \u0026#34;Smith\u0026#34;, id: 1}; let pete = { name: \u0026#34;Pete\u0026#34;, surname: \u0026#34;Hunt\u0026#34;, id: 2}; let mary = { name: \u0026#34;Mary\u0026#34;, surname: \u0026#34;Key\u0026#34;, id: 3}; let users = [john, pete, mary]; let usersMapped = users.map(user =\u0026gt; ({ fullName: `${user.name} ${user.surname}`, id: user.id })); console.log(usersMapped); // [ // { fullName: \u0026#34;John Smith\u0026#34;, id: 1 }, // { fullName: \u0026#34;Pete Hunt\u0026#34;, id: 2 }, // { fullName: \u0026#34;Mary Key\u0026#34;, id: 3 } // ] there are two arrow functions: without body value =\u0026gt; expr and with body value =\u0026gt; {...}. Here JavaScript would treat { as the start of function body, not the start of the object. The workaround is to wrap them in the “normal” brackets.\nlet usersMapped = users.map(user =\u0026gt; ({ fullName: `${user.name} ${user.surname}`, id: user.id }));\rExample 6: Convert Kebab-case to camelCase You can also use map() to apply transformations to strings, such as converting from kebab-case to camelCase:\nfunction camelCase(str) { return str.split(\u0026#39;-\u0026#39;) .map((word, index) =\u0026gt; index === 0 ? word : word[0].toUpperCase() + word.slice(1)) .join(\u0026#39;\u0026#39;); } console.log(camelCase(\u0026#34;background-color\u0026#34;)); // \u0026#34;backgroundColor\u0026#34; console.log(camelCase(\u0026#34;list-style-type\u0026#34;)); // \u0026#34;listStyleType\u0026#34; split('-'): Splits the string into an array of words based on the - delimiter. map(): Capitalizes the first letter of each word (except the first one), while keeping the rest of the word in lowercase. join(''): Joins the words back together to form a single string in camelCase. Key Points map() creates a new array and does not modify the original array. It transforms each element in the array according to the function passed to it. It is ideal for tasks like transforming values, extracting properties from objects, or creating new object structures. Unlike forEach(), map() always returns a new array, which can be assigned to a variable or used further in code. ","date":"2024-11-09","id":92,"permalink":"/personal-site/docs/java-script/js-language/5-arrays/js-05.04-map-method/","summary":"\u003ch3 id=\"transforming-arrays-with-map\"\u003eTransforming Arrays with \u003ccode\u003emap()\u003c/code\u003e\u003c/h3\u003e\n\u003cp\u003eThe \u003ccode\u003emap()\u003c/code\u003e method allows you to transform an array by applying a callback function to each element. This method returns a \u003cstrong\u003enew array\u003c/strong\u003e where each element has been transformed based on the function provided, without modifying the original array.\u003c/p\u003e","tags":[],"title":"JS - 05.04 - Map Method"},{"content":"reduce() Method The reduce() method is one of the most powerful and flexible array methods in JavaScript. It allows you to reduce an array to a single value by iterating over all elements and applying a function that combines each element with an accumulator (the result of previous calculations).\narr.reduce and arr.reduceRight\nlet value = arr.reduce(function(accumulator, currentItem, index, array) { // callback logic }, initialValue);\raccumulator: This is the cumulative value that is returned after each iteration. It’s the value that is built up as the loop progresses. currentItem: The current array item being processed. index (optional): The index of the current item. array (optional): The array reduce() was called on. initialValue: This is the value that accumulator will start with. If not provided, it defaults to the first element of the array. Basic Example: Summing an Array To sum all the elements in an array, we can use reduce():\nconst arr = [1, 2, 3, 4, 5]; let result = arr.reduce((sum, current) =\u0026gt; sum + current, 0); console.log(result); // 15 Here’s how it works:\nsum starts as the initialValue (0). current is each element of the array in turn. On each iteration, sum is updated by adding the current element. The final result after all iterations is 15. If we omit the initialValue:\nlet result = arr.reduce((sum, current) =\u0026gt; sum + current); console.log(result); // 15 In this case, the initialValue is set to the first element (1), and the sum begins from there.\nExample 2: Multiplying All Elements The reduce() method can also be used to perform a cumulative calculation, such as multiplying all the numbers in an array:\nconst arr = [1, 2, 3, 4, 5]; const product = arr.reduce((total, currentItem) =\u0026gt; total * currentItem, 1); console.log(product); // 120 The total starts at 1 (since multiplying by 1 has no effect). Each element of the array is multiplied by the accumulator (total), and the result accumulates through the iterations. Example 3: Creating a Keyed Object from an Array You can use reduce() to transform an array of objects into an object with a custom key. For example, turning an array of users into an object where the id is the key:\nlet users = [ {id: \u0026#34;john\u0026#34;, name: \u0026#34;John Smith\u0026#34;, age: 20}, {id: \u0026#34;ann\u0026#34;, name: \u0026#34;Ann Smith\u0026#34;, age: 24}, {id: \u0026#34;pete\u0026#34;, name: \u0026#34;Pete Peterson\u0026#34;, age: 31} ]; function groupById(array) { return array.reduce((obj, value) =\u0026gt; { obj[value.id] = value; return obj; }, {}); } // obj is accumilator with {} as starting value. // value are objects from the array. // value.id gives id value, to that the object is assigned. // all these are accumilated in {} a object let usersById = groupById(users); console.log(usersById); // { // \u0026#34;john\u0026#34;: {id: \u0026#34;john\u0026#34;, name: \u0026#34;John Smith\u0026#34;, age: 20}, // \u0026#34;ann\u0026#34;: {id: \u0026#34;ann\u0026#34;, name: \u0026#34;Ann Smith\u0026#34;, age: 24}, // \u0026#34;pete\u0026#34;: {id: \u0026#34;pete\u0026#34;, name: \u0026#34;Pete Peterson\u0026#34;, age: 31} // } obj is the accumulator, starting as an empty object {}. On each iteration, the id of each user is used as the key, and the user object is assigned to that key. Example 4: Getting the Average Age of Users We can also use reduce() to calculate the average of a property (e.g., age) in an array of objects:\nlet john = {id: \u0026#34;john\u0026#34;, name: \u0026#34;John Smith\u0026#34;, age: 25}; let ann = {id: \u0026#34;ann\u0026#34;, name: \u0026#34;Ann Smith\u0026#34;, age: 29}; let pete = {id: \u0026#34;pete\u0026#34;, name: \u0026#34;Pete Peterson\u0026#34;, age: 30}; let arr = [john, ann, pete]; function getAverageAge(users) { return users.reduce((acc, user) =\u0026gt; acc + user.age, 0) / users.length; } console.log(getAverageAge(arr)); // 28 acc starts at 0 and accumulates the sum of the age property of each user. After the loop, the total sum is divided by the length of the array (users.length) to compute the average. Example 5: Sum of Tripled Even Numbers You can chain reduce() with other array methods like map() and filter() to perform more complex transformations. For example, summing the tripled values of all even numbers:\nfunction sumOfTripledEvens(array) { return array .filter((num) =\u0026gt; num % 2 === 0) // filter out even numbers .map((num) =\u0026gt; num * 3) // multiply all by 3 .reduce((acc, curr) =\u0026gt; acc + curr); // get total sum } console.log(sumOfTripledEvens([1, 2, 3, 4, 5])); // 30 Here’s the breakdown:\nfilter(): Only even numbers are selected ([2, 4]). map(): Each even number is tripled ([6, 12]). reduce(): The tripled values are summed up (6 + 12 = 30). reduceRight() reduceRight() works similarly to reduce(), but it processes the array from right to left, instead of left to right. It’s useful when the direction of processing matters.\nconst arr = [1, 2, 3, 4, 5]; const result = arr.reduceRight((acc, current) =\u0026gt; acc - current, 0); console.log(result); // 3 In this case, reduceRight() starts from the last element of the array, subtracting each subsequent element from the accumulator.\nKey Points: reduce() reduces an array to a single value by iterating through all elements and accumulating the result. The first argument of the callback is the accumulator (cumulative result), and the second is the current item in the iteration. The initial value is optional; if not provided, it defaults to the first item of the array. Always specify the initial value when the array may be empty or when the calculation requires a specific starting point. reduceRight() is similar to reduce() but processes the array from right to left. ","date":"2024-11-09","id":93,"permalink":"/personal-site/docs/java-script/js-language/5-arrays/js-05.05-reduce-method/","summary":"\u003ch3 id=\"reduce-method\"\u003e\u003ccode\u003ereduce()\u003c/code\u003e Method\u003c/h3\u003e\n\u003cp\u003eThe \u003ccode\u003ereduce()\u003c/code\u003e method is one of the most powerful and flexible array methods in JavaScript. It allows you to \u003cstrong\u003ereduce\u003c/strong\u003e an array to a single value by iterating over all elements and applying a function that combines each element with an accumulator (the result of previous calculations).\u003c/p\u003e","tags":[],"title":"JS - 05.05 - Reduce Method"},{"content":"sort() Method The sort() method in JavaScript is used to sort the elements of an array in place, meaning it changes the original array, and also returns the sorted array. By default, it converts array elements to strings and sorts them lexicographically (i.e., alphabetically or numerically in string order).\nsort(fn) arr.sort()\nBasic Usage let arr = [1, 2, 15]; arr.sort(); alert(arr); // \u0026#34;1, 15, 2\u0026#34; In this example, the sort() method sorts the numbers as if they were strings, which is why 1 comes first, then 15, and finally 2. This may not give the expected numeric order.\nSorting with a Custom Comparator To sort the array in a specific numeric or lexicographical order, we can pass a comparison function to sort(). The function should take two parameters (a and b) and return:\nA negative number if a should appear before b. A positive number if a should appear after b. Zero if a and b are considered equal. The arr.sort(fn) method implements a generic sorting algorithm. An optimized quicksort or Timsort most of the time) It will walk the array, compare its elements using the provided function and reorder them, all we need is to provide the fn which does the comparison.\nHere’s an example of sorting numbers in ascending order:\nlet arr = [1, 2, 15]; arr.sort(function(a, b) { return a - b; }); alert(arr); // [1, 2, 15] This comparison function returns the difference a - b, which effectively sorts the numbers numerically.\nShorter Version (Using Arrow Function) arr.sort((a, b) =\u0026gt; a - b); // Sorts in ascending order alert(arr); // [1, 2, 15] For descending order, you can reverse the comparison:\narr.sort((a, b) =\u0026gt; b - a); // Sorts in descending order alert(arr); // [15, 2, 1] Sorting Strings When sorting an array of strings, JavaScript compares them lexicographically (alphabetical order):\nlet arr = [\u0026#39;Banana\u0026#39;, \u0026#39;Apple\u0026#39;, \u0026#39;Orange\u0026#39;]; arr.sort(); alert(arr); // [\u0026#34;Apple\u0026#34;, \u0026#34;Banana\u0026#34;, \u0026#34;Orange\u0026#34;] To sort strings in reverse order, just swap a and b in the comparison function:\narr.sort((a, b) =\u0026gt; b.localeCompare(a)); alert(arr); // [\u0026#34;Orange\u0026#34;, \u0026#34;Banana\u0026#34;, \u0026#34;Apple\u0026#34;] Copying and Sorting an Array If you need to sort an array but want to keep the original array intact, you can first make a copy of the array using slice() or the spread operator, and then apply sort():\nlet arr = [\u0026#34;HTML\u0026#34;, \u0026#34;JavaScript\u0026#34;, \u0026#34;CSS\u0026#34;]; let sorted = arr.slice().sort(); alert(sorted); // [\u0026#34;CSS\u0026#34;, \u0026#34;HTML\u0026#34;, \u0026#34;JavaScript\u0026#34;] alert(arr); // [\u0026#34;HTML\u0026#34;, \u0026#34;JavaScript\u0026#34;, \u0026#34;CSS\u0026#34;] (original array remains unchanged) Or using the spread operator:\nlet sorted = [...arr].sort();\rSorting Objects by a Property (e.g., Age) If you have an array of objects, and you want to sort by a specific property (e.g., age), you can pass a comparison function that compares the values of that property:\nlet john = {id: \u0026#34;john\u0026#34;, name: \u0026#34;John Smith\u0026#34;, age: 25}; let ann = {id: \u0026#34;ann\u0026#34;, name: \u0026#34;Ann Smith\u0026#34;, age: 29}; let pete = {id: \u0026#34;pete\u0026#34;, name: \u0026#34;Pete Peterson\u0026#34;, age: 30}; let arr = [john, pete, ann]; arr.sort((a, b) =\u0026gt; a.age - b.age); // Sort by age in ascending order alert(arr[0].name); // John Smith alert(arr[1].name); // Ann Smith alert(arr[2].name); // Pete Peterson To sort in descending order, reverse the comparison:\narr.sort((a, b) =\u0026gt; b.age - a.age); // Sort by age in descending order Shuffle an Array Shuffling is a way to randomly reorder the elements of an array. While you could use sort() with a random comparator to shuffle the array, this is not a perfect solution because sort() is not intended for randomness and can lead to non-uniform distributions.\nHere’s how to shuffle using a random comparison function (this is not fully random, but works for simple cases):\nlet arr = [1, 2, 3]; function shuffle(array) { array.sort(() =\u0026gt; Math.random() - 0.5); // Random comparator } shuffle(arr); alert(arr); // Randomly shuffled, e.g., [2, 1, 3] However, a much better approach is to use the Fisher-Yates shuffle algorithm, which is more reliable for shuffling: Fisher-Yates shuffle.\nfunction shuffle(array) { for (let i = array.length - 1; i \u0026gt; 0; i--) { let j = Math.floor(Math.random() * (i + 1)); // Random index between 0 and i [array[i], array[j]] = [array[j], array[i]]; // Swap elements } } let arr = [1, 2, 3]; shuffle(arr); alert(arr); // Array shuffled, e.g., [2, 1, 3] This method works by iterating over the array in reverse order and swapping each element with a randomly selected element from before it.\nSimulating Random Distribution If you want to test how well the Fisher-Yates shuffle distributes the results, you can run the shuffle multiple times and count the results:\nlet count = { \u0026#39;123\u0026#39;: 0, \u0026#39;132\u0026#39;: 0, \u0026#39;213\u0026#39;: 0, \u0026#39;231\u0026#39;: 0, \u0026#39;321\u0026#39;: 0, \u0026#39;312\u0026#39;: 0 }; for (let i = 0; i \u0026lt; 1000000; i++) { let array = [1, 2, 3]; shuffle(array); count[array.join(\u0026#39;\u0026#39;)]++; } for (let key in count) { alert(`${key}: ${count[key]}`); } // 123: 166693 // 132: 166647 // 213: 166628 // 231: 167517 // 312: 166199 // 321: 166316 This will give you an idea of how evenly the shuffle distributes the different possible permutations of the array [1, 2, 3].\nKey Points: sort() sorts arrays in place, meaning it modifies the original array. By default, sort() converts array elements to strings and sorts them lexicographically. To sort numerically, pass a comparison function to sort(). You can sort objects by properties (like age) by providing a custom comparator. Shuffling can be done using the Fisher-Yates shuffle for better randomness compared to using sort() with Math.random(). ","date":"2024-11-09","id":94,"permalink":"/personal-site/docs/java-script/js-language/5-arrays/js-05.06-sort-method/","summary":"\u003ch3 id=\"sort-method\"\u003e\u003ccode\u003esort()\u003c/code\u003e Method\u003c/h3\u003e\n\u003cp\u003eThe \u003ccode\u003esort()\u003c/code\u003e method in JavaScript is used to sort the elements of an array \u003cstrong\u003ein place\u003c/strong\u003e, meaning it changes the original array, and also returns the sorted array. By default, it converts array elements to strings and sorts them lexicographically (i.e., alphabetically or numerically in string order).\u003c/p\u003e","tags":[],"title":"JS - 05.06 - Sort Method"},{"content":"Rest Parameters (...) and Spread Syntax (...) In JavaScript, the rest parameters and spread syntax both use the ... syntax, but they serve different purposes.\nRest Parameters (...args) Rest parameters allow a function to accept an arbitrary number of arguments. When you use ... in the function\u0026rsquo;s parameter list, it collects all the remaining arguments into an array. This is helpful when you don\u0026rsquo;t know exactly how many arguments will be passed to a function.\nExample of Rest Parameters function sumAll(...args) { let sum = 0; for (let arg of args) { sum += arg; } return sum; } console.log(sumAll(1)); // 1 console.log(sumAll(1, 2, 3, 4)); // 10 console.log(sumAll(5, 10, 15, 20, 25)); // 75 The ...args syntax collects all arguments passed to sumAll into the args array. The function then iterates over the args array, summing the numbers. Rest Parameters with Other Parameters You can also combine regular parameters with rest parameters. The rest parameter must always be the last in the function\u0026rsquo;s argument list.\nfunction showName(first, last, ...titles) { console.log(first + \u0026#34; \u0026#34; + last); console.log(titles); // Titles as an array } showName(\u0026#34;Julius\u0026#34;, \u0026#34;Caesar\u0026#34;, \u0026#34;Consul\u0026#34;, \u0026#34;Imperator\u0026#34;); // Output: // Julius Caesar // [\u0026#34;Consul\u0026#34;, \u0026#34;Imperator\u0026#34;] first and last are regular parameters. ...titles collects the rest of the arguments into an array. function max(...numbers) { let result = -Infinity; for (let number of numbers) { if (number \u0026gt; result) result = number; } return result; } console.log(max(4, 1, 9, -2)); // 9 // using spread syntax in finction call let numbers = [5, 1, 7]; console.log(max(...numbers)); // 7 console.log(max(9, ...numbers, 2));\rSpread Syntax (...) Spread syntax, on the other hand, is used to expand an array or iterable object into individual elements. It \u0026ldquo;spreads\u0026rdquo; the elements of an array (or any iterable, like a string) into places where multiple arguments or elements are expected.\nExample of Spread Syntax in Function Calls A common use case is passing an array of arguments to a function that expects individual arguments. For example, Math.max expects multiple arguments, but if you have an array, you can use spread to pass the array elements as individual arguments.\n// function call, as function argument myFunction(a, ...iterableObj, b); // making an array, array literal [1, ...iterableObj, \u0026#39;4\u0026#39;, \u0026#39;five\u0026#39;, 6]; // making an object, object literal {...obj, key: \u0026#39;value\u0026#39;}\rlet arr = [3, 5, 1]; console.log(Math.max(...arr)); // 5 alert( Math.max(arr) ); // NaN Without spread syntax, Math.max(arr) would not work because Math.max expects individual arguments, not an array.\nPassing Multiple Iterables You can also use spread to pass multiple arrays (or iterables) to functions:\nlet arr1 = [1, -2, 3, 4]; let arr2 = [8, 3, -8, 1]; console.log(Math.max(...arr1, ...arr2)); // 8 alert( Math.max(1, 2, ...arr1, 25, 21, ...arr2) ); // 25 In this example, the spread operator ... is used to expand both arr1 and arr2 into individual arguments to Math.max.\nExample of Spread in Array Literals You can use spread syntax to merge arrays or create copies of arrays.\nlet arr1 = [1, 2, 3]; let arr2 = [4, 5, 6]; // Merging arrays let mergedArr = [...arr1, ...arr2]; console.log(mergedArr); // [1, 2, 3, 4, 5, 6] // Creating a copy of an array let copyArr = [...arr1]; console.log(copyArr); // [1, 2, 3] mergedArr contains elements from both arr1 and arr2. copyArr is a shallow copy of arr1. Example of Spread in Object Literals Spread syntax can also be used with objects to copy properties from one object to another or to merge objects.\nlet obj1 = {a: 1, b: 2}; let obj2 = {c: 3, d: 4}; let mergedObj = {...obj1, ...obj2}; console.log(mergedObj); // {a: 1, b: 2, c: 3, d: 4} let objCopy = {...obj1}; console.log(objCopy); // {a: 1, b: 2} mergedObj combines the properties of obj1 and obj2. objCopy is a shallow copy of obj1. If there are properties with the same key, the value from the later object will overwrite the earlier one:\nlet obj1 = {a: 1, b: 2}; let obj2 = {b: 3, c: 4}; let mergedObj = {...obj1, ...obj2}; console.log(mergedObj); // {a: 1, b: 3, c: 4} Differences Between Rest and Spread Syntax Feature Rest Parameters (...args) Spread Syntax (...) Usage Used in function parameters to collect arguments into an array. Used to expand an array or iterable into individual elements. Context Function parameters. Function calls, array literals, object literals. Behavior Gathers remaining arguments into an array. Expands an array or iterable into separate arguments or elements. Examples to Highlight Key Differences Rest Parameters in a Function function printAll(...args) { console.log(args); } printAll(1, 2, 3); // [1, 2, 3] Spread Syntax in a Function Call let numbers = [4, 5, 6]; console.log(Math.max(...numbers)); // 6 Merging Arrays with Spread let arr1 = [1, 2]; let arr2 = [3, 4]; let merged = [...arr1, ...arr2]; console.log(merged); // [1, 2, 3, 4] Copying an Object with Spread let obj = {name: \u0026#34;Alice\u0026#34;, age: 25}; let objCopy = {...obj}; console.log(objCopy); // {name: \u0026#34;Alice\u0026#34;, age: 25} Summary Rest Parameters (...args): Collect arguments into an array when defining a function. Spread Syntax (...): Expands an array or iterable into individual elements in function calls, array literals, or object literals. Spread syntax can be used when all elements from an object or array need to be included in a new array or object, or should be applied one-by-one in a function call\u0026rsquo;s arguments list.\nThere are three distinct places that accept the spread syntax:\nFunction arguments list (myFunction(a, ...iterableObj, b)) Array literals ([1, ...iterableObj, '4', 'five', 6]) Object literals ({ ...obj, key: 'value' }) ","date":"2024-11-09","id":95,"permalink":"/personal-site/docs/java-script/js-language/5-arrays/js-05.07-rest-spread/","summary":"\u003ch3 id=\"rest-parameters--and-spread-syntax-httpsjavascriptinforest-parameters-spread\"\u003e\u003ca href=\"https://javascript.info/rest-parameters-spread\"\u003eRest Parameters (\u003ccode\u003e...\u003c/code\u003e) and Spread Syntax (\u003ccode\u003e...\u003c/code\u003e)\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003eIn JavaScript, the \u003cstrong\u003erest parameters\u003c/strong\u003e and \u003cstrong\u003espread syntax\u003c/strong\u003e both use the \u003ccode\u003e...\u003c/code\u003e syntax, but they serve different purposes.\u003c/p\u003e","tags":[],"title":"JS - 05.07 - Rest \u0026 Spread"},{"content":"","date":"2024-10-22","id":96,"permalink":"/personal-site/docs/java-script-dom/","summary":"","tags":[],"title":"JavaScript DOM Manipulation"},{"content":"Manipulating DOM with JavaScript\nDocument Object Model (DOM) DOM Living Standard.\nThe DOM represents all page content that can be modified.\nThe document object is the main \u0026ldquo;entry point\u0026rdquo; to the page. We can change or create anything on the page using it.\ndocument.body.style.background = \u0026#34;red\u0026#34;; setTimeout( () =\u0026gt; document.body.style.background = \u0026#34;\u0026#34;, 1000); // change the style back after 1 second. \u0026#34;red\u0026#34; became \u0026#34;\u0026#34; The browser builds up a model of the HTML document\u0026rsquo;s structure and uses this model to draw the page on the screen. This representation of the document\u0026rsquo;s structure that can be read or modified. It is a live data structure: when it\u0026rsquo;s modified, the page on the screen is updated to reflect the changes.\nHTML is a set of boxes, For each box there is an object we can interact with to find out things such as what HTML tag it represents and which boxes and text it contains.\nThis representation is DOM.\nDOM is tree like representation of contents of a webpage - a tree of \u0026ldquo;nodes\u0026rdquo; of different relationships depending on how they are arranged in the HTML document.\nBrowser Object Model (BOM) The Browser Object Model (BOM) represents additional objects provided by the browser (host environment) for working with everything except the document.\nThe functions alert/confirm/prompt are also a part of the BOM: they are not directly related to the document, but represent pure browser methods for communicating with the user.\nThe BOM is a part of the general HTML specification.\nBrowser functions: setTimeout, alert, location and so on.\nnavigator.userAgent – about the current browser, and navigator.platform – about the platform (can help to differentiate between Windows/Linux/Mac etc).\nDOM tree In DOM every HTML tag is an object.\nNested tags are \u0026ldquo;children\u0026rdquo; of the enclosing one.\nThe text inside a tag is an object as well.\nThe DOM represents HTML as a tree structure of tags, every tree node is an object.\nTags are element nodes (or just elements) and for the tree structure.\n\u0026lt;html\u0026gt; is at the root, then \u0026lt;head\u0026gt; and \u0026lt;body\u0026gt; are its children.\nThe text inside elements form text nodes labeled as #text. It contains only string, it will not have children so always forms the leaf of the tree.\nThere are 12 node types. In practice we usually work with 4 of them:\ndocument – the “entry point” into DOM. element nodes – HTML-tags, the tree building blocks. text nodes – contain text. comments – sometimes we can put information there, it won’t be shown, but JS can read it from the DOM. ","date":"2024-11-09","id":97,"permalink":"/personal-site/docs/java-script-dom/1-dom-basics/js-dom-01.01-dom/","summary":"\u003cp\u003eManipulating DOM with JavaScript\u003c/p\u003e\n\u003ch3 id=\"document-object-model-dom\"\u003eDocument Object Model (DOM)\u003c/h3\u003e\n\u003cp\u003e\u003ca href=\"https://dom.spec.whatwg.org/\"\u003eDOM Living Standard\u003c/a\u003e.\u003cbr\u003e\nThe DOM represents all page content that can be modified.\u003cbr\u003e\nThe \u003ccode\u003edocument\u003c/code\u003e object is the main \u0026ldquo;entry point\u0026rdquo; to the page. We can change or create anything on the page using it.\u003c/p\u003e","tags":[],"title":"JS DOM - 01.01 - DOM"},{"content":"On top: documnetElement and body The topmost tree nodes are available directly as document properties:\n\u0026lt;body\u0026gt; = document.body\n\u0026lt;head\u0026gt; = document.head\nChildren: childNodes, firstChild, lastChild Child nodes are elements that are direct children. They are nested in the given one.\nDescendants are all the elements that are nested in the given one, including their children and so on.\nThe childNodes collection lists all child nodes, including text nodes.\n\u0026lt;script\u0026gt; for (let i=0; i \u0026lt; document.body.childNodes.length; i++) { alert( document.body.childNodes[i] ); } // Text, Div, Text, Ul, ... script firstChild and lastChild give fast access to the first and last child.\nelem.childNodes[0] === elem.firstChild elem.childNodes[ elem.childNodes.length - 1] === elem.lastChild\rDOM collections childNodes looks like an array, but the collection is an array-like iterable object.\nfor..of can be used to iterate over them. But array methods wont work.\nfor (let node of document.body.childNodes) { alert(node); // shows all nodes from collection }\rArray.from can be used create a real array from the collection if array methods are needed.\nalert( Array.from(document.body.childNodes).filter ); // function DOM collections are readable only, assignment doesn\u0026rsquo;t work.\nElement-only navigation Navigation properties listed above refer to all nodes. In childNodes we can see both text nodes, element nodes, and even comment nodes if they exist.\nBut for many tasks we don’t want text or comment nodes. We want to manipulate element nodes that represent tags and form the structure of the page.\nchildren – only those children that are element nodes. firstElementChild, lastElementChild – first and last element children. previousElementSibling, nextElementSibling – neighbor elements. parentElement – parent element. (same as parentNode) Replacing childNodes with children shows only elements.\n\u0026lt;script\u0026gt; for (let elem of document.body.children) { alert( document.body.childNodes[i] ); } // Div, Ul, Div ... script \u0026lt;/script\u0026gt;\rThere are two main sets of them:\nFor all nodes: parentNode, childNodes, firstChild, lastChild, previousSibling, nextSibling. For element nodes only: parentElement, children, firstElementChild, lastElementChild, previousElementSibling, nextElementSibling. Some types of DOM elements, e.g. tables, provide additional properties and collections to access their content.\n","date":"2024-11-09","id":98,"permalink":"/personal-site/docs/java-script-dom/1-dom-basics/js-dom-01.02-navigating-dom/","summary":"\u003ch4 id=\"on-top-documnetelement-and-body\"\u003eOn top: \u003ccode\u003edocumnetElement\u003c/code\u003e and body\u003c/h4\u003e\n\u003cp\u003eThe topmost tree nodes are available directly as \u003ccode\u003edocument\u003c/code\u003e properties:\u003cbr\u003e\n\u003ccode\u003e\u0026lt;body\u0026gt; = document.body\u003c/code\u003e\u003cbr\u003e\n\u003ccode\u003e\u0026lt;head\u0026gt; = document.head\u003c/code\u003e\u003c/p\u003e","tags":[],"title":"JS DOM - 01.02 - Navigating DOM"},{"content":"Adding text content and HTML content div.textContent = \u0026#34;Hello World!\u0026#34;; // creates a text node containing \u0026#34;hello world\u0026#34; and inserts it in div div.innerHTML = \u0026#34;\u0026lt;span\u0026gt;Hello World!\u0026lt;/span\u0026gt;\u0026#34;; // renders the HTML inside div It is preferred to using text content over inner html for adding text to avoid security risks.\ninnerHTML The innerHTML property allows to get the HTML inside the element as a string.\nWe can also modify it. So it’s one of the most powerful ways to change the page.\n\u0026lt;script\u0026gt; alert( documnet.body.innerHTML ); // read current content document.body.innerHTML = \u0026#39;The new body\u0026#39;; // replace it \u0026lt;/script\u0026gt;\rWe can append HTML to an element by using elem.innerHTML += \u0026quot;more html\u0026quot;\nwhat’s going on is not an addition, but a full overwrite.\nIn other words, innerHTML+= does this:\nThe old contents is removed. The new innerHTML is written instead (a concatenation of the old and the new one). As the content is “zeroed-out” and rewritten from the scratch, all images and other resources will be reloaded.\nouterHTML The outerHTML property contains the full HTML of the element. That’s like innerHTML plus the element itself.\n\u0026lt;script\u0026gt; alert( elem.outerHTML ); // \u0026lt;div id=\u0026#39;elem\u0026#39;\u0026gt; Hello \u0026lt;/div\u0026gt; \u0026lt;/script\u0026gt;\rwriting to outerHTML does not change the element. Instead, it replaces it in the DOM.\nThe outerHTML assignment does not modify the DOM element , but removes it from the DOM and inserts the new HTML in its place.\nSo what happened in div.outerHTML=... is:\ndiv was removed from the document. Another piece of HTML \u0026lt;p\u0026gt;A new element\u0026lt;/p\u0026gt; was inserted in its place. div still has its old value. The new HTML wasn’t saved to any variable. It’s so easy to make an error here: modify div.outerHTML and then continue to work with div as if it had the new content in it. But it doesn’t. Such thing is correct for innerHTML, but not for outerHTML.\ntextContent The textContent provides access to the text inside the element: only text, minus all \u0026lt;tags\u0026gt;\nWriting to textContent is much more useful, because it allows to write text the “safe way”.\nAn arbitrary string, for instance entered by a user, and want to show it.\nWith innerHTML we’ll have it inserted “as HTML”, with all HTML tags. With textContent we’ll have it inserted “as text”, all symbols are treated literally. \u0026lt;div id = \u0026#34;elem1\u0026#34; \u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div id = \u0026#34;elem2\u0026#34; \u0026gt;\u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; let name = prompt(\u0026#34;What\u0026#39;s your name?\u0026#34;, \u0026#34;\u0026lt;b\u0026gt;Winnie-the-Pooh!\u0026lt;/b\u0026gt;\u0026#34;); elem1.innerHTML = name; emel2.textContent = name; \u0026lt;/script\u0026gt;\rThe first \u0026lt;div\u0026gt; gets the name “as HTML”: all tags become tags, so we see the bold name. The second \u0026lt;div\u0026gt; gets the name “as text”, so we literally see \u0026lt;b\u0026gt;Winnie-the-Pooh!\u0026lt;/b\u0026gt;. In most cases, we expect the text from a user, and want to treat it as text. We don’t want unexpected HTML in our site. An assignment to textContent does exactly that.\nThe hidden property The “hidden” attribute and the DOM property specifies whether the element is visible or not.\n\u0026lt;div\u0026gt; Both divs below are hidden \u0026lt;/div\u0026gt; \u0026lt;div hidden\u0026gt;wit the attribute \u0026#34;hidden\u0026#34;\u0026lt;/div\u0026gt; \u0026lt;div id=\u0026#34;elem\u0026#34;\u0026gt;Javascript assigned property hidden\u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; elem.hidden = true; \u0026lt;/script\u0026gt;\rhidden works the same as style=\u0026quot;display:none\u0026quot;. But it’s shorter to write.\nHere’s a blinking element:\n\u0026lt;div id=\u0026#34;elem\u0026#34;\u0026gt;A blinking element\u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; setInterval( () =\u0026gt; elem.hidden = !elem.hidden, 1000); \u0026lt;/script\u0026gt;\rMore properties DOM elements also have additional properties, in particular those that depend on the class:\nvalue – the value for \u0026lt;input\u0026gt;, \u0026lt;select\u0026gt; and \u0026lt;textarea\u0026gt; (HTMLInputElement, HTMLSelectElement…). href – the “href” for \u0026lt;a href=\u0026quot;...\u0026quot;\u0026gt; (HTMLAnchorElement). id – the value of “id” attribute, for all elements (HTMLElement). \u0026lt;input type=\u0026#34;text\u0026#34; id=\u0026#34;elem\u0026#34; value=\u0026#34;value\u0026#34;\u0026gt; \u0026lt;script\u0026gt; alert( elem.type); // text alert( elem.id); // elem alert( elem.value); // value \u0026lt;/script\u0026gt;\r","date":"2024-11-09","id":99,"permalink":"/personal-site/docs/java-script-dom/1-dom-basics/js-dom-01.03-text-and-html-content/","summary":"\u003ch4 id=\"adding-text-content-and-html-content\"\u003eAdding text content and HTML content\u003c/h4\u003e\n\r\n\r\n\r\n\u003cdiv class=\"expressive-code\"\u003e\r\n  \u003cfigure class=\"frame not-content\"\u003e\r\n  \u003cfigcaption class=\"header\"\u003e\r\n    \u003cspan class=\"title\"\u003e\u003c/span\u003e\r\n  \u003c/figcaption\u003e\r\n  \u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-js\" data-lang=\"js\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"nx\"\u003ediv\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nx\"\u003etextContent\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"s2\"\u003e\u0026#34;Hello World!\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e// creates a text node containing \u0026#34;hello world\u0026#34; and inserts it in div\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"nx\"\u003ediv\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nx\"\u003einnerHTML\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"s2\"\u003e\u0026#34;\u0026lt;span\u0026gt;Hello World!\u0026lt;/span\u0026gt;\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e// renders the HTML inside div\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\r\n  \u003c/figure\u003e\r\n\u003c/div\u003e\r\n\u003cp\u003eIt is preferred to using text content over inner html for adding text to avoid security risks.\u003c/p\u003e","tags":[],"title":"JS DOM - 01.03 - Text and Html Content"},{"content":"document.getElementById If an element has the id attribute, we can get the element using the method document.getElementById(id), no matter where it is.\n\u0026lt;script\u0026gt; let elem = document.getElementById(\u0026#39;elem\u0026#39;); elem.style.background = \u0026#34;red\u0026#34;; \u0026lt;/script\u0026gt;\rThe method getElementById can be called on document object. It looks for the given id in the whole document.\nquerySelectorAll By far, the most versatile method, elem.querySelectorAll(css) returns all elements inside elem matching the given CSS selector.\nelement.querySelectorAll(selectors) // returns \u0026#39;NodeList\u0026#39; containing references to all matches of the \u0026#39;selector\u0026#39; NodeList is not an Array even though it looks like an array it has several array methods missing from it.\nIt can be converted to an Array using Array.from() or spread operator\n\u0026lt;ul\u0026gt; \u0026lt;li\u0026gt;The\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;test\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;li\u0026gt;has\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;passed\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt;\rlet elements = document.querySelectorAll(\u0026#39;ul \u0026gt; li:last-child\u0026#39;); for (let elem of elements) { alert(elem.innerHTML); // test, passed }\rPseudo-classes in the CSS selector like :hover and :active are also supported.\ndocument.querySelectorAll(':hover') will return the collection with elements that the pointer is over now (in nesting order: from the outermost \u0026lt;html\u0026gt; to the most nested one).\nquerySelector(selector) elem.querySelector(css selector) returns the first element for the given CSS selector.\nelement.querySelector(selector) // returns a reference to the first match of \u0026#39;selector\u0026#39; The result is the same as elem.querySelectorAll(css)[0], but the latter is looking for all elements and picking one, while elem.querySelector just looks for one. So it’s faster and also shorter to write.\nelem.matches The elem.matches(css) does not look for anything, it merely checks if elem matches the given CSS-selector. It returns true or false.\nelements / tags \u0026ldquo;element\u0026rdquo; nodes are primarily used for manipulating the DOM\n\u0026lt;div id = \u0026#34;container\u0026#34;\u0026gt; \u0026lt;div class = \u0026#34;display\u0026#34;\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class = \u0026#34;controls\u0026#34;\u0026gt; \u0026lt;/div\u0026gt;\t\u0026lt;/div\u0026gt;\rHere there is a parent and its children which are on the next level, each on their own branch.\nTargeting nodes with selectors When working with DOM, \u0026lsquo;selectors\u0026rsquo; are used to target the nodes to be worked on.\nUsing CSS style selectors to target the \u0026lt;div class = \u0026quot;display\u0026quot;\u0026gt; \u0026lt;/div\u0026gt;:\n/* CSS selectors */ .display div.display #container \u0026gt; .display div#container \u0026gt; div.display\rUsing relational selectors (i.e firstElementChild or lastElementChild) with special properties owned by the nodes.\nIdentifying a certain node based on its relationship to the nodes around it.\n// selects the #container div const container = document.querySelector(\u0026#34;#container\u0026#34;); // selects the first child of #container i.e .display console.dir(container.firstElementChild); // selects the .controls div const controls = document.querrySelector(\u0026#34;.controls\u0026#34;); // selects the prior sibling of control i.e .display console.dir(controls.previousElementSibling);\r","date":"2024-11-09","id":100,"permalink":"/personal-site/docs/java-script-dom/1-dom-basics/js-dom-01.04-selectors/","summary":"\u003ch3 id=\"documentgetelementbyid\"\u003edocument.getElementById\u003c/h3\u003e\n\u003cp\u003eIf an element has the \u003ccode\u003eid\u003c/code\u003e attribute, we can get the element using the method \u003ccode\u003edocument.getElementById(id)\u003c/code\u003e, no matter where it is.\u003c/p\u003e","tags":[],"title":"JS DOM - 01.04 - Selectors"},{"content":"When the browser loads the page, it “parses” the HTML and generates DOM objects from it. For element nodes, most standard HTML attributes automatically become properties of DOM objects.\nFor instance, if the tag is \u0026lt;body id=\u0026quot;page\u0026quot;\u0026gt;, then the DOM object has body.id = \u0026quot;page\u0026quot;.\nAttributes – is what’s written in HTML. Properties – is what’s in DOM objects. DOM properties document.body,myData = { name: \u0026#39;ceasar\u0026#39;, title: \u0026#39;imperator\u0026#39; }; alert(document.body.myData.title); // imperator Methods can be added\ndocument.body.sayTagName = function() { alert(this.tagName); }; document.body.sayTagName(); // Body So, DOM properties and methods behave just like those of regular JavaScript objects:\nThey can have any value. They are case-sensitive (write elem.nodeType, not elem.NoDeTyPe) HTML attributes In HTML, tags may have attributes.\nWhen the browser parses the HTML to create DOM objects for tags, it recognizes standard attributes in HTML and creates DOM properties from them.\nSo when an element has id or another standard attribute, the corresponding property gets created. But that doesn’t happen if the attribute is non-standard.\nA standard attribute for one element can be unknown for another one. For instance, \u0026quot;type\u0026quot; is standard for \u0026lt;input\u0026gt;, but not for \u0026lt;body\u0026gt;\nAll attributes are accessible by using the following methods:\nelem.attributes - a collection of objects that belongs to `attr` class with `name` and `value` properties. (is iterable) elem.hasAttribute(name) // checks for existence. elem.getAttribute(name) // gets the value. elem.setAttribute(name, value) // sets the value. elem.removeAttribute(name) // removes the attribute. [[2.3 class, attributes#Editing HTML attributes|Editing Attributes]]\nHTML attributes have the following features:\nTheir name is case-insensitive (id is same as ID). Anything can be assigned, Their values are always strings. \u0026lt;body id=\u0026#34;test\u0026#34; something=\u0026#34;non-standard\u0026#34;\u0026gt; \u0026lt;script\u0026gt; alert(document.body.ID); // test case insensitve alert(document.body.something); // undefined alert(document.body.getAttribute(\u0026#39;something\u0026#39;)); // non-standard \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;elem\u0026#34; about=\u0026#34;Elephant\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; alert( elem.getAttribute(\u0026#39;About\u0026#39;) ); // Elephant case insensitve elem.setAttribute(\u0026#39;Test\u0026#39;, 123); // 123 becomes a string alert( elem.outerHTML ); // checking added attribute for(let attr of elem.attributes ) { alert( `${attr.name} = ${atr.value}` ); } \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt;\rProperty-attribute synchronization DOM properties are typed DOM properties are not always strings.\ninput.checked property of check boxes is a boolean.\nstyle attribute is a string in HTML, but the style property is an object.\n","date":"2024-11-09","id":101,"permalink":"/personal-site/docs/java-script-dom/1-dom-basics/js-dom-01.05-attributes-properties/","summary":"\u003cp\u003eWhen the browser loads the page, it “parses” the HTML and generates DOM objects from it. For element nodes, most standard HTML attributes automatically become properties of DOM objects.\u003c/p\u003e","tags":[],"title":"JS DOM - 01.05 - Attributes Properties"},{"content":"","date":"2024-10-22","id":102,"permalink":"/personal-site/docs/html-css/html/","summary":"","tags":[],"title":"HTML"},{"content":"","date":"2024-10-22","id":103,"permalink":"/personal-site/docs/html-css/","summary":"","tags":[],"title":"HTML \u0026 CSS"},{"content":"HTML (HyperText Markup Language) defines the structure and content of webpages. We use HTML elements to create all the paragraphs, headings, lists, images, and links that make up a typical webpage.\nElements and Tags All elements of HTML are wrapped in opening and closing HTML tags.\n\u0026lt;p\u0026gt;: Opening tag (angle brackets with keyword) marks the beginning. \u0026lt;/p\u0026gt;: Closing tag shows the element\u0026rsquo;s end, has a forward slash before the keyword. \u0026lt;p\u0026gt;paragraph text\u0026lt;/p\u0026gt;\rCatalog of Tags [[Catalog of Tags]]\nElements are containers for content, with the tags indicating what content the element contains. Using the correct element for content is referred to as semantic HTML.\nVoid Elements Void elements do not have any content, so they have a single tag:\n\u0026lt;meta\u0026gt; \u0026lt;link\u0026gt; \u0026lt;br\u0026gt; \u0026lt;img\u0026gt; Previously, these were called self-closing tags (e.g., \u0026lt;br /\u0026gt;, \u0026lt;img /\u0026gt;), but it is no longer necessary to close them this way in HTML5.\nHTML File An HTML file containing the homepage of the website should be named index.html because servers will look for that by default.\nHTML Boilerplate All HTML documents need the same basic structure or boilerplate that should be in place before anything useful can be done.\n1. Doctype Every HTML page starts with a Doctype declaration which tells the browser what version of HTML to use for rendering the document. The latest version is HTML5, and its Doctype is:\n\u0026lt;!DOCTYPE html\u0026gt;\rThis should be the first line of the file.\n2. HTML Element \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;!-- lang attribute specifies the language of the document --\u0026gt; \u0026lt;/html\u0026gt;\rThe \u0026lt;html\u0026gt; element is the root element of the document, meaning every other element will be its descendant. \u0026lt;html lang=\u0026quot;en\u0026quot;\u0026gt; lang is html attribute giving additional info like language.\n3. Head Element The \u0026lt;head\u0026gt; element contains important meta-information to help render the document correctly in the browser. There should be no elements that display content within \u0026lt;head\u0026gt;.\n3.1 Meta Elements \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;!-- Character encoding for the document --\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt; \u0026lt;!-- Controls layout on mobile browsers --\u0026gt; \u0026lt;/head\u0026gt;\r\u0026lt;meta charset=\u0026quot;UTF-8\u0026quot;\u0026gt;: Ensures that different symbols are displayed correctly. \u0026lt;meta name=\u0026quot;viewport\u0026quot;\u0026gt;: Specifies the tag is related to viewport settings. content=\u0026quot;width=device-width, initial-scale=1.0\u0026quot;: Sets the width of the viewport to match the device\u0026rsquo;s width and the initial zoom level to 1.0. This sets the width of the viewport to match the device\u0026rsquo;s width. and sets the initial zoom level when the page is first loaded. A scale of 1.0 means that the page will be displayed at its natural size without any zooming in or out. There are other \u0026lt;meta\u0026gt; tags available for defining how the webpage behaves when shared on the web, among other functions.\n3.2 Title Element The \u0026lt;title\u0026gt; element gives the webpage a human-readable title that is displayed in the browser\u0026rsquo;s tab.\nWithout a \u0026lt;title\u0026gt;, the browser defaults to the file name, e.g., index.html.\n\u0026lt;head\u0026gt; \u0026lt;title\u0026gt;My Webpage\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt;\r3.3 Link Element The \u0026lt;link\u0026gt; element is used to link external stylesheets.\n\u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;style.css\u0026#34;\u0026gt; \u0026lt;!-- Linking an external CSS file --\u0026gt;\rrel: Specifies the relationship between the current document and the linked resource. href: Specifies the location of the linked resource. 4. Body Element The \u0026lt;body\u0026gt; element contains all the content that will be displayed to users, including text, images, lists, links, etc.\n\u0026lt;body\u0026gt; \u0026lt;h1\u0026gt;Line to be displayed\u0026lt;/h1\u0026gt; \u0026lt;/body\u0026gt;\rComplete HTML Boilerplate Example \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt; \u0026lt;title\u0026gt;My Webpage\u0026lt;/title\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;style.css\u0026#34;\u0026gt; \u0026lt;!-- Linking CSS --\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1\u0026gt;Line to be displayed\u0026lt;/h1\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt;\rVSCode Boilerplate Shortcut In a .html file, enter ! in an empty index.html file and select the first option to generate the full boilerplate code.\nOpening the File Drag and drop into the browser\u0026rsquo;s address bar or double-click the file. In the directory containing the file, you can open it with google-chrome index.html. Use the Live Server extension of VSCode for live preview. ","date":"2024-11-04","id":104,"permalink":"/personal-site/docs/html-css/html/html-01-boiler-plate/","summary":"\u003cp\u003e\u003cstrong\u003eHTML (HyperText Markup Language)\u003c/strong\u003e defines the structure and content of webpages. We use HTML elements to create all the paragraphs, headings, lists, images, and links that make up a typical webpage.\u003c/p\u003e","tags":[],"title":"HTML - 01 - Boiler Plate"},{"content":"Paragraphs \u0026lt;p\u0026gt; \u0026lt;/p\u0026gt; All text can be placed inside the \u0026lt;body\u0026gt;, but spaces will not be considered without using paragraph tags. The \u0026lt;p\u0026gt; tag can be used to create distinct paragraphs.\nHeadings \u0026lt;h1\u0026gt; \u0026lt;/h1\u0026gt; Headings are larger and bolder texts, with six levels of headings available from \u0026lt;h1\u0026gt; (most important) to \u0026lt;h6\u0026gt; (least important).\nStrong \u0026lt;strong\u0026gt; \u0026lt;/strong\u0026gt; The \u0026lt;strong\u0026gt; tag indicates the importance, seriousness, or urgency of a word or section of content, without altering its original meaning.\nEmphasis \u0026lt;em\u0026gt; \u0026lt;/em\u0026gt; The \u0026lt;em\u0026gt; tag places stress on a piece of content in a way that changes its meaning, often indicating verbal stress.\nItalic \u0026lt;i\u0026gt; \u0026lt;/i\u0026gt; The \u0026lt;i\u0026gt; tag is used to convey a different mood or voice from the surrounding content. It’s often applied to foreign words, idiomatic phrases, technical terms, ship names, or thoughts.\nBold \u0026lt;b\u0026gt; \u0026lt;/b\u0026gt; The \u0026lt;b\u0026gt; tag draws attention to a word or section of content for utilitarian purposes, without conveying additional importance or emphasis. It is the least semantic of the tags discussed.\nSmall \u0026lt;small\u0026gt; \u0026lt;/small\u0026gt; The \u0026lt;small\u0026gt; tag defines smaller text, typically for side comments or fine print.\nHighlight/Mark \u0026lt;mark\u0026gt; \u0026lt;/mark\u0026gt; The \u0026lt;mark\u0026gt; tag highlights text for reference or importance.\nStrike Out/Delete \u0026lt;del\u0026gt; \u0026lt;/del\u0026gt; The \u0026lt;del\u0026gt; tag represents content that has been deleted, often rendered with a strikethrough.\nInsert \u0026lt;ins\u0026gt; \u0026lt;/ins\u0026gt; The \u0026lt;ins\u0026gt; tag shows newly inserted content, typically underlined. After deletion other word can be shown as inserted, which is represented by underline.\nSubscript \u0026lt;sub\u0026gt; \u0026lt;/sub\u0026gt; The \u0026lt;sub\u0026gt; tag denotes text that appears half the size and at a lower position, similar to mathematical or chemical formulas.\nSuperscript \u0026lt;sup\u0026gt; \u0026lt;/sup\u0026gt; The \u0026lt;sup\u0026gt; tag displays text that appears half a character above the normal line and in a smaller font, useful for footnotes or exponentiation.\nNesting and Indentation Nesting is used to show parent, child, and sibling tag relationships. Indentation makes these relationships easier to see.\nHTML Comments \u0026lt;!-- text --\u0026gt; To comment out lines in VSCode, use the shortcut Ctrl + / to convert any line into a comment or revert it.\nLists Unordered Lists \u0026lt;ul\u0026gt; \u0026lt;li\u0026gt; \u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; Used when the order of items doesn’t matter. Each item in the list is represented by \u0026lt;li\u0026gt;, which will typically be displayed as a bullet point (circle, square, or dot). The style is defined by CSS with the list-style-type property.\nOrdered Lists \u0026lt;ol\u0026gt; \u0026lt;li\u0026gt; \u0026lt;/li\u0026gt; \u0026lt;/ol\u0026gt; For creating lists where the order and numbering are important. By default, \u0026lt;ol\u0026gt; assigns numbers to each list item.\nBoth unordered and ordered lists can be nested inside one another as needed. If a second list needs to be nested inside a list item, it should be placed within its \u0026lt;li\u0026gt; \u0026lt;/li\u0026gt;.\n\u0026lt;ul\u0026gt; \u0026lt;li\u0026gt;First item\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt; Second item \u0026lt;ul\u0026gt; \u0026lt;li\u0026gt;Second item first subitem\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt; Second item second subitem \u0026lt;ul\u0026gt; \u0026lt;li\u0026gt;Second item second subitem first sub-subitem\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;Second item second subitem second sub-subitem\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;Second item second subitem third sub-subitem\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;Second item third subitem\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;Third item\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; - first item - second item - second item first subitem - second item second subitem - second item second subitem first sub-subitem - second item second subitem second sub-subitem - second item second subitem third sub-subitem - second item third subitem - third item\rGlobal Attributes for Ordered Lists reversed: Numbering from high to low. start=\u0026quot;4\u0026quot;: Starts numbering from 4. type: Defines the numbering style (e.g., a for lowercase letters, A for uppercase letters, i for lowercase Roman numerals, I for uppercase Roman numerals). Example of starting an ordered list from 4:\n\u0026lt;ol start=\u0026#34;4\u0026#34;\u0026gt; \u0026lt;li\u0026gt;Fourth item\u0026lt;/li\u0026gt; \u0026lt;/ol\u0026gt; \u0026lt;ol reversed\u0026gt; \u0026lt;li\u0026gt;First item\u0026lt;/li\u0026gt; \u0026lt;/ol\u0026gt;\rValue Attribute Used on individual \u0026lt;li\u0026gt; elements within an ordered list to change the value of that list item:\n\u0026lt;ol\u0026gt; \u0026lt;li\u0026gt;Head north on N Halsted St\u0026lt;/li\u0026gt; \u0026lt;li value=\u0026#34;9\u0026#34;\u0026gt;Turn right on W Diversey Pkwy\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;Turn left on N Orchard St\u0026lt;/li\u0026gt; \u0026lt;/ol\u0026gt;\rDescription Lists Description lists outline multiple terms and their descriptions, useful for glossaries. They are created using the \u0026lt;dl\u0026gt; element, along with \u0026lt;dt\u0026gt; for the term and \u0026lt;dd\u0026gt; for the description.\nInstead of using a \u0026lt;li\u0026gt; element to mark up list items, the description list requires two block-level elements: the description term element, \u0026lt;dt\u0026gt;, and the description element, \u0026lt;dd\u0026gt;.\n\u0026lt;dd\u0026gt; element includes a left margin by default. The definition term and the description that directly follows it correspond to one another; thus, the order of these elements is important.\n\u0026lt;dl\u0026gt; \u0026lt;dt\u0026gt;study\u0026lt;/dt\u0026gt; \u0026lt;dd\u0026gt;The devotion of time and attention to acquiring knowledge on an academic subject, especially by means of books\u0026lt;/dd\u0026gt; \u0026lt;dt\u0026gt;design\u0026lt;/dt\u0026gt; \u0026lt;dd\u0026gt;A plan or drawing produced to show the look and function or workings of a building, garment, or other object before it is built or made\u0026lt;/dd\u0026gt; \u0026lt;dd\u0026gt;Purpose, planning, or intention that exists or is thought to exist behind an action, fact, or material object\u0026lt;/dd\u0026gt; \u0026lt;dt\u0026gt;business\u0026lt;/dt\u0026gt; \u0026lt;dt\u0026gt;work\u0026lt;/dt\u0026gt; \u0026lt;dd\u0026gt;A person\u0026#39;s regular occupation, profession, or trade\u0026lt;/dd\u0026gt; \u0026lt;/dl\u0026gt; study The devotion of time and attention to acquiring knowledge on an academic subject, especially by means of books design A plan or drawing produced to show the look and function or workings of a building, garment, or other object before it is built or made Purpose, planning, or intention that exists or is thought to exist behind an action, fact, or material object business work A person\u0026#39;s regular occupation, profession, or trade\rList-Style-Type Property List items can be styled through CSS using the list-style-type property. The style can be applied to either \u0026lt;ul\u0026gt;, \u0026lt;ol\u0026gt;, or \u0026lt;li\u0026gt; elements. [[List Styles]]\n/* Partial list of styles */ list-style-type: disc; list-style-type: circle; list-style-type: square; list-style-type: decimal; list-style-type: georgian; list-style-type: trad-chinese-informal; list-style-type: kannada; /* Custom styling */ list-style-type: \u0026#34;-\u0026#34;; /* Custom string value */ /* Identifier matching an @counter-style rule */ list-style-type: custom-counter-style; list-style-type: none; /* No list styling */ /* Global values */ list-style-type: inherit; list-style-type: initial; list-style-type: revert; list-style-type: unset;\r","date":"2024-11-04","id":105,"permalink":"/personal-site/docs/html-css/html/html-02-texts-lists/","summary":"\u003ch3 id=\"paragraphs-p-p\"\u003eParagraphs \u003ccode\u003e\u0026lt;p\u0026gt; \u0026lt;/p\u0026gt;\u003c/code\u003e\u003c/h3\u003e\n\u003cp\u003eAll text can be placed inside the \u003ccode\u003e\u0026lt;body\u0026gt;\u003c/code\u003e, but spaces will not be considered without using paragraph tags. The \u003ccode\u003e\u0026lt;p\u0026gt;\u003c/code\u003e tag can be used to create distinct paragraphs.\u003c/p\u003e","tags":[],"title":"HTML - 02 - Texts \u0026 Lists"},{"content":"Anchor Elements An anchor element is defined by wrapping the text or another HTML element we want to link with an \u0026lt;a\u0026gt; tag.\n\u0026lt;a\u0026gt;About\u0026lt;/a\u0026gt; \u0026lt;!-- Needs href to point to where to go --\u0026gt; \u0026lt;a href=\u0026#34;https://www.theodinproject.com/about\u0026#34;\u0026gt;About\u0026lt;/a\u0026gt;\rOpening Links in a New Tab The target=\u0026quot;_blank\u0026quot; attribute opens a link in a new tab. By default, links open in the same tab, which is represented by target=\u0026quot;_self\u0026quot;.\n\u0026lt;a href=\u0026#34;https://www.theodinproject.com/about\u0026#34; target=\u0026#34;_blank\u0026#34;\u0026gt;About\u0026lt;/a\u0026gt;\rSecurity: rel=\u0026quot;noreferrer\u0026quot; Setting rel=\u0026quot;noreferrer\u0026quot; helps enhance security by preventing the linked webpage from knowing the origin of the link. It also stops the opened webpage from accessing the previous webpage\u0026rsquo;s window.\n\u0026lt;a href=\u0026#34;https://www.theodinproject.com/about\u0026#34; target=\u0026#34;_blank\u0026#34; rel=\u0026#34;noreferrer\u0026#34;\u0026gt;About\u0026lt;/a\u0026gt;\rAbsolute and Relative Links Absolute Links: These are links to pages on other websites and always include the protocol and domain. https://www.theodinproject.com/about\nRelative Links: These link to other pages within the same website and do not include the domain name. They only include the path relative to the current page. Use ./ to denote the current folder, and ../ to move up one directory.\n\u0026lt;body\u0026gt; \u0026lt;h1\u0026gt;Homepage\u0026lt;/h1\u0026gt; \u0026lt;a href=\u0026#34;https://www.theodinproject.com/about\u0026#34;\u0026gt;About The Odin Project\u0026lt;/a\u0026gt; \u0026lt;a href=\u0026#34;./pages/about.html\u0026#34;\u0026gt;About\u0026lt;/a\u0026gt; \u0026lt;/body\u0026gt;\rImages The \u0026lt;img\u0026gt; tag is a void element, meaning it does not require a closing tag.\n\u0026lt;img src=\u0026#34;https://www.google.com/somepic.png\u0026#34;\u0026gt;\rFile Path for Images Use ../ to navigate up a directory when specifying a relative path. Absolute paths can also be used. src Attribute The src attribute is used to specify the location of the image file.\n\u0026lt;img src=\u0026#34;image.png\u0026#34;\u0026gt;\ralt Attribute The alt attribute provides alternate text for the image, which is displayed if the image cannot be loaded.\n\u0026lt;img src=\u0026#34;image.png\u0026#34; alt=\u0026#34;Logo of the site\u0026#34;\u0026gt;\rImage Size While not required, specifying the height and width attributes can help images load correctly.\n\u0026lt;img src=\u0026#34;https://www.theodinproject.com/mstile-310x310.png\u0026#34; alt=\u0026#34;The Odin Project Logo\u0026#34; height=\u0026#34;310\u0026#34; width=\u0026#34;310\u0026#34;\u0026gt;\rSupported Formats Common image formats include:\n.jpg .png .gif .svg File Structure A typical project file structure should look like this:\nroot/\r│\r├── index.html \u0026lt;!-- Mandatory in the root folder --\u0026gt;\r├── images/ \u0026lt;!-- Folder for images --\u0026gt;\r├── css/ \u0026lt;!-- Folder for CSS files --\u0026gt;\r└── js/ \u0026lt;!-- Folder for JavaScript files --\u0026gt;\rNaming Conventions Avoid spaces, numbers, and capital letters in file names. Keep names short and simple. Additional web pages can be placed in the root folder or in separate directories as needed. ","date":"2024-11-04","id":106,"permalink":"/personal-site/docs/html-css/html/html-03-links-images/","summary":"\u003ch2 id=\"anchor-elements\"\u003eAnchor Elements\u003c/h2\u003e\n\u003cp\u003eAn anchor element is defined by wrapping the text or another HTML element we want to link with an \u003ccode\u003e\u0026lt;a\u0026gt;\u003c/code\u003e tag.\u003c/p\u003e","tags":[],"title":"HTML - 03 - Links \u0026 Images"},{"content":"The \u0026lt;input\u0026gt; HTML element is used to create interactive controls for web-based forms to accept data from users. It provides a wide variety of input types and control widgets depending on the device and user agent. The \u0026lt;input\u0026gt; element is one of the most powerful and complex in HTML due to the numerous combinations of input types and attributes available.\n\u0026lt;input\u0026gt; Element Example \u0026lt;label for=\u0026#34;name\u0026#34;\u0026gt;Name (4 to 8 characters):\u0026lt;/label\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; id=\u0026#34;name\u0026#34; name=\u0026#34;name\u0026#34; required minlength=\u0026#34;4\u0026#34; maxlength=\u0026#34;8\u0026#34; size=\u0026#34;10\u0026#34; /\u0026gt;\rAccessibility and Labels Using a label enhances accessibility for users with assistive technologies. It also increases the click area for mouse and touch screen users. Clicking on either the label or the input field will focus the input.\nExamples of Label Usage:\nInaccessible Input: \u0026lt;p\u0026gt;Enter your name: \u0026lt;input id=\u0026#34;name\u0026#34; type=\u0026#34;text\u0026#34; size=\u0026#34;30\u0026#34; /\u0026gt;\u0026lt;/p\u0026gt;\rImplicit Label: \u0026lt;p\u0026gt; \u0026lt;label\u0026gt;Enter your name: \u0026lt;input id=\u0026#34;name\u0026#34; type=\u0026#34;text\u0026#34; size=\u0026#34;30\u0026#34; /\u0026gt;\u0026lt;/label\u0026gt; \u0026lt;/p\u0026gt;\rExplicit Label: \u0026lt;p\u0026gt; \u0026lt;label for=\u0026#34;name\u0026#34;\u0026gt;Enter your name: \u0026lt;/label\u0026gt; \u0026lt;input id=\u0026#34;name\u0026#34; type=\u0026#34;text\u0026#34; size=\u0026#34;30\u0026#34; /\u0026gt; \u0026lt;/p\u0026gt;\rLabels When including inputs, it is an accessibility requirement to add labels alongside. This is needed so those who use assistive technologies can tell what the input is for. Also, clicking or touching a label gives focus to the label\u0026rsquo;s associated form control. This improves the accessibility and usability for sighted users, increases the area a user can click or touch to activate the form control. This is especially useful (and even needed) for radio buttons and checkboxes, which are tiny.\nMore information about labels in general MDN Documentation on Labels.\n\u0026lt;input\u0026gt; needs an id attribute. The \u0026lt;label\u0026gt; then needs a for attribute whose value is the same as the input\u0026rsquo;s id.\n\u0026lt;label for=\u0026#34;peas\u0026#34;\u0026gt;Do you like peas?\u0026lt;/label\u0026gt; \u0026lt;input type=\u0026#34;checkbox\u0026#34; name=\u0026#34;peas\u0026#34; id=\u0026#34;peas\u0026#34; /\u0026gt;\rTypes of \u0026lt;input\u0026gt; The behavior of an \u0026lt;input\u0026gt; element varies based on its type attribute. If not specified, the default type is text.\nButton as \u0026lt;input\u0026gt; \u0026lt;input\u0026gt; elements of type button render as simple push buttons. However, the newer \u0026lt;button\u0026gt; element is recommended for creating buttons with more flexibility, including HTML content.\n\u0026lt;input type=\u0026#34;button\u0026#34; value=\u0026#34;Add to favorites\u0026#34;\u0026gt; \u0026lt;!-- Same as --\u0026gt; \u0026lt;button\u0026gt;Add to favorites\u0026lt;/button\u0026gt;\rInput Types Checkbox \u0026lt;fieldset\u0026gt; \u0026lt;legend\u0026gt;Choose your monster\u0026#39;s features:\u0026lt;/legend\u0026gt; \u0026lt;div\u0026gt; \u0026lt;input type=\u0026#34;checkbox\u0026#34; id=\u0026#34;scales\u0026#34; name=\u0026#34;scales\u0026#34; checked /\u0026gt; \u0026lt;label for=\u0026#34;scales\u0026#34;\u0026gt;Scales\u0026lt;/label\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div\u0026gt; \u0026lt;input type=\u0026#34;checkbox\u0026#34; id=\u0026#34;horns\u0026#34; name=\u0026#34;horns\u0026#34; /\u0026gt; \u0026lt;label for=\u0026#34;horns\u0026#34;\u0026gt;Horns\u0026lt;/label\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/fieldset\u0026gt;\rValue attribute represents the value given to the data submitted with checkbox\u0026rsquo;s name.\nRadio Similar to checkbox, only one button in a given group can be selected at the same time. Generally used in radio groups (a collection of radio buttons describing set of related options) \u0026lt;fieldset\u0026gt; \u0026lt;legend\u0026gt;Select a maintenance drone:\u0026lt;/legend\u0026gt; \u0026lt;div\u0026gt; \u0026lt;input type=\u0026#34;radio\u0026#34; id=\u0026#34;huey\u0026#34; name=\u0026#34;drone\u0026#34; value=\u0026#34;huey\u0026#34; checked /\u0026gt; \u0026lt;label for=\u0026#34;huey\u0026#34;\u0026gt;Huey\u0026lt;/label\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div\u0026gt; \u0026lt;input type=\u0026#34;radio\u0026#34; id=\u0026#34;dewey\u0026#34; name=\u0026#34;drone\u0026#34; value=\u0026#34;dewey\u0026#34; /\u0026gt; \u0026lt;label for=\u0026#34;dewey\u0026#34;\u0026gt;Dewey\u0026lt;/label\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/fieldset\u0026gt;\rThe value attribute is a string containing the radio button\u0026rsquo;s value. The value is never shown to user, but used to identify which radio button in a group is selected.\nA radio group is defined by giving each of radio buttons in the group the same name.\nDate Opens a date picker or numeric wheels for year, month, day when active in supporting browsers. The value is normalized to the format yyyy-mm-dd.\n\u0026lt;label for=\u0026#34;start\u0026#34;\u0026gt;Start date:\u0026lt;/label\u0026gt; \u0026lt;input type=\u0026#34;date\u0026#34; id=\u0026#34;start\u0026#34; name=\u0026#34;trip-start\u0026#34; value=\u0026#34;2018-07-22\u0026#34; min=\u0026#34;2018-01-01\u0026#34; max=\u0026#34;2018-12-31\u0026#34; /\u0026gt;\rValue is used to set a default date. The displayed date format will differ from the actual value — the displayed date is formatted based on the locale of the user\u0026rsquo;s browser, but the parsed value is always formatted yyyy-mm-dd.\nDatetime-Local\nA control for entering a date and time, with no time zone. Opens a date picker or numeric wheels for date- and time-components when active in supporting browsers. Email\nA field for entering an email address with validation. File\nA control for selecting a file, using the accept attribute to specify file types. Image\nA graphical submit button that displays an image defined by the src attribute. Number\nA control for entering a number, often displaying a spinner. Password\nA single-line text field where the input is obscured for security. Range\nA control for selecting a numeric value using a slider. Submit\nA button that submits the form. Attributes for \u0026lt;input\u0026gt; Each input type can accept different attributes, enhancing functionality and user experience. Here are some commonly used attributes:\ntype: Specifies the type of input (e.g., text, checkbox, radio). id: Associates a label with the input. name: Identifies the input for form submission. value: Defines the initial value of the input. required: Makes the input mandatory. min, max: Specifies the range of acceptable values for number and date inputs. placeholder: Provides a hint to the user about what to enter. ","date":"2024-11-04","id":107,"permalink":"/personal-site/docs/html-css/html/html-04-input-types/","summary":"\u003cp\u003eThe \u003cstrong\u003e\u003ccode\u003e\u0026lt;input\u0026gt;\u003c/code\u003e\u003c/strong\u003e HTML element is used to create interactive controls for web-based forms to accept data from users. It provides a wide variety of input types and control widgets depending on the device and user agent. The \u003ccode\u003e\u0026lt;input\u0026gt;\u003c/code\u003e element is one of the most powerful and complex in HTML due to the numerous combinations of input types and attributes available.\u003c/p\u003e","tags":[],"title":"HTML - 04 - Input Types"},{"content":"\u0026lt;button\u0026gt;\u0026lt;/button\u0026gt; The \u0026lt;button\u0026gt; element represents a clickable button that can be used to submit forms or trigger actions on the webpage. It can contain text, images, or other HTML elements.\n\u0026lt;button type=\u0026#34;submit\u0026#34;\u0026gt;Submit\u0026lt;/button\u0026gt; \u0026lt;button type=\u0026#34;button\u0026#34; onclick=\u0026#34;alert(\u0026#39;Hello!\u0026#39;)\u0026#34;\u0026gt;Click Me!\u0026lt;/button\u0026gt;\rDrop Down Selector: \u0026lt;select\u0026gt; \u0026lt;option\u0026gt; \u0026lt;/option\u0026gt; \u0026lt;/select\u0026gt; The \u0026lt;select\u0026gt; element creates a drop-down list that allows users to choose one or more options. Each option within the list is defined using the \u0026lt;option\u0026gt; element.\n\u0026lt;label for=\u0026#34;weather\u0026#34;\u0026gt;Select the weather type today:\u0026lt;/label\u0026gt; \u0026lt;select id=\u0026#34;weather\u0026#34;\u0026gt; \u0026lt;option value=\u0026#34;\u0026#34;\u0026gt;--Make a Choice--\u0026lt;/option\u0026gt; \u0026lt;option value=\u0026#34;sunny\u0026#34;\u0026gt;Sunny\u0026lt;/option\u0026gt; \u0026lt;option value=\u0026#34;rainy\u0026#34;\u0026gt;Rainy\u0026lt;/option\u0026gt; \u0026lt;option value=\u0026#34;snowing\u0026#34;\u0026gt;Snowing\u0026lt;/option\u0026gt; \u0026lt;option value=\u0026#34;overcast\u0026#34;\u0026gt;Overcast\u0026lt;/option\u0026gt; \u0026lt;/select\u0026gt;\rThe first \u0026lt;option\u0026gt; with value=\u0026quot;\u0026quot; is a placeholder that prompts users to make a selection. The for attribute in the \u0026lt;label\u0026gt; element links it to the \u0026lt;select\u0026gt; element, enhancing accessibility. ","date":"2024-11-04","id":108,"permalink":"/personal-site/docs/html-css/html/html-05-button/","summary":"\u003ch3 id=\"buttonbutton\"\u003e\u003ccode\u003e\u0026lt;button\u0026gt;\u0026lt;/button\u0026gt;\u003c/code\u003e\u003c/h3\u003e\n\u003cp\u003eThe \u003ccode\u003e\u0026lt;button\u0026gt;\u003c/code\u003e element represents a clickable button that can be used to submit forms or trigger actions on the webpage. It can contain text, images, or other HTML elements.\u003c/p\u003e","tags":[],"title":"HTML - 05 - Button"},{"content":"HTML DOM Events\nHTML events are actions that occur to HTML elements, which JavaScript can respond to. By using event listeners, you can execute JavaScript code in reaction to these events.\nExample of an Event Handler:\n\u0026lt;button onclick=\u0026#34;myFunction()\u0026#34;\u0026gt;Click me\u0026lt;/button\u0026gt;\rUsing addEventListener:\nbutton.addEventListener(\u0026#34;click\u0026#34;, myFunction);\rHTML Events An HTML event can be triggered by various actions, either by the browser itself or by user interactions. Here are some examples:\nThe web page has finished loading. An input field\u0026rsquo;s value has changed. A button has been clicked. When these events occur, you might want to execute specific code. JavaScript allows you to run code in response to these detected events.\nEvent Handler Attributes HTML supports event handler attributes that allow you to embed JavaScript code directly into HTML elements. For example:\n\u0026lt;input type=\u0026#34;text\u0026#34; onchange=\u0026#34;alert(\u0026#39;Input changed!\u0026#39;)\u0026#34;\u0026gt;\rCommon HTML Events Here’s a list of some common HTML events along with their descriptions:\nEvent Description onchange Triggered when the value of an HTML element changes. onclick Triggered when the user clicks on an HTML element. onmouseover Triggered when the mouse moves over an HTML element. onmouseout Triggered when the mouse moves away from an HTML element. onkeydown Triggered when the user presses a key on the keyboard. onload Triggered when the browser has finished loading the page. Event Occurs When Belongs To abort The loading of a media is aborted UiEvent, Event afterprint A page has started printing Event animationend A CSS animation has completed AnimationEvent animationiteration A CSS animation is repeated AnimationEvent animationstart A CSS animation has started AnimationEvent beforeprint A page is about to be printed Event beforeunload Before a document is about to be unloaded UiEvent, Event blur An element loses focus FocusEvent canplay The browser can start playing a media (has buffered enough to begin) Event canplaythrough The browser can play through a media without stopping for buffering Event change The content of a form element has changed Event click An element is clicked on MouseEvent contextmenu An element is right-clicked to open a context menu MouseEvent copy The content of an element is copied ClipboardEvent cut The content of an element is cut ClipboardEvent dblclick An element is double-clicked MouseEvent drag An element is being dragged DragEvent dragend Dragging of an element has ended DragEvent dragenter A dragged element enters the drop target DragEvent dragleave A dragged element leaves the drop target DragEvent dragover A dragged element is over the drop target DragEvent dragstart Dragging of an element has started DragEvent drop A dragged element is dropped on the target DragEvent durationchange The duration of a media is changed Event ended A media has reach the end (\u0026ldquo;thanks for listening\u0026rdquo;) Event error An error has occurred while loading a file ProgressEvent, UiEvent, Event focus An element gets focus FocusEvent focusin An element is about to get focus FocusEvent focusout An element is about to lose focus FocusEvent fullscreenchange An element is displayed in fullscreen mode Event fullscreenerror An element can not be displayed in fullscreen mode Event hashchange There has been changes to the anchor part of a URL HashChangeEvent input An element gets user input InputEvent, Event invalid An element is invalid Event keydown A key is down KeyboardEvent keypress A key is pressed KeyboardEvent keyup A key is released KeyboardEvent load An object has loaded UiEvent, Event loadeddata Media data is loaded Event loadedmetadata Meta data (like dimensions and duration) are loaded Event loadstart The browser starts looking for the specified media ProgressEvent message A message is received through the event source Event mousedown The mouse button is pressed over an element MouseEvent mouseenter The pointer is moved onto an element MouseEvent mouseleave The pointer is moved out of an element MouseEvent mousemove The pointer is moved over an element MouseEvent mouseover The pointer is moved onto an element MouseEvent mouseout The pointer is moved out of an element MouseEvent mouseup A user releases a mouse button over an element MouseEvent mousewheel Deprecated. Use the wheel event instead WheelEvent offline The browser starts working offline Event online The browser starts working online Event open A connection with the event source is opened Event pagehide User navigates away from a webpage PageTransitionEvent pageshow User navigates to a webpage PageTransitionEvent paste Some content is pasted in an element ClipboardEvent pause A media is paused Event play The media has started or is no longer paused Event playing The media is playing after being paused or buffered Event popstate The window\u0026rsquo;s history changes PopStateEvent progress The browser is downloading media data Event ratechange The playing speed of a media is changed Event resize The document view is resized UiEvent, Event reset A form is reset Event scroll An scrollbar is being scrolled UiEvent, Event search Something is written in a search field Event seeked Skipping to a media position is finished Event seeking Skipping to a media position is started Event select User selects some text UiEvent, Event show A element is shown as a context menu Event stalled The browser is trying to get unavailable media data Event storage A Web Storage area is updated StorageEvent submit A form is submitted Event suspend The browser is intentionally not getting media data Event timeupdate The playing position has changed (the user moves to a different point in the media) Event toggle The user opens or closes the element Event touchcancel The touch is interrupted TouchEvent touchend A finger is removed from a touch screen TouchEvent touchmove A finger is dragged across the screen TouchEvent touchstart A finger is placed on a touch screen TouchEvent transitionend A CSS transition has completed TransitionEvent unload A page has unloaded UiEvent, Event volumechange The volume of a media is changed (includes muting) Event waiting A media is paused but is expected to resume (e.g. buffering) Event wheel The mouse wheel rolls up or down over an element WheelEvent ","date":"2024-11-04","id":109,"permalink":"/personal-site/docs/html-css/html/html-06-dom-events/","summary":"\u003cp\u003e\u003ca href=\"https://www.w3schools.com/jsref/dom_obj_event.asp\"\u003eHTML DOM Events\u003c/a\u003e\u003c/p\u003e\n\u003chr\u003e\n\u003cp\u003eHTML events are actions that occur to HTML elements, which JavaScript can respond to. By using event listeners, you can execute JavaScript code in reaction to these events.\u003c/p\u003e","tags":[],"title":"HTML - 06 - DOM Events"},{"content":"CSS consists of rules, which are made up of:\nSelector: Points to a part of the HTML Declaration: A property: value pair (semicolon-separated list) Ruleset A ruleset (or rule) consists of One or more selectors and an associated declarations block\nHTML comments: \u0026lt;!-- --\u0026gt; CSS comments: /* */ Selectors Selectors refer to the HTML elements to which a particular CSS rules / declarations applies to; selectors , are conditions selecting some elements of the page.\nSelectors are used to target HTML elements for applying CSS styles. A declaration block is applied to the selected elements.\nSelectors can be simple (e.g., targeting a specific element) or more complex (e.g., selecting by class or ID).\nEach valid declaration block is preceded by one or more comma-separated selectors.\nA \u0026lt;div\u0026gt; is one of the basic HTML elements. It is an empty container. In general, it is best to use other tags such as \u0026lt;h1\u0026gt; or \u0026lt;p\u0026gt; for content but there are many cases where the thing needed is just a container for other elements.\nSelector Types 1. Universal Selector (*) The universal selector will select all elements of any type in a document, hence the name universal selector, and the syntax for it is an asterisk *.\n* { color: purple; }\rThis would apply color: purple; to all elements on the page.\n2. Type Selector A type selector (or element selector) targets all elements of a specific type (e.g., \u0026lt;div\u0026gt;, \u0026lt;p\u0026gt;, etc.).\n\u0026lt;!-- index.html --\u0026gt; \u0026lt;div\u0026gt;Hello, World!\u0026lt;/div\u0026gt; \u0026lt;div\u0026gt;Hello again!\u0026lt;/div\u0026gt; \u0026lt;p\u0026gt;Hi...\u0026lt;/p\u0026gt; \u0026lt;div\u0026gt;Okay, bye.\u0026lt;/div\u0026gt;\r/* styles.css */ div { color: white; }\rThis will apply the color: white; style to all \u0026lt;div\u0026gt; elements, but not to \u0026lt;p\u0026gt; elements.\n3. Class Selector Class selectors target all elements with a specific class. The syntax uses a period (.) followed by the class name.\nClasses are reusable across multiple elements.\n\u0026lt;div class=\u0026#34;alert-text\u0026#34;\u0026gt;Please agree to our terms.\u0026lt;/div\u0026gt;\r.alert-text { color: red; }\rSyntax: .classname\na period . immediately followed by the case-sensitive value of the class attribute.\nYou can also add multiple classes to an element using a space-separated list:\n\u0026lt;div class=\u0026#34;alert-text severe-alert\u0026#34;\u0026gt;Warning!\u0026lt;/div\u0026gt;\r4. ID Selector ID selectors target an element with a specific ID. The syntax uses a hashtag (#) followed by the ID value. IDs must be unique within a page.\nExample: \u0026lt;div id=\u0026#34;title\u0026#34;\u0026gt;My Awesome 90\u0026#39;s Page\u0026lt;/div\u0026gt;\r#title { background-color: red; }\rSyntax: #idname\nA hashtag # immediately followed by the case-sensitive value of the ID attribute.\nImportant: An element can have only one ID, and an ID must be unique within a page. IDs should not contain any white space. Key Differences Between Classes and IDs Classes: Can be used on multiple elements. Can apply to any number of elements across a page. IDs: Must be unique to a single element. Cannot be used on more than one element on a page. A common mistake is overusing the ID attribute when a class would suffice.\n","date":"2024-11-06","id":110,"permalink":"/personal-site/docs/html-css/css/css-01-selectors/","summary":"\u003cp\u003eCSS consists of rules, which are made up of:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eSelector\u003c/strong\u003e: Points to a part of the HTML\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eDeclaration\u003c/strong\u003e: A \u003cstrong\u003eproperty: value\u003c/strong\u003e pair (semicolon-separated list)\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"ruleset\"\u003e\u003cstrong\u003eRuleset\u003c/strong\u003e\u003c/h3\u003e\n\u003cp\u003eA \u003cstrong\u003eruleset\u003c/strong\u003e (or \u003cstrong\u003erule\u003c/strong\u003e) consists of One or more \u003cstrong\u003eselectors\u003c/strong\u003e and an associated \u003cstrong\u003edeclarations block\u003c/strong\u003e\u003c/p\u003e","tags":[],"title":"CSS - 01 -Selectors"},{"content":"","date":"2024-10-22","id":111,"permalink":"/personal-site/docs/html-css/css/","summary":"","tags":[],"title":"CSS"},{"content":"1. Grouping Selectors Grouping selectors allows for applying the same style rules to multiple elements. Instead of writing separate rules for similar selectors, they can be grouped together with a comma-separated list. This helps in reducing redundancy and makes your CSS more efficient.\nIf the .read and .unread selectors share common style declarations, we can group them together:\nExample 1: Grouping selectors without grouping\n.read { color: white; background-color: black; /* several unique declarations */ } .unread { color: white; background-color: black; /* several unique declarations */ }\rExample 2: Grouping selectors with a comma-separated list\n.read, .unread { color: white; background-color: black; } .read { /* several unique declarations for .read */ } .unread { /* several unique declarations for .unread */ }\rBy grouping them, you can apply common properties (like color and background-color) to both classes at once. This reduces repetition and makes your code easier to maintain.\n2. Chaining Selectors Chaining selectors allows for targeting elements that match multiple conditions, such as an element that has both a specific class and an ID, or multiple classes. This technique can be used to apply styles more specifically without having to create new classes or IDs.\nExample 1: Chaining two classes Chain class selectors to target elements that have both classes:\n\u0026lt;div\u0026gt; \u0026lt;div class=\u0026#34;subsection header\u0026#34;\u0026gt;Latest Posts\u0026lt;/div\u0026gt; \u0026lt;p class=\u0026#34;subsection preview\u0026#34;\u0026gt;This is where a preview for a post might go.\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt;\r.subsection.header { color: red; }\rIn this case, .subsection.header selects only the \u0026lt;div\u0026gt; element with both the subsection and header classes.\nExample 2: Chaining a class and an ID Chaining a class and an ID to target a specific element:\n\u0026lt;div\u0026gt; \u0026lt;div class=\u0026#34;subsection header\u0026#34;\u0026gt;Latest Posts\u0026lt;/div\u0026gt; \u0026lt;p class=\u0026#34;subsection\u0026#34; id=\u0026#34;preview\u0026#34;\u0026gt;This is where a preview for a post might go.\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt;\r.subsection.header { color: red; } .subsection#preview { color: blue; }\rIn this case:\n.subsection.header targets the div with both classes subsection and header. .subsection#preview targets the p element with class subsection and ID preview. Important: You cannot chain multiple type selectors (e.g., div and p) since an element can only be one type. For example, divp is not valid because it tries to target a non-existent \u0026lt;divp\u0026gt; element.\n3. Combinators Combinators in CSS are used to describe relationships between elements. They allow us to select elements based on their position or relationship in the HTML structure.\n3.1 Descendant Combinator (A B) Specifies that the element selected by B is a descendant of the element selected by A, but is not necessarily a direct child.\nThe descendant combinator (represented by a space between two selectors) selects an element that is a descendant of another element. This can be any level of nesting, not just direct children.\nchild class will only be selected if it is nested inside ancestor, regardless of how deep that nesting is.\n\u0026lt;div class=\u0026#34;ancestor\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;contents\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;contents\u0026#34;\u0026gt;More Content\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;contents\u0026#34;\u0026gt;No nesting\u0026lt;/div\u0026gt;\r.ancestor .contents { color: green; }\rThe .ancestor .contents selector will apply to the .contents elements inside the .ancestor element, but not the .contents element outside it. There is no limit to how many nested elements you can select with descendant combinators, e.g., .one .two .three .four. 3.2 Next-Sibling Combinator (A + B) The next-sibling combinator specifies that the elements selected by both A and B have the same parent and selects the element B that immediately follows element A as a sibling.\n\u0026lt;div class=\u0026#34;first\u0026#34;\u0026gt;First\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;second\u0026#34;\u0026gt;Second\u0026lt;/div\u0026gt;\r.first + .second { color: purple; }\rThis rule will apply color: purple to .second only if it directly follows .first. 3.3 Subsequent-Sibling Combinator (A ~ B) The subsequent-sibling combinator selects all elements B that share the same parent as element A and come after it, but not necessarily immediately.\n\u0026lt;div class=\u0026#34;first\u0026#34;\u0026gt;First\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;second\u0026#34;\u0026gt;Second\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;third\u0026#34;\u0026gt;Third\u0026lt;/div\u0026gt;\r.first ~ .third { color: orange; }\rIn this case, the rule will apply color: orange to .third because it follows .first and is within the same parent. 3.4 Child Combinator (A \u0026gt; B) The child combinator selects element B only if it is a direct child of element A.\n\u0026lt;div class=\u0026#34;parent\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;child\u0026#34;\u0026gt;Child\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;child\u0026#34;\u0026gt;Not a direct child\u0026lt;/div\u0026gt;\r.parent \u0026gt; .child { color: blue; }\rThe .parent \u0026gt; .child selector will only apply styles to .child elements that are direct children of .parent. 3.5 Column Combinator (A || B) The column combinator is used in tables to target elements within a specific column.\n\u0026lt;table\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;Column 1\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;Column 2\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;Data 1\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;Data 2\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/table\u0026gt;\rtd || Column 2 { color: red; }\rThe column combinator selects elements in a specified table column, including those that span multiple columns. CSS Cascade and Specificity Specificity in CSS The order of importance in CSS rules is determined by specificity. More specific selectors override less specific ones.\nSpecificity Hierarchy: Inline styles: Styles applied directly to an element via the style attribute. ID selectors: #idname (more specific than classes or elements). Class selectors: .classname Type selectors: div, p, etc. General Rule: An ID selector will always override any number of class or type selectors, and a class selector will override any number of type selectors.\n\u0026lt;div class=\u0026#34;main\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;list\u0026#34; id=\u0026#34;subsection\u0026#34;\u0026gt;Blue text\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt;\r#subsection { color: blue; } .main .list { color: red; }\rResult: The text will appear in blue because the ID selector (#subsection) has higher specificity than the class selector (.main .list). Additional resources An interactive Scrim Video covers how selectors can be chained and used along with rules to select specific items.\nThe CSS Cascade interactive read that in detail about other factors that affect what CSS rules actually end up being applied.\nCSS Specificity Explained video from Kevin Powell about specificity of selectors and priorities.\nInteractive Scrim on the CSS Cascade.\nCSS Specificity Calculator allows you to fill in your own selectors and have their specificity calculated and visualized.\n","date":"2024-11-06","id":112,"permalink":"/personal-site/docs/html-css/css/css-02-multiple-selecors/","summary":"\u003ch2 id=\"1-grouping-selectors\"\u003e\u003cstrong\u003e1. Grouping Selectors\u003c/strong\u003e\u003c/h2\u003e\n\u003cp\u003eGrouping selectors allows for applying the same style rules to multiple elements. Instead of writing separate rules for similar selectors, they can be grouped together with a comma-separated list. This helps in reducing redundancy and makes your CSS more efficient.\u003c/p\u003e","tags":[],"title":"CSS - 02 - Multiple Selecors"},{"content":"A Declaration is a key-value pair that defines a style rule in CSS. It is composed of two parts:\nProperty: An identifier (human-readable name) that specifies the feature to be styled. Value: Describes how the feature should be handled by the browser engine. Declaration Block A declaration block is a group of one or more declarations enclosed in curly braces ({}), and each declaration is separated by a semicolon (;).\ndiv.bold-text { font-weight: 700; /* Property: font-weight, Value: 700 */ text-align: center; /* Property: text-align, Value: center */ }\rThe property is font-weight and text-align. The value for font-weight is 700 and for text-align is center. CSS Properties Each CSS property has a set of valid values, defined by a formal grammar, as well as a semantic meaning, implemented by the browser engine.\nColor and Background Color The color property controls the text color, while the background-color property defines the background color of an element. Both properties can accept different kinds of values:\nKeywords (e.g., red, transparent) HEX values (e.g., #FF5733) RGB values (e.g., rgb(255, 87, 51)) HSL values (e.g., hsl(9, 100%, 60%)) [[CSS_Color_values]] p { /* HEX color */ color: #1100ff; } p { /* RGB color */ color: rgb(100, 0, 127); } p { /* HSL color */ color: hsl(15, 82%, 56%); }\rTypography Basics Font Family The font-family property defines which font to use for the text. It can be:\nA specific font family name (e.g., \u0026quot;Times New Roman\u0026quot;). A generic font family (e.g., serif, sans-serif). If a browser can\u0026rsquo;t find or support the first font in the list, it will try the next one, and so on, until it finds a valid font.\nThis is why it’s best practice to include a list of values for this property, starting with the font you want to be used most and ending with a generic font family as a fallback, e.g. font-family: \u0026quot;Times New Roman\u0026quot;, serif;\nbody { font-family: \u0026#34;Times New Roman\u0026#34;, serif; }\rIn this example, \u0026quot;Times New Roman\u0026quot; is the preferred font, and serif is the fallback.\nFont Size The font-size property sets the size of the text. This value should not contain any spaces between the number and the unit (e.g., px, em).\np { font-size: 22px; }\rFont Weight The font-weight property affects the boldness of the text. It can accept:\nKeywords like normal, bold. Numeric values (e.g., 700 for bold, 400 for normal). h1 { font-weight: bold; /* Keyword */ } h2 { font-weight: 700; /* Numeric value for bold */ }\rText Alignment The text-align property aligns text horizontally within an element. Common values include:\nleft center right justify p { text-align: center; }\rImage Size (Height and Width) By default, an \u0026lt;img\u0026gt; element’s height and width values are the same as the image’s actual dimensions.\nImages aren’t the only elements that we can adjust the height and width on. To adjust the size of the image without causing it to lose its proportions, you would use a value of “auto” for the height property and adjust the width value:\nAdjusting Image Size Without Losing Proportions\nimg { height: auto; /* Preserve aspect ratio */ width: 500px; /* Set a fixed width */ }\rThis ensures the image keeps its aspect ratio while adjusting the width to 500px.\nWhy Set Height and Width?\nWhen you explicitly set the height and width for images, you help the browser allocate space on the page before the image loads. This prevents layout shifts as images load.\nInline vs. Block Elements Inline Elements Inline elements do not start on a new line. They appear alongside other elements on the same line. \u0026lt;a\u0026gt;, \u0026lt;span\u0026gt;, \u0026lt;strong\u0026gt;, \u0026lt;em\u0026gt;. Inline elements have special behavior for padding and margin. For instance, they won’t expand vertically like block elements.\nPadding and margin behave differently on inline elements. Do not want to try to put extra padding or margin on inline elements.\nBlock Elements Block elements start on a new line and take up the full width of their parent element, stacking vertically. \u0026lt;div\u0026gt;, \u0026lt;p\u0026gt;, \u0026lt;h1\u0026gt; to \u0026lt;h6\u0026gt;. Block elements behave like containers that stretch across the page.\ndisplay Property Inline vs. Block Display display: inline: Makes elements appear in a line, one after another. display: block: Forces elements to take up the full width, causing each element to appear on a new line. Next item goes to the next line (stacked on each other) img { display: block; } button { display: inline; }\rimg will behave as a block element (taking up full width). button will behave inline, appearing next to other inline elements. inline-block: A Middle Ground The inline-block value combines the behavior of inline and block elements. It allows elements to sit inline, but you can still apply block-level properties like padding and margin. You’ll probably end up reaching for flexbox more often\ndiv { display: inline-block; margin: 10px; }\rinline-block elements behave like inline elements, but you can still control their dimensions and margins like block elements. Divs and Spans \u0026lt;div\u0026gt;: A block-level element used to group other elements and apply styles. It’s a generic container with no semantic meaning. Divs allow us to divide the page into different blocks and apply styling to those blocks.\n\u0026lt;span\u0026gt;: An inline-level element used to group text or inline elements for styling purposes. It’s also a generic container but doesn\u0026rsquo;t affect layout as much as \u0026lt;div\u0026gt;.\n\u0026lt;div class=\u0026#34;container\u0026#34;\u0026gt; \u0026lt;p\u0026gt;This is a \u0026lt;span class=\u0026#34;highlight\u0026#34;\u0026gt;highlighted\u0026lt;/span\u0026gt; word.\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt;\rMain reference Mozilla CSS values and units can be used to learn the various types of values possible in absolute or relative terms.\nMozilla CSS Properties Reference can be used to learn if a particular CSS property is inherited or not; look for the Inherited field inside the Formal Definition section. Here’s an example for the CSS color property.\n","date":"2024-11-06","id":113,"permalink":"/personal-site/docs/html-css/css/css-03-declaration/","summary":"\u003cp\u003eA \u003cstrong\u003eDeclaration\u003c/strong\u003e is a key-value pair that defines a style rule in CSS. It is composed of two parts:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\u003cstrong\u003eProperty\u003c/strong\u003e: An identifier (human-readable name) that specifies the feature to be styled.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eValue\u003c/strong\u003e: Describes how the feature should be handled by the browser engine.\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch3 id=\"declaration-block\"\u003e\u003cstrong\u003eDeclaration Block\u003c/strong\u003e\u003c/h3\u003e\n\u003cp\u003eA declaration block is a group of one or more declarations enclosed in curly braces (\u003ccode\u003e{}\u003c/code\u003e), and each declaration is separated by a semicolon (\u003ccode\u003e;\u003c/code\u003e).\u003c/p\u003e","tags":[],"title":"CSS - 03 - Declaration"},{"content":"There are three primary methods to add CSS to an HTML document: External CSS, Internal CSS, and Inline CSS. Let’s break down each method:\n1. External CSS External CSS involves creating a separate CSS file and linking it to HTML document. This is done using the void \u0026lt;link\u0026gt; element inside the \u0026lt;head\u0026gt; section of the HTML.\nThe href attribute specifies the location of the CSS file, and the rel attribute defines the relationship between the HTML file and the linked CSS file (which will always be stylesheet).\n\u0026lt;!-- index.html --\u0026gt; \u0026lt;head\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;styles.css\u0026#34;\u0026gt; \u0026lt;/head\u0026gt;\r/* styles.css */ div { color: white; background-color: black; } p { color: red; }\rAdvantages of External CSS: Separation of concerns: Keeps HTML and CSS files separate, making the HTML cleaner and smaller. Reusability: You only need to edit the CSS in one place, and those styles will apply to every HTML page linked to that CSS file. This is especially useful for websites with multiple pages that share similar styles. 2. Internal CSS Internal CSS, or embedded CSS, involves placing the CSS rules directly inside the HTML document. The CSS is placed within the \u0026lt;style\u0026gt; tag inside the \u0026lt;head\u0026gt; section of the HTML.\nPlace your CSS rules between the opening and closing \u0026lt;style\u0026gt; tags in the \u0026lt;head\u0026gt; section of your HTML document. This method is useful when you want to style a single HTML page without affecting others. HTML with Internal CSS:\n\u0026lt;head\u0026gt; \u0026lt;style\u0026gt; div { color: white; background-color: black; } p { color: red; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div\u0026gt;Sample content\u0026lt;/div\u0026gt; \u0026lt;p\u0026gt;Some text\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt;\rAdvantages of Internal CSS: Ideal for applying styles to a single page or when you\u0026rsquo;re testing out different styles quickly. No need to create and maintain a separate CSS file for simple styles on one page. Disadvantages of Internal CSS: Does not keep styles separate from content, which can make the HTML file larger and less maintainable, especially for larger projects. Not reusable across multiple pages (unlike External CSS). 3. Inline CSS Inline CSS applies styles directly to individual HTML elements using the style attribute. This method allows you to specify styles directly within the HTML tag itself.\nHow to Use Inline CSS Add the style attribute to an HTML element. Place the CSS declaration(s) within the style attribute. Each declaration is separated by a semicolon. HTML with Inline CSS:\n\u0026lt;body\u0026gt; \u0026lt;div style=\u0026#34;color: white; background-color: black;\u0026#34;\u0026gt;Content goes here\u0026lt;/div\u0026gt; \u0026lt;p style=\u0026#34;color: red;\u0026#34;\u0026gt;Some text here\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt;\rAdvantages of Inline CSS: Useful for quickly testing or applying one-off styles to specific elements. No need to write separate CSS files or use \u0026lt;style\u0026gt; tags. Disadvantages of Inline CSS: Poor maintainability: Styles are applied directly to elements, which can make the HTML messy and harder to maintain. Redundancy: You’ll need to repeat the same styles across different elements if they share the same styling, which can lead to repetitive code. Overrides other styles: Inline styles have the highest specificity, meaning they can override other CSS rules (including external and internal styles). Summary of Methods Method When to Use Pros Cons External CSS When you have multiple pages or want separation of concerns Clean, reusable across multiple pages Requires an extra HTTP request for the CSS file Internal CSS For single-page styles or testing Easy to apply to a single page Not reusable across pages; can make HTML bulky Inline CSS For quick, one-off styling of elements Quick to implement Hard to maintain, can lead to redundancy ","date":"2024-11-06","id":114,"permalink":"/personal-site/docs/html-css/css/css-04-adding-css/","summary":"\u003cp\u003eThere are three primary methods to add CSS to an HTML document: \u003cstrong\u003eExternal CSS\u003c/strong\u003e, \u003cstrong\u003eInternal CSS\u003c/strong\u003e, and \u003cstrong\u003eInline CSS\u003c/strong\u003e. Let’s break down each method:\u003c/p\u003e","tags":[],"title":"CSS - 04 - Adding CSS"},{"content":"MDN’s lesson on the box model. Inline boxes !\nEvery element on a webpage is essentially a rectangular box, and the Box Model describes the structure of these boxes. Margin, Border, Padding and Content is what is called box model. * {outline: 2px solid red} marking boxes.\nThe model consists of the following components:\nContent: The actual content of the element, such as text or images. Padding: The space between the content and the border. Border: Surrounds the padding (if any) and content. Margin: The space outside the border, separating elements from each other. 1. Margin The margin is the space outside the element’s border, separating it from other elements. CSS Tricks page on margins\nDefault Margin The default margin for most elements (especially block-level elements) is usually 8px, but it can be removed by setting it to 0.\nCollapsing Margins If two elements have adjacent margins (i.e., one is directly above or below the other), the larger margin will \u0026ldquo;collapse\u0026rdquo; and be applied instead of combining the two. For example:\nIf the bottom margin of the first element is 15px and the top margin of the second element is 20px, the space between the two elements will be 20px (not 35px). Centering Elements Horizontally Using Margins To horizontally center a block element:\nSet display: block; to the element (block elements are naturally placed on their own line). The element must have a defined width. Set margin-left: auto; and margin-right: auto;. .element { width: 300px; margin-left: auto; margin-right: auto; }\rmargin-left: auto; pushes the element to the left. margin-right: auto; pushes it to the right, dividing the remaining space equally on both sides, thus centering the element. Margin Shorthand The margin can be set using shorthand notation:\nmargin: 10px; — applies 10px to all four sides. margin: 10px 20px 30px 40px; — follows the \u0026ldquo;clock method\u0026rdquo;: Top: 10px Right: 20px Bottom: 30px Left: 40px If only two values are given:\nmargin: 20px auto; — 20px for top and bottom, and auto for left and right (centers horizontally). 2. Padding Padding is the space between the content of an element and its border. It increases the internal space within a box.\nPadding Shorthand Padding can be applied to all four sides at once using shorthand:\npadding: 10px; — applies 10px padding to all sides. padding: 10px 20px 30px 40px; — follows the same \u0026ldquo;clock method\u0026rdquo; as margin: Top: 10px Right: 20px Bottom: 30px Left: 40px If two values are provided:\npadding: 20px 10px; — 20px for top and bottom, 10px for left and right. 3. Border and Border Radius The border is the area between the content/padding and the margin. It is often used to visually separate elements.\nThe border can be set with:\nWidth: The thickness of the border. Style: The type of border (solid, dashed, dotted, etc.). Color: The color of the border. element { border: 8px solid blue; }\rBorder Radius The border-radius property is used to round the corners of an element’s border.\nelement { border-radius: 10px; }\r4. Content The content of a box refers to the actual text, images, or other elements inside it.\nHeight and Line Height: height: 24px; — this sets the height of the content area (excluding padding and borders). line-height: 24px; — this sets the height of a line of text, which can affect vertical alignment. Box Sizing The box-sizing property controls how the width and height of an element are calculated.\ncontent-box (default) In the content-box model, the width and height of the box are applied to the content only. The padding and border are added on top of the content width and height, making the total size of the element larger than the declared width and height.\nbox-sizing: content-box;\rif you set width: 300px; and the element has padding and borders, the total width will be larger than 300px. Here the size of the box will be width + paddig + border so if width is 300px it is the width of the content of the box but not the box. border-box In the border-box model, the width and height include the padding and border. This means the total width or height is exactly what you set, with padding and borders inside the defined dimensions.\nbox-sizing: border-box;\rif width: 300px;, the padding and border will be included inside this 300px width. Best Practice To apply border-box globally (for all elements), you can use the following rule:\n* { margin: 0; padding: 0; border: 0; box-sizing: border-box; }\rThis resets the box model for all elements, making layout calculations easier.\nSummary of the Box Model Properties Property Description Shorthand Example Margin Space outside the border of an element. margin: 10px 20px 30px 40px; Padding Space between the content and the border. padding: 10px 20px; Border A line surrounding the padding and content. border: 8px solid blue; Content The actual content of the box (text, images, etc.). height: 24px; or line-height: 24px; Box-sizing Defines how the total width and height of the box are calculated. box-sizing: border-box; or content-box; Additional resources Learn CSS Box Model box-sizing: border-box Scrim on the box model. Slaying The Dragon for understanding the box model. ","date":"2024-11-06","id":115,"permalink":"/personal-site/docs/html-css/css/css-05-box-model/","summary":"\u003cp\u003e\u003ca href=\"https://developer.mozilla.org/en-US/docs/Learn/CSS/Building_blocks/The_box_model\"\u003eMDN’s lesson on the box model\u003c/a\u003e. Inline boxes !\u003c/p\u003e\n\u003cp\u003eEvery element on a webpage is essentially a rectangular box, and the \u003cstrong\u003eBox Model\u003c/strong\u003e describes the structure of these boxes.\nMargin, Border, Padding and Content is what is called box model.\u003ccode\u003e * {outline: 2px solid red}\u003c/code\u003e marking boxes.\u003c/p\u003e","tags":[],"title":"CSS - 05 - Box Model"},{"content":"Flexbox Resource\nFlexbox is a layout model in CSS designed to arrange items into rows or columns. It allows items to flex (grow or shrink) based on defined rules, giving us more control over the alignment, spacing, and distribution of elements in a container.\nFlex Containers and Flex Items Flexbox involves two main concepts:\nFlex Container: This is the parent element that has display: flex applied to it. It acts as a wrapper for the child elements. Flex Items: These are the child elements inside the flex container, which will be arranged based on the flex properties of the container. Any element can be both a flex container and a flex item. flex containers can be nested, applying display: flex to a flex item and then arranging its children using flexbox again (i.e., creating nested flexboxes).\nCentering Buttons with Flexbox \u0026lt;div class=\u0026#34;button-container\u0026#34;\u0026gt; \u0026lt;button\u0026gt;Button 1\u0026lt;/button\u0026gt; \u0026lt;button\u0026gt;Button 2\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt;\r.button-container { display: flex; /* Establish flexbox on the container */ justify-content: center; /* Align the buttons horizontally in the center */ } button { margin: 0 10px; /* Optional: Space between buttons */ }\rExplanation:\nFlex Container: The \u0026lt;div class=\u0026quot;button-container\u0026quot;\u0026gt; is the flex container with display: flex. Flex Items: The two \u0026lt;button\u0026gt; elements are the flex items inside the container. justify-content: center is used to center the buttons horizontally. You can use margin on the buttons to add space between them, or use justify-content: space-around or justify-content: space-between to control spacing automatically. Common Flexbox Properties 1. Flex Container Properties The flex container controls the layout of its direct child elements (flex items).\ndisplay: flex: Establishes the flex container.\nflex-direction: Defines the direction in which the flex items are placed (row, column, etc.).\nrow (default): Items are placed horizontally (left to right). column: Items are placed vertically (top to bottom). justify-content: Aligns the flex items along the main axis (horizontal or vertical depending on flex-direction).\ncenter: Centers items within the container. flex-start: Aligns items to the start of the container. flex-end: Aligns items to the end of the container. space-between: Distributes items evenly with space between them. space-around: Distributes items with equal space around them. space-evenly: Distributes items with equal space between and around them. .container { display: flex; justify-content: space-between; /* Space out items evenly */ }\ralign-items: Aligns the items along the cross axis (perpendicular to the main axis).\nstretch (default): Stretches items to fill the container\u0026rsquo;s height. flex-start: Aligns items to the top (or left if flex-direction: row). flex-end: Aligns items to the bottom (or right if flex-direction: row). center: Centers items vertically (or horizontally). baseline: Aligns items based on their baseline (useful for text). .container { display: flex; align-items: center; /* Vertically centers items in the container */ }\ralign-content: Aligns the flex lines when there is extra space along the cross axis (for multi-line flex containers).\nflex-start, flex-end, center, space-between, space-around, and stretch work similarly as with align-items. 2. Flex Item Properties These properties control the layout and behavior of individual flex items inside a flex container.\nflex-grow: Defines how much a flex item should grow relative to the other items in the container. It is a proportion.\nflex-grow: 1; means the item can grow to take up any available space. A value of 0 means it will not grow. .item { flex-grow: 1; /* Allow this item to grow */ }\rflex-shrink: Defines how much a flex item should shrink relative to the other items when there is not enough space.\nflex-shrink: 1; (default) allows the item to shrink if needed. flex-shrink: 0; means the item will not shrink. .item { flex-shrink: 0; /* Prevent this item from shrinking */ }\rflex-basis: Specifies the initial size of the flex item before any space distribution.\nThis can be a fixed value (e.g., 200px) or auto (where the size is based on the item\u0026rsquo;s content). .item { flex-basis: 100px; /* Set initial size to 100px */ }\rflex: This is a shorthand property for flex-grow, flex-shrink, and flex-basis.\nflex: 1 is a common shorthand, which means the item can grow and shrink, and the initial size is 0. .item { flex: 1; /* Equivalent to flex-grow: 1; flex-shrink: 1; flex-basis: 0; */ }\ralign-self: Overrides the align-items setting for an individual flex item.\nalign-self: center; will center the item vertically (or horizontally depending on the flex-direction). .item { align-self: flex-end; /* Align this item to the end along the cross axis */ }\rColumns in Flexbox By default, Flexbox arranges items in a row. However, you can also create a column layout by using flex-direction: column;.\nCreating Columns in Flexbox When you use display: flex, it places all direct children of the container into rows or columns. However, only direct children are arranged this way. Any nested elements inside those direct children will not automatically be arranged into columns.\nCreating a Column Layout .container { display: flex; flex-direction: column; /* Arrange items in a column */ align-items: center; /* Optionally, center the items horizontally */ }\rImportant Notes:\nFlexbox uses the container\u0026rsquo;s direct children for the layout. If a container has nested elements, those elements will not be arranged in a column unless you apply display: flex to the nested container as well. To make the layout responsive, the flex container width should be set appropriately, especially in responsive designs. Summary of Key Flexbox Properties Property Description Values display: flex Establishes the flex container display: flex; flex-direction Defines the direction of the flex items row, column, row-reverse, column-reverse justify-content Aligns items along the main axis flex-start, flex-end, center, space-between, space-around, space-evenly align-items Aligns items along the cross axis flex-start, flex-end, center, baseline, stretch align-self Overrides align-items for individual flex items auto, flex-start, flex-end, center, baseline, stretch flex-grow Defines the growth factor of a flex item A number (default 0) flex-shrink Defines the shrink factor of a flex item A number (default 1) flex-basis Defines the initial size of a flex item Any valid length (e.g., auto, 100px, 20%) flex Shorthand for flex-grow, flex-shrink, and flex-basis flex: 1; or flex: [grow] [shrink] [basis] align-content Aligns multiple lines of flex items in the container flex-start, flex-end, center, space-between, space-around, stretch Interneting Is Hard tutorial on CSS layouts with flexbox. Slaying the dragon tutorial on Flexbox in 8 minutes. ","date":"2024-11-06","id":116,"permalink":"/personal-site/docs/html-css/css/css-06-flexbox/","summary":"\u003cp\u003e\u003ca href=\"https://developer.mozilla.org/en-US/docs/Learn/CSS/CSS_layout/Flexbox\"\u003eFlexbox Resource\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003eFlexbox is a layout model in CSS designed to arrange items into rows or columns. It allows items to \u003cstrong\u003eflex\u003c/strong\u003e (grow or shrink) based on defined rules, giving us more control over the alignment, spacing, and distribution of elements in a container.\u003c/p\u003e","tags":[],"title":"CSS - 06 - Flexbox"},{"content":"Flexbox makes it easy to create responsive layouts, where flex items can grow, shrink, and adjust according to the available space in the flex container.\nBy manipulating the flex-grow, flex-shrink, and flex-basis properties, we can control how items behave in the layout.\nComponents of Flexibility 1. flex-grow flex-grow determines how a flex item will grow relative to other flex items in the container.\nIt specifies the \u0026ldquo;growth factor\u0026rdquo; for an item. The flex container distributes free space among its flex items according to their flex-grow values. The greater the value of flex-grow, the more space the item will take up compared to the other items. .container { display: flex; } .item1 { flex-grow: 1; /* This item will grow to fill space */ } .item2 { flex-grow: 2; /* This item will grow twice as much as item1 */ }\rflex: 1 1 0% makes all the div grow the same amount. if flex: 2 1 0% is used in any of the other div, it will grow 2 times the size of the other.\n2. flex-shrink flex-shrink defines the \u0026ldquo;shrink factor\u0026rdquo; of a flex item. It determines how a flex item will shrink when there is not enough space in the flex container. Used to prevent overflow.\nIt specifies how much a flex item should shrink when the container is smaller than the total size of all flex items. A flex-shrink value greater than 1 will make an item shrink faster than others. A value of 0 prevents shrinking completely. .container { display: flex; } .item1 { flex-shrink: 1; /* This item will shrink normally */ } .item2 { flex-shrink: 2; /* This item will shrink twice as much as item1 */ }\rIf the total width of item1 and item2 is larger than the available space, item2 will shrink twice as fast as item1.\nThis gets applied only if the size of all flex items are larger than their parent container.\nflex-shrink: 1 is the default value, which means all items will shrink evenly. A higher number can be selected for an item to make it shrink at higher rate.\nEx: Suppose width of 3 div is set to 100 each and the parent div isn\u0026rsquo;t 300, then all div will shrink evenly to fit\nIf any specific item should not shrink below its defined size, then flex-shrink: 0 can be used. It will grow beyond this size but will not shrink below it.\n[!note] When flex-grow and flex-shrink is specified, the flex boxes wont respect the given values of width. They shrink and expand to fill the box.\nWhen flex-grow flex-shrink are 0, they will be completely inflexible.\n3. flex-basis flex-basis sets the initial size of a flex item before it starts growing or shrinking. It defines the item\u0026rsquo;s hypothetical size along the main axis (either width or height).\nIt acts like the width or height of a flex item, depending on the flex direction. The item will start at this size, and then grow or shrink based on the remaining space in the container. The flex-basis value defines the starting point for growth or shrinkage. If flex-basis is set to 0%, it means the item will ignore its natural size and shrink or grow to fill the available space. .container { display: flex; } .item1 { flex-basis: 100px; /* Item will start at 100px wide */ } .item2 { flex-basis: auto; /* Item will use its natural size */ }\rIn this example, item1 will start at 100px wide, and item2 will use its natural width based on its content.\nDefault for flex-basis is auto but in shorthand flex: 1 it will be 0%\nflex-grow, flex-shrink, and flex-basis working together When all three properties are set on a flex item, the item will:\nGrow to take up available space according to its flex-grow value. Shrink to avoid overflow according to its flex-shrink value. Start at the size specified by flex-basis. Important Note:\nIf flex-grow and flex-shrink are both set to 0, the item will not grow or shrink, and will remain at its initial size based on flex-basis. By default, flex-grow is 0, flex-shrink is 1, and flex-basis is auto. flex Shorthand The flex property is a shorthand for the three flex properties: flex-grow, flex-shrink, and flex-basis. You can use this shorthand to apply all three properties at once, making the CSS cleaner and more concise.\nBasic Values of flex 1. flex: auto .item { flex: 1 1 auto; }\rThis is equivalent to:\nflex-grow: 1; flex-shrink: 1; flex-basis: auto;\rThe item will grow and shrink as necessary, making it flexible but its size will be based on its natural size (either width or height), but it will still absorb available space if needed.\n2. flex: positive-number .item { flex: 1; /* Equivalent to flex-grow: 1, flex-shrink: 1, flex-basis: 0 */ }\rthat is flex: 1 1 0 Makes it receive the free space proportionately. This will make the item grow evenly along with others. The item will have a base size of 0, and will grow to absorb free space equally with other items that also have flex: 1.\n3. flex: initial .item { flex: initial; }\rThis is equivalent to:\nflex-grow: 0; flex-shrink: 1; flex-basis: auto;\rThe item will not grow, but it will shrink if needed to fit the container. The item will use its natural size as the basis.\n4. flex: none .item { flex: none; }\rThis is equivalent to:\nflex-grow: 0; flex-shrink: 0; flex-basis: auto;\rThe item is completely inflexible. It will maintain its natural size and will not grow or shrink, even if there is available space or overflow.\nPractical Use Cases for Flexbox Flexibility Even Growth: To have all items grow equally to fill the available space, use flex: 1 on all items. Fixed Items with Flexible Items: To make one item flexible (growing/shrinking) while others stay fixed, set flex: 1 on the flexible item and leave others with flex: none or no flex value. Prevent Shrinking: To ensure an item does not shrink below its base size, use flex-shrink: 0. Adaptive Layouts: Combine flex-grow, flex-shrink, and flex-basis to create responsive layouts that adjust based on the container\u0026rsquo;s size. Summary Property Description Example Values flex-grow Defines how much a flex item will grow relative to others 1 (grow equally), 2 (grow twice as much), 0 (no growth) flex-shrink Defines how much a flex item will shrink to prevent overflow 1 (default), 2 (shrink faster), 0 (no shrinking) flex-basis Sets the initial size of the flex item before growing/shrinking auto (natural size), 0 (ignore natural size) flex (shorthand) A shorthand for flex-grow, flex-shrink, and flex-basis 1, 0 1 auto, none (no flexibility) Resource links General Shorthand Properties Shorthand flex documentation Flex documentation\nCSS Channel Demo Video on Flexbox\n","date":"2024-11-06","id":117,"permalink":"/personal-site/docs/html-css/css/css-07-flex-flexibility/","summary":"\u003cp\u003eFlexbox makes it easy to create responsive layouts, where flex items can grow, shrink, and adjust according to the available space in the flex container.\u003cbr\u003e\nBy manipulating the \u003cstrong\u003eflex-grow\u003c/strong\u003e, \u003cstrong\u003eflex-shrink\u003c/strong\u003e, and \u003cstrong\u003eflex-basis\u003c/strong\u003e properties, we can control how items behave in the layout.\u003c/p\u003e","tags":[],"title":"CSS - 07 - Flex Flexibility"},{"content":"Flexbox operates along two main axes: the main axis and the cross axis.\nKey Flexbox Properties: justify-content: Aligns items along the main axis. (Row for row) align-items: Aligns items along the cross axis. (Column for row) Main Axis and Cross Axis Main Axis: This is the primary axis along which flex items are arranged. It is determined by the flex-direction property.\nWhen flex-direction: row (the default), the main axis runs horizontally (left to right). When flex-direction: column, the main axis runs vertically (top to bottom). Cross Axis: The axis that runs perpendicular to the main axis.\nWhen flex-direction: row, the cross axis runs vertically (top to bottom). When flex-direction: column, the cross axis runs horizontally (left to right). Changing the Orientation of Flex Items The flex-direction property defines the direction of the main axis and affects how flex items are aligned:\nflex-direction: row (default): Arranges items horizontally from left to right. flex-direction: row-reverse: Items are arranged horizontally, but from right to left. flex-direction: column: Arranges items vertically from top to bottom. flex-direction: column-reverse: Items are arranged vertically, but from bottom to top. Default Behavior of flex-direction: row Items are arranged in a row (horizontally) and take up the full width of the container. If you use flex: 1 on each item, the items will grow equally to fill the available space in the container. Behavior with flex-direction: column When flex-direction: column is set, items are stacked vertically. Here, height becomes the main dimension (instead of width). With flex: 1, the items will grow vertically and take up equal amounts of space along the column, but if flex-basis: 0 is used, the items collapse and shrink. To ensure items respect their height, use flex: 1 1 auto. Note: By default, block-level elements (like divs) in flex-direction: column will collapse to height: auto, meaning they\u0026rsquo;ll shrink to fit their content unless specified otherwise.\nGap Between Items The gap property adds spacing between flex items, similar to adding margins but specifically designed for grid and flex layouts.\ngap: 8px: Adds 8px space between all flex items. gap: 10px 20px: Adds 10px gap between rows and 20px gap between columns. This is a relatively new feature but provides a cleaner and more consistent way to manage space between items than using margins.\nUsing margin: auto for Alignment margin-left: auto;: Pushes the item to the right by taking up all available space to the left. margin-right: auto;: Pushes the item to the left by taking up all available space to the right. This is a great way to center elements (either horizontally or vertically) within a flex container.\nFlexbox Cheat Sheet Cheat Sheet for flexbox\nHere’s a quick reference for some commonly used Flexbox properties:\nGeneral Properties display: Enables Flexbox for all children\ndisplay: flex; — Applies Flexbox layout to the container. display: inline-flex; — Same as flex, but the container behaves like an inline element. flex-direction: Establishes the main axis of the flex container\nflex-direction: row; — Items are arranged horizontally (default). flex-direction: row-reverse; — Items are arranged horizontally, but reversed (right to left). flex-direction: column; — Items are arranged vertically. flex-direction: column-reverse; — Items are arranged vertically, but reversed (bottom to top). flex-wrap: Wraps items to a new line if they can\u0026rsquo;t all fit in one\nflex-wrap: nowrap; — No wrapping (all items stay in a single line). flex-wrap: wrap; — Items wrap onto multiple lines if needed. flex-wrap: wrap-reverse; — Items wrap onto multiple lines in reverse order. Alignment and Distribution justify-content: Aligns items along the main axis\njustify-content: flex-start; — Aligns items to the start of the container. justify-content: flex-end; — Aligns items to the end of the container. justify-content: center; — Centers items along the main axis. justify-content: space-evenly; — Distributes items evenly, with equal space between them. justify-content: space-between; — Distributes items with space between them, but no space at the start or end. justify-content: space-around; — Distributes items with equal space around them. align-items: Aligns items along the cross axis\nalign-items: flex-start; — Aligns items to the start of the cross axis. align-items: flex-end; — Aligns items to the end of the cross axis. align-items: center; — Centers items along the cross axis. align-items: baseline; — Aligns items based on their baseline. align-items: stretch; — Stretches items to fill the container along the cross axis. align-content: Aligns multiple lines of items (affects only when there’s more than one line)\nalign-content: flex-start; — Aligns the lines to the start of the container. align-content: flex-end; — Aligns the lines to the end of the container. align-content: center; — Centers the lines. align-content: space-between; — Distributes the lines with equal space between them. align-content: space-around; — Distributes the lines with space around them. align-content: stretch; — Stretches the lines to fill the container. For Individual Children order: integer;: Explicitly sets the order of flex items. Items with lower values will appear before those with higher values.\norder: 2; The item will appear second in the flex container. align-self: \u0026lt;alignment\u0026gt;;: Aligns individual items along the cross axis, overriding the align-items setting for that particular item.\nalign-self: flex-end; — This item will align itself at the end of the cross axis, even if the others are aligned differently. flex-grow: \u0026lt;number\u0026gt;;: Defines how much the item will grow relative to other flex items. If set to 1, it will grow to fill any available space.\nflex-grow: 1; — The item will grow to fill the available space. flex-shrink: \u0026lt;number\u0026gt;;: Defines how much the item will shrink relative to others. By default, items shrink when space is tight.\nflex-shrink: 2; — This item will shrink twice as fast as others. flex-basis: \u0026lt;value\u0026gt;;: Sets the initial size of an item before growing or shrinking.\nflex-basis: 200px; — The item starts with a size of 200px. Putting It All Together flex: 1; — This shorthand means flex-grow: 1, flex-shrink: 1, and flex-basis: 0. It allows the item to grow and shrink evenly, filling available space in the container. flex: 1 1 auto; — This allows the item to grow and shrink, but it starts at its natural size based on its content. This beautiful Interactive Guide to Flexbox Typical use cases of Flexbox is an MDN article The CSS Tricks “Guide to Flexbox” is a classic. ","date":"2024-11-06","id":118,"permalink":"/personal-site/docs/html-css/css/css-08-axes-in-flexbox/","summary":"\u003cp\u003eFlexbox operates along two main axes: the \u003cstrong\u003emain axis\u003c/strong\u003e and the \u003cstrong\u003ecross axis\u003c/strong\u003e.\u003c/p\u003e\n\u003ch3 id=\"key-flexbox-properties\"\u003e\u003cstrong\u003eKey Flexbox Properties:\u003c/strong\u003e\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e\u003ccode\u003ejustify-content\u003c/code\u003e\u003c/strong\u003e: Aligns items along the \u003cstrong\u003emain axis\u003c/strong\u003e. (Row for row)\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e\u003ccode\u003ealign-items\u003c/code\u003e\u003c/strong\u003e: Aligns items along the \u003cstrong\u003ecross axis\u003c/strong\u003e. (Column for row)\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"main-axis-and-cross-axis\"\u003e\u003cstrong\u003eMain Axis and Cross Axis\u003c/strong\u003e\u003c/h2\u003e\n\u003cp\u003e\u003cstrong\u003eMain Axis\u003c/strong\u003e: This is the primary axis along which flex items are arranged. It is determined by the \u003ccode\u003eflex-direction\u003c/code\u003e property.\u003c/p\u003e","tags":[],"title":"CSS - 08 - Axes in Flexbox"},{"content":"A utility class in CSS is a class that is designed to apply a single, specific property to an element. Unlike traditional classes that might group together several properties to style an element, utility classes focus on applying a single CSS rule, which allows you to easily reuse it across different elements.\nCreate a class with one property:\n.italic { font-style: italic; }\rApply it in the HTML:\n\u0026lt;p class=\u0026#34;italic\u0026#34;\u0026gt;This is italicized text.\u0026lt;/p\u0026gt; \u0026lt;div class=\u0026#34;italic\u0026#34;\u0026gt;This div will also have italicized text.\u0026lt;/div\u0026gt;\rAdvantages of Utility Classes:\nSimpler and more maintainable: You define the CSS once, and then apply it wherever it\u0026rsquo;s needed. Easier to remove styles: If you decide you no longer want the style, you can simply remove the utility class from the HTML element. Faster development: You can quickly add styles without having to write a whole class for each situation. To apply the same property to multiple elements, use multi-cursor editing. In many code editors (e.g., VS Code), you can select multiple occurrences of the same text (like a class name) by pressing Ctrl + D (or Cmd + D on Mac). This allows you to edit them all simultaneously.\nInheritance in CSS CSS inheritance is a concept where certain properties applied to a parent element are automatically inherited by its child elements. This can save you time and code by applying styles once to the parent, rather than individually to each child element.\nProperties That Are Inherited Some properties are inherited by default, including many related to typography and text layout. These properties typically affect how text appears across multiple elements and are inherited by child elements automatically.\nCommon inherited properties include:\ncolor font-family font-size font-weight line-height text-align text-transform How to Use Inheritance You can apply a style to a parent element, and its children will inherit those styles without needing to explicitly set them.\nFor example:\nbody { color: darkslategray; font-family: Arial, sans-serif; } h1 { font-size: 2em; } p { font-size: 1em; }\rIn this case, both the h1 and p elements will inherit the color and font-family properties from the body tag. You only need to define them once at the parent level.\nDRY (Don’t Repeat Yourself) Principle in CSS To follow the DRY principle, apply inherited properties to the parent container and let them be inherited by the child elements. This avoids redundancy and keeps your CSS more concise.\n/* Parent element */ body { color: #333; font-family: \u0026#39;Arial\u0026#39;, sans-serif; font-size: 16px; } /* Child elements inherit these properties automatically */ h1, p, div { /* No need to define color, font-family, font-size again */ }\rThis helps reduce repetition and ensures consistency across your website.\nFont Family Stack When defining fonts on a webpage, you usually provide a font stack. This is a list of fonts that the browser should use in the specified order, falling back to the next font in the stack if the first one is unavailable.\nExample of a Font Stack: body { font-family: \u0026#34;Helvetica Neue\u0026#34;, Helvetica, Arial, sans-serif; }\r\u0026ldquo;Helvetica Neue\u0026rdquo; is the preferred font. If it’s not available, the browser will use Helvetica. If that’s not available either, it will try Arial. If none of these fonts are available, it will use the default sans-serif font. This ensures that your content remains readable, even if the primary font isn\u0026rsquo;t installed on the user\u0026rsquo;s device.\nMaking a Circle from a Square In CSS, you can transform a square into a circle by using the border-radius property with a value of 50%. This works because the border-radius sets how round the corners of an element are, and a value of 50% will make all four corners fully rounded, turning the shape into a circle.\n.circle { width: 100px; height: 100px; background-color: blue; border-radius: 50%; /* Makes the square a circle */ }\r\u0026lt;div class=\u0026#34;circle\u0026#34;\u0026gt;\u0026lt;/div\u0026gt;\rThe element is 100px by 100px, making it a square. The border-radius: 50% makes the square into a perfect circle. This is a simple and powerful way to create circles in web design.\n","date":"2024-11-06","id":119,"permalink":"/personal-site/docs/html-css/css/css-09-utility-class-inheritance/","summary":"\u003cp\u003eA \u003cstrong\u003eutility class\u003c/strong\u003e in CSS is a class that is designed to apply a single, specific property to an element. Unlike traditional classes that might group together several properties to style an element, utility classes focus on applying a single CSS rule, which allows you to easily reuse it across different elements.\u003c/p\u003e","tags":[],"title":"CSS - 09 - Utility Class \u0026 Inheritance"},{"content":"CSS offers various units for defining sizes in styles.\n1. Absolute Units These units are fixed and do not change based on other elements.\nPixels (px) Usage: Good for precise layout control, especially for borders, margins, and padding. Example: .box { width: 300px; height: 200px; border: 1px solid black; }\rWhen to Use: When you need exact measurements. When to Avoid: In responsive designs where scaling is required. Points (pt) Usage: Primarily for print styles. One point is 1/72 of an inch. Example: @media print { body { font-size: 12pt; } }\rWhen to Use: In printed documents. When to Avoid: On screens, as it may not scale well. Inches (in), Centimeters (cm), Millimeters (mm) Usage: Rarely used in web design but can be useful in print styles. Example: @media print { .page { width: 8.5in; height: 11in; } }\rWhen to Use: For print layout. When to Avoid: On web pages, as they may not render as expected on screens. 2. Relative Units These units are relative to another value, typically the parent element\u0026rsquo;s size or the viewport.\nPercentages (%) Usage: Useful for responsive designs, allowing elements to scale based on their container. Example: .container { width: 80%; margin: 0 auto; }\rWhen to Use: For fluid layouts. When to Avoid: When you need fixed sizes for elements. Viewport Units Viewport Width (vw): 1vw is equal to 1% of the viewport\u0026rsquo;s width. Viewport Height (vh): 1vh is equal to 1% of the viewport\u0026rsquo;s height. Example: .full-screen { width: 100vw; height: 100vh; }\rWhen to Use: For full-screen sections or elements. When to Avoid: In nested elements where context changes (e.g., within a scrolling container). Em (em) Usage: Relative to the font size of the element, good for font sizes and spacing. Example: .text { font-size: 2em; /* 2 times the font size of the parent */ }\rWhen to Use: For scalable typography. When to Avoid: In complex nested elements, as it can lead to unexpected sizes. Rem (rem) Usage: Relative to the root (html) font size, ensuring consistency across the site. Example: html { font-size: 16px; /* Base size */ } .text { font-size: 1.5rem; /* 24px */ }\rWhen to Use: For consistent scaling across different components. When to Avoid: When needing local context adjustments. Ch Usage: Relative to the width of the \u0026ldquo;0\u0026rdquo; character in the current font. Example: .input { width: 20ch; /* Width of 20 characters */ }\rWhen to Use: For inputs where character length matters. When to Avoid: For elements where the character width varies greatly. Ex Usage: Relative to the height of the lowercase \u0026ldquo;x\u0026rdquo; in the current font. Example: .text { font-size: 2ex; /* Height based on the font */ }\rWhen to Use: Rarely; not widely supported across browsers. When to Avoid: Due to inconsistencies in rendering. 3. Flex and Grid Units Flexbox:\nFlex-grow: Defines the ability for a flex item to grow. Example: .container { display: flex; } .item { flex-grow: 1; /* Item can grow to fill space */ }\rWhen to Use: When creating flexible layouts. When to Avoid: When exact sizes are needed. CSS Grid:\nFractional Units (fr): Represents a fraction of the available space. Example: .grid { display: grid; grid-template-columns: 1fr 2fr; /* 1/3 and 2/3 of available space */ }\rWhen to Use: For complex, responsive grid layouts. When to Avoid: In simple layouts where other units suffice. 4. CSS Functions calc() Usage: Allows for dynamic calculations. You can mix different units. Example: .box { width: calc(100% - 50px); /* Dynamic width */ }\rWhen to Use: For dynamic layouts. When to Avoid: When not needed for simple cases. min() and max() Usage: Set constraints on sizes. Example: .box { width: min(100%, 800px); /* Width won\u0026#39;t exceed 800px */ }\rWhen to Use: To create responsive designs with limits. When to Avoid: When fixed sizes are required. clamp() Usage: Sets a value that adjusts between a defined minimum and maximum. Example: .text { font-size: clamp(1rem, 2vw, 3rem); /* Responsive font size */ }\rWhen to Use: For responsive typography. When to Avoid: In static designs where sizes must remain unchanged. Conclusion Choosing the right sizing unit in CSS can significantly impact your layout\u0026rsquo;s responsiveness and user experience. Using relative units like em, rem, and viewport units can help create flexible designs, while absolute units like px are best for fixed layouts.\n","date":"2024-11-07","id":120,"permalink":"/personal-site/docs/html-css/css/css_resource/css-04.1-size-units/","summary":"\u003cp\u003eCSS offers various units for defining sizes in styles.\u003c/p\u003e\n\u003ch2 id=\"1-absolute-units\"\u003e1. Absolute Units\u003c/h2\u003e\n\u003cp\u003eThese units are fixed and do not change based on other elements.\u003c/p\u003e","tags":[],"title":"CSS - 04.1 - Size Units"},{"content":"Colors in CSS can be specified by the following methods:\nPredefined/Cross-browser color names With the currentcolor keyword Hexadecimal colors Hexadecimal colors with transparency RGB colors RGBA colors HSL colors HSLA colors CSS Custom Variable Gradients CSS Color Values Overview Colors in CSS can be specified using various methods, allowing designers flexibility and precision in styling elements. Here’s a breakdown of these methods:\n1. Predefined/Cross-browser Color Names CSS supports 140 predefined color names (e.g., blue, red, coral, brown), which are widely recognized across browsers.\nExample: #p1 { background-color: blue; } /* Blue background */ #p2 { background-color: red; } /* Red background */ #p3 { background-color: coral; } /* Coral background */ #p4 { background-color: brown; } /* Brown background */\r2. The currentcolor Keyword The currentcolor keyword refers to the value of the color property of an element, ensuring that properties like borders can inherit the text color.\nExample: #myDIV { color: blue; /* Blue text color */ border: 10px solid currentcolor; /* Blue border color */ }\rThe border of Div border is blue because the div color is blue.\n3. Hexadecimal Colors Hexadecimal colors are defined using the format #RRGGBB, where RR, GG, and BB represent the intensity of red, green, and blue components, respectively.\nFormat: #RRGGBB or #RGB Example: #p1 { background-color: #ff0000; } /* Red */ #p2 { background-color: #00ff00; } /* Green */ #p3 { background-color: #0000ff; } /* Blue */ .box { background-color: #3498db; /* A specific shade of blue */ }\r4. Hexadecimal Colors With Transparency To add transparency to a hexadecimal color, you can use the format #RRGGBBAA, where AA specifies the alpha channel.\nExample: #p1a { background-color: #ff000080; } /* Red with 50% transparency */ #p2a { background-color: #00ff0080; } /* Green with 50% transparency */ #p3a { background-color: #0000ff80; } /* Blue with 50% transparency */\r5. RGB Colors An RGB color is specified with the rgb() function, using integers (0-255) or percentage values.\nFormat: rgb(red, green, blue) Example: #p1 { background-color: rgb(255, 0, 0); } /* Red */ #p2 { background-color: rgb(0, 255, 0); } /* Green */ #p3 { background-color: rgb(0, 0, 255); } /* Blue */ .box { background-color: rgb(52, 152, 219); /* A specific shade of blue */ }\r6. RGBA Colors RGBA extends RGB by adding an alpha channel for opacity. An RGBA color is specified with the rgba() function: rgba(red, green, blue, alpha)\nThe alpha parameter is a number between 0.0 (fully transparent) and 1.0 (fully opaque).\nExample: #p1 { background-color: rgba(255, 0, 0, 0.3); } /* Red with 30% opacity */ #p2 { background-color: rgba(0, 255, 0, 0.3); } /* Green with 30% opacity */ #p3 { background-color: rgba(0, 0, 255, 0.3); } /* Blue with 30% opacity */\r7. HSL Colors HSL stands for hue, saturation, and lightness, offering a cylindrical-coordinate representation of colors.\nhsl(hue, saturation, lightness)\nHue is a degree on the color wheel (from 0 to 360) - 0 (or 360) is red, 120 is green, 240 is blue.\nSaturation is a percentage value; 0% means a shade of gray and 100% is the full color.\nLightness is also a percentage; 0% is black, 100% is white.\nExample: #p1 { background-color: hsl(120, 100%, 50%); } /* Green */ #p2 { background-color: hsl(120, 100%, 75%); } /* Light Green */ #p3 { background-color: hsl(120, 100%, 25%); } /* Dark Green */ #p4 { background-color: hsl(120, 60%, 70%); } /* Pastel Green */\rUse: For intuitive adjustments to colors based on hue, saturation, and lightness.\n8. HSLA Colors HSLA extends HSL with an alpha channel for opacity. hsla(hue, saturation, lightness, alpha)\nExample: #p1 { background-color: hsla(120, 100%, 50%, 0.3); } /* Green with 30% opacity */ #p2 { background-color: hsla(120, 100%, 75%, 0.3); } /* Light Green with 30% opacity */ #p3 { background-color: hsla(120, 100%, 25%, 0.3); } /* Dark Green with 30% opacity */ #p4 { background-color: hsla(120, 60%, 70%, 0.3); } /* Pastel Green with 30% opacity */\r9. CSS Custom Properties (Variables) Usage: Define reusable color values throughout your CSS. Example: :root { --main-color: #3498db; /* Define a custom property */ } .box { background-color: var(--main-color); /* Use the custom property */ }\rWhen to Use: For maintaining consistent colors across a site and easy updates. When to Avoid: If you do not need to reuse colors or your project is very small. 10. Gradients Format: linear-gradient() or radial-gradient() Example (Linear): .box { background: linear-gradient(to right, #3498db, #8e44ad); /* Horizontal gradient */ }\rExample (Radial): .box { background: radial-gradient(circle, #3498db, #8e44ad); /* Circular gradient */ }\rWhen to Use: For backgrounds that require a blend of colors. When to Avoid: If the design is too busy or if it affects readability. ","date":"2024-11-07","id":121,"permalink":"/personal-site/docs/html-css/css/css_resource/css-04.2-color-values/","summary":"\u003cp\u003eColors in CSS can be specified by the following methods:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003ePredefined/Cross-browser color names\u003c/li\u003e\n\u003cli\u003eWith the \u003ccode\u003ecurrentcolor\u003c/code\u003e keyword\u003c/li\u003e\n\u003cli\u003eHexadecimal colors\u003c/li\u003e\n\u003cli\u003eHexadecimal colors with transparency\u003c/li\u003e\n\u003cli\u003eRGB colors\u003c/li\u003e\n\u003cli\u003eRGBA colors\u003c/li\u003e\n\u003cli\u003eHSL colors\u003c/li\u003e\n\u003cli\u003eHSLA colors\u003c/li\u003e\n\u003cli\u003eCSS Custom Variable\u003c/li\u003e\n\u003cli\u003eGradients\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003ch1 id=\"css-color-values-overview\"\u003eCSS Color Values Overview\u003c/h1\u003e\n\u003cp\u003eColors in CSS can be specified using various methods, allowing designers flexibility and precision in styling elements. Here’s a breakdown of these methods:\u003c/p\u003e","tags":[],"title":"CSS - 04.2 - Color Values"},{"content":"","date":"2024-11-07","id":122,"permalink":"/personal-site/docs/html-css/css/css_resource/","summary":"","tags":[],"title":"CSS Reference"},{"content":"Keyboard Shortcuts Ctrl + P: Open Command Palette for search. Ctrl + Shift + P: to toggle left panel (Custom short key) Alt: Create multiple cursor points by holding down. Alt + Shift: Select multiple sections in different areas. Linking and Tagging Tags: #Tag\nLinking Notes:\nBasic Link: [[Note Name]] — Creates a new file if the note doesn’t exist. Alias Naming: [[link | name]] — Use a pipe | to create an alias. Header Links: [[Obsidian#Header 1 | Alias]] — Link to specific headers in a note. Tagged Sections: [[Obsidian#^352532 | toHideTheNumbers]] — Using ^ to tag any small section. Code and Comments Inline Code: code line\nCode Block:\ncode block with language insertions\rLinks:\nExternal: [name](URL) Embed Image: ![name](URL) Example: ![Google](https://www.google.com) Hover Text: [google](https://www.google.com \u0026quot;To bring up a pop up while hovering\u0026quot;)\nInformation Block:\n[!info]\nInformation Block\nFormatting text and links:\nObsidian Help\nNote Block:\n[!note] : Name\nDescription goes here.\nInline Comments: %% comments visible only in editing view %%\nText Formatting Highlighting: ==highlighting== Strikethrough: ~~Strike through~~ Lists and Checklists Unordered Lists: Start with +, -, or *\nOrdered Lists: Start with numbers\nOne Nested one Nested two Two Three Checklist:\n- [ ] for an empty checkbox - [x] for a checked box Example: Task 1 Task 2 Footnotes Creating Footnotes:\nUse [^1] to reference a footnote and [^1]: for the footnote text. Example: Footnote 1 Inline Method: Use text^[footnote] for inline footnotes.\nExample: This is a footnote^[this is the text for the footnote]. Order of numbers can be changed and numbers will change accordingly\nFoot note 1 Another one 2\nImages Embedding Images: ![link text](URL) ![link text](URL \u0026quot;Alt text\u0026quot;) Tables Creating Tables: Use | to separate columns, with --- under headers. Name Column Header Markdown to HTML Conversion Markdown can be converted to HTML for webpages. Check out: Markdown Guide Static Site Generators: Jekyll: Popular generator for building HTML websites from Markdown. GitHub Pages: Offers free hosting for Jekyll sites. Line Breaks To create a line break, leave two or more spaces after a paragraph. Or \u0026lt;br /\u0026gt; can be used. Recommended Tools and Plugins Markdown Editors:\nGhostwriter (cross-platform) Markdown Monster (Windows) ReText (Linux) VS Code Plugins:\nMarkdown Extended Prettier - Code Formatter Markdown Shortcuts Markdown Preview Enhanced Linked to the footnote\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nanother link\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"2024-10-22","id":123,"permalink":"/personal-site/docs/tools/obsidian/","summary":"\u003ch2 id=\"keyboard-shortcuts\"\u003eKeyboard Shortcuts\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e\u003ccode\u003eCtrl + P\u003c/code\u003e\u003c/strong\u003e: Open Command Palette for search.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e\u003ccode\u003eCtrl + Shift + P\u003c/code\u003e\u003c/strong\u003e:  to toggle left panel (Custom short key)\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e\u003ccode\u003eAlt\u003c/code\u003e\u003c/strong\u003e: Create multiple cursor points by holding down.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e\u003ccode\u003eAlt + Shift\u003c/code\u003e\u003c/strong\u003e: Select multiple sections in different areas.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"linking-and-tagging\"\u003eLinking and Tagging\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003eTags\u003c/strong\u003e: \u003ccode\u003e#Tag\u003c/code\u003e\u003c/p\u003e","tags":[],"title":"Obsidian"},{"content":"Useful Links VS Code Documentation Keyboard Shortcuts Reference Shortcuts in the Editor Side Bar Toggles Ctrl + B : Toggle side bar open and close Ctrl + Shift + E : Open Explorer Ctrl + Shift + F : Open Search Ctrl + Shift + G : Open Source Control (Git) Ctrl + Shift + D : Open Debug Menu Ctrl + Shift + X : Open Extensions General Shortcuts Ctrl + Shift + P or Fn + F1 : Open Command Palette (includes Zen Mode, Minimap) Ctrl + P : Quick file search Ctrl + , : Open Settings Ctrl + Shift + N : New VS Code window Ctrl + \\ : Split Editor File Handling Ctrl + W : Close current file/editor Ctrl + Shift + T : Reopen last closed editor Ctrl + Tab or Ctrl + PgUp/PgDw : Switch through open files Ctrl + Shift + Tab : Reverse switch through open files Text Selection Ctrl + C : Copy the entire line where the cursor is located Ctrl + D : Select the exact word (can be used to select all instances when pressed multiple times) Home / End : Go to the beginning or end of the current line Ctrl + Space : Trigger suggestions Ctrl + L : Select current line Ctrl + Shift + L : Select all instances of the current selection Ctrl + Shift + H : Replace in file Ctrl + F : Find Ctrl + H : Replace Display F11 : Toggle full screen Ctrl + =/- : Zoom in or out Ctrl + Shift + C : Open Command Prompt/Terminal Plugins and Extensions Essential Extensions IntelliSense: Provides smart completions based on variable types, function definitions, and imported modules. Emmet: Offers shorthand syntax for HTML and CSS, expanding into full code snippets. Cascadia Code: A font family from Microsoft designed for coding, includes ligatures. Font Ligatures: Turns groups of characters into a single character for improved readability. Live Server: Launch a local development server with live reload for HTML/CSS previews. Markdown Plugins Markdown Extended: Enhances Markdown editing capabilities. Prettier: Automatically formats code for consistency. Markdown Shortcuts: Provides keyboard shortcuts specifically for Markdown editing. Markdown Preview Enhanced: A powerful Markdown preview tool with extra features. Custom Snippets Create snippets that translate to predefined code, customizable for individual programming languages. This feature is beneficial for advanced users who want to streamline their coding process. Advanced Customization Edit in JSON: Customize settings, shortcuts, and editor behavior in a JSON file for more granular control. Text Wrap: Configure text wrapping preferences. Cursor Customization: Set conditions for cursor behavior in specific file types or locations. Setting Sync: Sync settings, extensions, and keybindings across devices for a consistent development environment. Topics to Consider Integrated Debugging: Setting breakpoints and inspecting variables. Remote Development: Using the Remote Development extensions to work with remote servers or containers. Version Control Integration: How to effectively use Git within VS Code. Task Runner: Automate repetitive tasks like building or running scripts. Live Share: Collaborate with others in real-time through Live Share sessions. ","date":"2024-10-22","id":124,"permalink":"/personal-site/docs/tools/vs-code/","summary":"\u003ch2 id=\"useful-links\"\u003eUseful Links\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e\u003ca href=\"https://code.visualstudio.com/docs\"\u003eVS Code Documentation\u003c/a\u003e\u003c/strong\u003e\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e\u003ca href=\"https://go.microsoft.com/fwlink/?linkid=832144\"\u003eKeyboard Shortcuts Reference\u003c/a\u003e\u003c/strong\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"shortcuts-in-the-editor\"\u003eShortcuts in the Editor\u003c/h2\u003e\n\u003ch3 id=\"side-bar-toggles\"\u003eSide Bar Toggles\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eCtrl + B\u003c/code\u003e  : Toggle side bar open and close\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eCtrl + Shift + E\u003c/code\u003e  : Open Explorer\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eCtrl + Shift + F\u003c/code\u003e  : Open Search\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eCtrl + Shift + G\u003c/code\u003e  : Open Source Control (Git)\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eCtrl + Shift + D\u003c/code\u003e  : Open Debug Menu\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eCtrl + Shift + X\u003c/code\u003e  : Open Extensions\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"general-shortcuts\"\u003eGeneral Shortcuts\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eCtrl + Shift + P\u003c/code\u003e  or \u003ccode\u003eFn + F1\u003c/code\u003e  : Open Command Palette (includes Zen Mode, Minimap)\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eCtrl + P\u003c/code\u003e  : Quick file search\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eCtrl + ,\u003c/code\u003e  : Open Settings\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eCtrl + Shift + N\u003c/code\u003e  : New VS Code window\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eCtrl + \\\u003c/code\u003e  : Split Editor\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"file-handling\"\u003eFile Handling\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eCtrl + W\u003c/code\u003e  : Close current file/editor\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eCtrl + Shift + T\u003c/code\u003e  : Reopen last closed editor\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eCtrl + Tab\u003c/code\u003e  or \u003ccode\u003eCtrl + PgUp/PgDw\u003c/code\u003e  : Switch through open files\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eCtrl + Shift + Tab\u003c/code\u003e  : Reverse switch through open files\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"text-selection\"\u003eText Selection\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eCtrl + C\u003c/code\u003e  : Copy the entire line where the cursor is located\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eCtrl + D\u003c/code\u003e  : Select the exact word (can be used to select all instances when pressed multiple times)\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eHome / End\u003c/code\u003e  : Go to the beginning or end of the current line\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eCtrl + Space\u003c/code\u003e  : Trigger suggestions\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eCtrl + L\u003c/code\u003e  : Select current line\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eCtrl + Shift + L\u003c/code\u003e  : Select all instances of the current selection\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eCtrl + Shift + H\u003c/code\u003e  : Replace in file\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eCtrl + F\u003c/code\u003e  : Find\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eCtrl + H\u003c/code\u003e  : Replace\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"display\"\u003eDisplay\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eF11\u003c/code\u003e  : Toggle full screen\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eCtrl + =/-\u003c/code\u003e  : Zoom in or out\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eCtrl + Shift + C\u003c/code\u003e  : Open Command Prompt/Terminal\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"plugins-and-extensions\"\u003ePlugins and Extensions\u003c/h2\u003e\n\u003ch3 id=\"essential-extensions\"\u003eEssential Extensions\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eIntelliSense\u003c/strong\u003e: Provides smart completions based on variable types, function definitions, and imported modules.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eEmmet\u003c/strong\u003e: Offers shorthand syntax for HTML and CSS, expanding into full code snippets.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eCascadia Code\u003c/strong\u003e: A font family from Microsoft designed for coding, includes ligatures.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eFont Ligatures\u003c/strong\u003e: Turns groups of characters into a single character for improved readability.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eLive Server\u003c/strong\u003e: Launch a local development server with live reload for HTML/CSS previews.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"markdown-plugins\"\u003eMarkdown Plugins\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eMarkdown Extended\u003c/strong\u003e: Enhances Markdown editing capabilities.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003ePrettier\u003c/strong\u003e: Automatically formats code for consistency.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eMarkdown Shortcuts\u003c/strong\u003e: Provides keyboard shortcuts specifically for Markdown editing.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eMarkdown Preview Enhanced\u003c/strong\u003e: A powerful Markdown preview tool with extra features.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"custom-snippets\"\u003eCustom Snippets\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eCreate snippets that translate to predefined code, customizable for individual programming languages. This feature is beneficial for advanced users who want to streamline their coding process.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"advanced-customization\"\u003eAdvanced Customization\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eEdit in JSON\u003c/strong\u003e: Customize settings, shortcuts, and editor behavior in a JSON file for more granular control.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eText Wrap\u003c/strong\u003e: Configure text wrapping preferences.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eCursor Customization\u003c/strong\u003e: Set conditions for cursor behavior in specific file types or locations.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eSetting Sync\u003c/strong\u003e: Sync settings, extensions, and keybindings across devices for a consistent development environment.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"topics-to-consider\"\u003eTopics to Consider\u003c/h2\u003e\n\u003col\u003e\n\u003cli\u003e\u003cstrong\u003eIntegrated Debugging\u003c/strong\u003e: Setting breakpoints and inspecting variables.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eRemote Development\u003c/strong\u003e: Using the Remote Development extensions to work with remote servers or containers.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eVersion Control Integration\u003c/strong\u003e: How to effectively use Git within VS Code.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eTask Runner\u003c/strong\u003e: Automate repetitive tasks like building or running scripts.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eLive Share\u003c/strong\u003e: Collaborate with others in real-time through Live Share sessions.\u003c/li\u003e\n\u003c/ol\u003e","tags":[],"title":"VS Code"},{"content":"Introduction to Git Pro Git Book: A comprehensive guide to Git. Basic Setup git --version # Check Git version # Change default branch to main git config --global init.defaultBranch main git config --global user.name \u0026#34;Your Name\u0026#34; # Set username git config --get user.name # Retrieve username git config --global user.email \u0026#34;mail@mail.com\u0026#34; # Set email git config --get user.email # Retrieve email git config --global color.ui auto # Enable colored output git config --global pull.rebase false # Disable rebase on pull\rgit pull: This command is used to fetch changes from a remote repository and merge them into your current branch. By default, it performs a merge. Rebasing: This is an alternative to merging where Git re-applies your local changes on top of the changes fetched from the remote.\nConnecting Git to GitHub with SSH Setting Up SSH Key ls ~/.ssh/id_ed25519.pub # Check if SSH key exists ssh-keygen -t ed25519 # Create a new SSH key # Press Enter for default location and no passphrase cat ~/.ssh/id_ed25519.pub # Copy the SSH key\rAdding SSH Key to GitHub Go to Settings → SSH and GPG keys. Click New SSH key and paste the SSH key. Basic Git Commands git status # Show tracked, untracked, staged files git add [file name] # Add specific file to staging area git add . # Add all files to staging area git commit -m \u0026#34;message\u0026#34; # Commit staged files with a message git log # Show commit history q # Exit log view if it\u0026#39;s too long git push # Push changes to the remote repository git push origin main # Push to the main branch\rUsing Git in VS Code Open the terminal in VS Code: code . To set VS Code as the default editor for commit messages: git config --global core.editor \u0026#34;code --wait\u0026#34;\rGitHub to Git Creating a New Repository: In GitHub, click New repository. Select Code, then copy the SSH link (not the HTTP link). Cloning a Repository mkdir repos # Create a new directory cd repos # Navigate to that directory git clone [paste the ssh link] # Clone the repo from GitHub cd [the new folder] # Navigate into the cloned folder git remote -v # Show the linked GitHub repository\rPushing Local Repository to GitHub git init # Initialize a new Git repository git add . # Stage all files git commit -m \u0026#34;message\u0026#34; # Commit the changes # Create an empty repository on GitHub (without README or license) git remote add origin [ssh key] # Link to the GitHub repository git branch -M main # Rename current branch to main (if necessary) git push -u origin main # Push changes to GitHub\rCommit Messages Follow the seven rules of a great Git commit message:\nSeparate subject from body with a blank line. Limit subject line to 50 characters. Capitalize the subject line. Do not end the subject line with a period. Use the imperative mood in the subject line. Wrap the body at 72 characters. Explain what and why in the body, not how. Tutorial Video: Conventional Commits\nBranches Use git branch to see all branches. To create a new branch: git branch \u0026lt;branch_name\u0026gt; # Create a new branch git checkout \u0026lt;branch_name\u0026gt; # Switch to the branch git checkout -b \u0026lt;branch_name\u0026gt; # Create and switch to a new branch git checkout main # Switch back to the main branch\rMerging Branches # Move to the branch you want to merge into git merge \u0026lt;branch_name\u0026gt; # Merge changes from \u0026lt;branch_name\u0026gt;\rMerge Conflicts Occur when changes to the same line in a file are made in different branches. Deleting a Branch git branch -d \u0026lt;branch_name\u0026gt; # Delete a merged branch git branch -D \u0026lt;branch_name\u0026gt; # Force delete an unmerged branch\rPushing a New Branch to GitHub git checkout -b \u0026lt;branch_name\u0026gt; # Create and switch to the new branch git push origin \u0026lt;branch_name\u0026gt; # Push the branch to GitHub git push -u origin \u0026lt;branch_name\u0026gt; # Link the local branch with the remote one\rChanging to an Old Commit git log --oneline # View commit history # Get the commit ID from the log git reset --hard [9digitId] # Reset to that commit (deletes progress) git checkout -b old-state [id] # Create a new branch at the old commit git revert [commit_id] # Revert a specific commit\rAdditional Topics to Explore Git Workflow Models:\nOverview of workflows like Git Flow, GitHub Flow, etc. Remote Management:\nHow to manage multiple remotes and their configurations. Stashing Changes:\nUsing git stash to temporarily save changes. Rebasing:\nIntroduction to rebasing vs. merging and its implications. Using Tags:\nHow to create and manage tags for releases. Working with Submodules:\nOverview of using submodules for managing dependencies. Collaborative Work:\nBest practices for collaborating on GitHub (pull requests, code reviews). Git Hooks:\nIntroduction to hooks for automating tasks at different points in the Git workflow. Git GUI Clients:\nOverview of popular GUI clients for Git and their features. Troubleshooting Common Issues:\nTips for resolving common Git issues (merge conflicts, detached HEAD, etc.). ","date":"2024-10-22","id":125,"permalink":"/personal-site/docs/tools/git-github/","summary":"\u003ch2 id=\"introduction-to-git\"\u003eIntroduction to Git\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e\u003ca href=\"https://git-scm.com/book/en/v2/Getting-Started-About-Version-Control\"\u003ePro Git Book\u003c/a\u003e\u003c/strong\u003e: A comprehensive guide to Git.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"basic-setup\"\u003eBasic Setup\u003c/h2\u003e\n\r\n\r\n\r\n\u003cdiv class=\"expressive-code\"\u003e\r\n  \u003cfigure class=\"frame is-terminal not-content\"\u003e\r\n  \u003cfigcaption class=\"header\"\u003e\r\n    \u003cspan class=\"title\"\u003e\u003c/span\u003e\r\n  \u003c/figcaption\u003e\r\n  \u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003egit --version  \u003cspan class=\"c1\"\u003e# Check Git version\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# Change default branch to main\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003egit config --global init.defaultBranch main\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003egit config --global user.name \u003cspan class=\"s2\"\u003e\u0026#34;Your Name\u0026#34;\u003c/span\u003e  \u003cspan class=\"c1\"\u003e# Set username\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003egit config --get user.name                   \u003cspan class=\"c1\"\u003e# Retrieve username\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003egit config --global user.email \u003cspan class=\"s2\"\u003e\u0026#34;mail@mail.com\u0026#34;\u003c/span\u003e  \u003cspan class=\"c1\"\u003e# Set email\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003egit config --get user.email                   \u003cspan class=\"c1\"\u003e# Retrieve email\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003egit config --global color.ui auto             \u003cspan class=\"c1\"\u003e# Enable colored output\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003egit config --global pull.rebase \u003cspan class=\"nb\"\u003efalse\u003c/span\u003e         \u003cspan class=\"c1\"\u003e# Disable rebase on pull\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\r\n  \u003c/figure\u003e\r\n\u003c/div\u003e\r\n\u003cp\u003egit pull: This command is used to fetch changes from a remote repository and merge them into your current branch. By default, it performs a merge.\nRebasing: This is an alternative to merging where Git re-applies your local changes on top of the changes fetched from the remote.\u003c/p\u003e","tags":[],"title":"Git \u0026 Github"},{"content":"","date":"2024-10-22","id":126,"permalink":"/personal-site/docs/tools/","summary":"","tags":[],"title":"Tools \u0026 Accesories"},{"content":"An Operating System (OS) is a collection of programs that work together as a whole to support the user’s interaction with the computer by managing hardware resources and running processes.\nOperating systems typically comprise many different programs, with the heart of the OS being a single program called the kernel.\nThe kernel is loaded into memory when the computer boots and remains resident in memory until the system shuts down. Its role is to handle process and resource management, among other tasks. The kernel may call upon other OS components to complete certain tasks, which are loaded and run as needed. Users may also call upon some of these OS components, which are also loaded and run as needed. The Operating System Kernel The kernel is responsible for most of the important tasks of the OS. There are three primary types of kernels:\nMonolithic Kernel Microkernel Hybrid Kernel Monolithic Kernel A monolithic kernel is a single program that operates solely within the computer’s privileged mode and its own memory(address) space.\nCommunication between the user space (running applications) and the kernel space is done via system calls.\nA system call invokes a specific portion of the OS kernel. Upon receiving a system call, the kernel switches from user mode to privileged mode.\nThe kernel ensures that the user’s request is legitimate and that the appropriate access level is granted for the request to be carried.\nEarly Operating Systems used a monolithic kernel, which was small due to limited memory and fewer system resources. As computing capabilities grew, operating systems became more complex, and so did their kernels.\nMicrokernel In a microkernel:\nThe kernel is smaller and simpler than the monolithic type. Communication is similar to the monolithic kernel, but the kernel relies on servers to handle various tasks. System calls occur between the kernel and servers, as well as between application software and servers. Among the server components are: File system servers, Network servers, Display servers, User interface servers, Device driver communication servers\nThe kernel retains responsibility for: Process scheduling, Memory management (including virtual memory), Interprocess communication between OS components.\nHybrid Kernel The hybrid kernel is a compromise between monolithic and microkernels. The kernel is kept small, but additional server-like components are added:\nServer components run in kernel mode but typically in the user’s address space. This allows processes to call upon the servers more easily than in the microkernel approach, bypassing some time-consuming system calls. Linux Kernel: Modular Monolithic Kernel: Monolithic kernels can be broken into modules, which are loaded as needed. This modular approach allows Linux to remain lightweight based on the modules loaded. Linux and System Calls: In Linux, a system call isn’t directly intercepted by the kernel. Instead, it’s handled by a wrapper function, which places the arguments of the function call into appropriate hardware registers before the kernel switches from user mode to privileged mode. Portability: Linux is a portable OS. It is not written for any specific hardware but can run on various platforms. Why Linux? Advantages:\nFree: Linux is available at no cost. Open-source: The code is open, allowing users to enhance and modify it. More control over the OS: Provides greater administrative control for system management. Educational value: Helps users learn more about computers and operating systems. Community-driven: Quick fixes for major issues from the community. Portable: Can be used on various hardware platforms. Disadvantages:\nNo commercial support: Organizations might face challenges without guaranteed support. Lagging behind on features and security: Sometimes updates and fixes may be slower compared to proprietary systems. UNIX systems have the same system calls which are described in the POSIX specification.\nFeatures of UNIX Multiuser System:\nMultitasking Sytem:\nBuilding block Approach : Hundreds of command which perform one simple job. Commands can be connected with pipe to manipulate data which are called as filters.\nIt is through Pipes UNIX implements the \u0026ldquo;small is beautiful\u0026rdquo; philosophy. UNIX tools are designed with a requirement that the output of one tool be used as input to another. That\u0026rsquo;s why the architecture of UNIX had to make commands that throw out excessive verbiage and clutter the output - which is the reason why UNIX Programs are not interactive.\nIf the output of ls contained headers or prompted users for a specific information, this output couldn\u0026rsquo;t have been used as useful input to any other commands.\nBy interconnecting various tools, there can be a large combination of usages.\nRoles of OS Kernel Role Meaning Example Auditing and Accounting Keep track of users logged in and resources allocated; log events. Auditing and logging programs. Device Management Ability to add, remove, and interface with peripheral devices. Mounting disk drives, adding devices via USB. File Management Ability to manage files and directories: open, close, create, save, rename, and copy. File operations like opening, creating, renaming files. Interprocess Communication Sharing information between running processes. Signals and message-passing between processes. Interrupt Handling Handling device interrupts and running situations. Timer interrupts, I/O interrupts, interprocess interrupts. Memory Management Allocation and deallocation of memory; protecting memory areas. Virtual memory, demand paging, memory compaction. Process Management Starting new processes, monitoring running processes, and handling errors. Multitasking, process scheduling, thread management. Protection Ensuring processes can only access their own memory. User account management, user mode vs privileged mode. Resource Management Granting access to resources while maintaining mutually exclusive access. Synchronization mechanisms, deadlock handling. Scheduling Determining the order of process execution. Priority scheduling, round-robin scheduling. Security Extending protection across the network. Encryption, access control. User Interface Providing an interface for users to interact with the OS, applications, and hardware. GUI, CLI, menu-driven interfaces. ","date":"2024-12-31","id":127,"permalink":"/personal-site/docs/bash-linux/linux_os/linux-os-01-linux-kernel/","summary":"\u003cp\u003eAn \u003cstrong\u003eOperating System (OS)\u003c/strong\u003e is a collection of programs that work together as a whole to support the user’s interaction with the computer by managing hardware resources and running processes.\u003c/p\u003e","tags":[],"title":"Linux OS - 01 - Linux Kernel"},{"content":"","date":"2024-12-29","id":128,"permalink":"/personal-site/docs/bash-linux/linux_os/","summary":"","tags":[],"title":"Linux OS"},{"content":"","date":"2024-10-22","id":129,"permalink":"/personal-site/docs/bash-linux/","summary":"Reference points of Linux Bash scripting","tags":[],"title":"Linux - Bash \u0026 OS"},{"content":"Two simplest entities support the UNIX System - file and process.\nA File is just an array of bytes that can virtually contain anything. It is also related to other files by being part of a single hierarchical structure. File is located with reference to a predetermined place.\nProcess is the name given to a file when it is executed as a program.\nProcess is simply the \u0026ldquo;time image\u0026rdquo; of an executable file. It also belongs to a separate hierarchical structure with parents, children and grandchildren.\nProgram is a static entity.\nA process is a running program, it has a state which changes over time. The programs are identical but the processes all differ because each will have its own unique state.\nA process is described in many ways,\nIs it currently being run by the CPU or waiting?\nif waiting, where?\nWhat are the values of its variables? where in memory is it stored?\nIf in memory, what resources does it have assigned to it?\nThe answers to these questions are just some of the ways we describe a process.\nWhenever a process runs, Linux kernel keeps track of it through process ID (PID).\nThe first process the kernel starts after it is loaded is systemd.\nsystemd is responsible for for starting the run-time environment and then monitering the environment.\nsystemd is given PID of 1, each new process gets the next available PID.\nIn Linux, a process can only be created by another process (except systemd).\nCreating process is referred to as parent and created process is child where parent process spawns the child process.\nSpawning of a process utilizes the system call of the parent process to the Linux kernel.\n***Several forms of child process creation system calls. ***\nfork() Creates a duplicate process of the parent but with its own PID, own memory and its own resources. Parent and child an run concurrently.\nvfork() Same as fork except parent is temporarily suspended and child might be permitted to use the parent\u0026rsquo;s memory space.\nclone() Like fork except there is more control over the child process produced with respect to what is duplicated and what is shared between parent and child.\nexec() take an existing process and replace its image (executable code) with new image.\nwait() Suspended parent process to wait for an event of a child process.\nThe current process (parent) invokes one of the system call function like fork() clone(). There are several different clone systems clone() clone2() clone3()\nThe difference between clone fork vfork is how much will be shared between the parent and the child.\nvfork() suspends the parent process while the child runs.\nAnother option is to create a child with clone or fork and then have the parent wait\nThere are several wait systems,\nwith wait() the parent is suspended till one child terminates.\nwith waitid() waitpid() the parent suspends until the child with the specified PID terminates.\nThese can be modified to make the parent resume under different circumstances also. This makes wait() more flexible than vfork()\nexec() fork, clone, vfork create a child that has the same executable code as the parent. (calling wc from bash, the child created by fork is still bash, here exec replaces the child code with wc) exec replaces the parents code with the child with the image of the program the child should be.\nThere are several versions of exec() known as exec family of system calls. execl() execle() execlp() execv() execve() and execvp(). The difference between them is the parameters passed to them.\nIt is common to pair up fork() and exec()\nCPU stores information about the running process via its registers. These register values changes as the process executes. The program counter (PC) stores the address of the next instruction to fetch from memory. The Instruction register (IR) stores the current instruction. status flag (SF) register stack pointer (SP)\nThe Operating system must keep track of the process\u0026rsquo;s state and does so through a data structure called the process control block (PCB). PCB collects the most important data about the running process.\nProcess Control Block Information\nProcess State : Run-time state of the process; usually one of new, ready, running, suspended, terminating, waiting Process ID : Usually a numeric designer to differentiate the process from others. Other process data : Parent process, process owner, priority, scheduling information, accounting data such as CPU time elapsed. Process Location : Which queue the process resides in (ready, wait, job) Process privilege/state : What mode the process runs in (user, Privileged, some other) Hardware-stored values : PC, IR, SF, SP (possibly data register values) and interrupt masks. Resource allocation : I/O devices currently allocated to the process; memory in use; page table. The operating system is also in charge of scheduling when process run, and of changing the process status as needed doing process management.\nSingle process execution OS starts a process and the CPU attention is entirely held by that one running process until it terminates or requests some operation from OS.\nBatch processing, scheduling programs, process requests (jobs)\nDuring batch processing era, different scheduling algorithms were developed. Simplest and fairest is first come first serve FCFS or First in first out FIFO\nOrdering jobs statistically from shortest to longest is known as shortest-job first opposite would be longest-job first A priority schedule may be used with FIFO. A series of queues are used to order the process by priority\nConcurrent Processing It is to switch from a waiting process to a process ready to execute leading to improved form of process management called multiprogramming. CPU executes single process but if that process needs to perform time-consuming I/O then that process is set aside and another process is executed.\nThere will be atleast two queues, ready queue and wait queue. There might be multiple I/O wait queues. It is the OS job (scheduler) to choose which process the CPU should switch to. This is cocurrent processing, multiprogramming is one of concurrent processing.\nThe changing of CPU from one process to another is called context switch where OS gets involved. coopeartive multitasking, rendezvous\nThe next evolution of process management is to force a context switch so that no single process can monopolize the CPU. A hardware called timer which counts cock cycles. It is initialized to some value, gets decremented and when it reaches 0, the timer alerts the OS to perform a context switch. The running process is moved to the ready queue and the CPU resumes the process next in line in the ready queue.\nThis becomes preemptive multitasking which is multitasking or previously known as time sharing\nround robin sheduling time slice quanta\nSetting 1000 * (process priority) Priority 1 gets 1000 each time while priority 10 gets 10,000 each time to finish faster.\nThey can be made to age process to lessen the priority over time.\nThreads?? New concepts multithreading\nLinux by default uses cooperative and preemptive multitasking and multi-threading. It can also perform batch processing on request using batch instruction.\nInterrupt Handling CPU repeatedly fetches and runs program instructions (fetch-execute cycle) until it finishes executing the current process. The timer reaching 0 is an example where some hardware component needs the CPU\u0026rsquo;s attention, where it can interrupt the CPU\u0026rsquo;s fetch-execute cycle and request the CPU focus its attention on hardware component to handle whatever situation arose. Naturally, interrupting the CPU is called interrupt, and process of requesting an interrupt is an interrupt request (IRQ)\nIRQ might originate from hardware or software. Hardware through reserved line on the bus to CPU for software IRQ is submitted as an interrupt signal.\nUpon receiving an interrupt request, the CPU finishes the current fetch-execute cycle. CPU determines which device or software raised the interrupt. CPU acknowledges the IRQ to the interrupting device. To handle interrupt, CPU switches from user porocess to operating system which is privileged.\nFor every type of interrupt, the OS contains an interrupt handler. It is a piece of code written to handle a specific type of interrupting situation. CPU performs a context switch from current process to proper interrpt handler, requiring that CPU saves what it was doing with respect to the user process.\nThe interrupt handler executes and upon completion, the OS switches back to the process that had been running (or new process if the interrupt was from the timer reaching 0), also changing mode back to user mode.\nIRQ\u0026rsquo;s are prioritized, if the CPU is currently handling an IRQ and higher priority IRQ arrives, the CPU will postpone the lower IRQ for newer one.\nIn Linux, interrupt handlers are part of Kernel. The information about the interrupt is recorded in /proc/interrupts\nThe file /proc/stat also contains interrupt information.\nProcess Monitering Ownership of running processes Launching a process from command line control + c control + z\nMonitoring Process To see what the a process is doing.\nGUI Monitoring Tools System Monitor gnome-system-monitor command to launch from CLI\nThere are two versions, one for Gnome and another for KDE.\nCommand line monitoring tools top ps\ntop top program when launched outputs and remains running. It is an interactive program that updates its output in specified refresh rate (default 3 sec). This can be altered using -d s.t s is seconds and t is tenth of second -d 1 update every second -d 0.5 -d 0.0001\nsujith@sujith-Latitude-7490:~$ top -d 5 top - 18:37:00 up 2:35, 1 user, load average: 0.15, 0.25, 0.25 Tasks: 251 total, 1 running, 250 sleeping, 0 stopped, 0 zombie %Cpu(s): 1.0 us, 0.9 sy, 0.0 ni, 98.0 id, 0.0 wa, 0.0 hi, 0.0 si, 0.0 st MiB Mem : 7818.0 total, 5118.5 free, 1647.7 used, 1641.4 buff/cache MiB Swap: 4096.0 total, 4096.0 free, 0.0 used. 6170.4 avail Mem PID USER PR NI VIRT RES SHR S %CPU %MEM TIME+ COMMAND 1559 sujith 20 0 4872356 281168 127100 S 7.8 3.5 3:29.14 gnome-s+ 3386 sujith 20 0 554448 52336 41552 S 3.0 0.7 0:03.12 gnome-t+ 234 root -51 0 0 0 0 S 1.8 0.0 0:02.40 irq/51-+ 2431 sujith 20 0 1159.6g 269780 129124 S 0.6 3.4 14:18.19 obsidian 4964 sujith 20 0 14536 5760 3584 R 0.6 0.1 0:00.25 top 760 systemd+ 20 0 21584 12544 10368 S 0.4 0.2 0:05.00 systemd+ 1749 sujith 20 0 388872 11756 6784 S 0.4 0.1 0:00.85 ibus-da+ 2412 sujith 20 0 32.6g 133844 97160 S 0.4 1.7 4:00.22 obsidian 2750 root 20 0 0 0 0 I 0.4 0.0 0:05.31 kworker+ 2921 root 20 0 0 0 0 I 0.4 0.0 0:02.67 kworker+ 17 root 20 0 0 0 0 I 0.2 0.0 0:01.45 rcu_pre+ 79 root -51 0 0 0 0 S 0.2 0.0 0:21.71 irq/9-a+ 114 root 0 -20 0 0 0 I 0.2 0.0 0:07.62 kworker+ 184 root 0 -20 0 0 0 I 0.2 0.0 0:00.18 kworker+ 761 systemd+ 20 0 91044 7680 6784 S 0.2 0.1 0:04.19 systemd+ 2074 sujith 20 0 236772 7040 6528 S 0.2 0.1 0:00.15 ibus-en+ 2263 sujith 20 0 1156.1g 160496 124608 S 0.2 2.0 2:12.02 obsidian -H to show threads -i to show idle process -u username to show process started by that username -n # where hash is integer to indicate the number of refreshes that top should perform before terminating. top -n 10\nKeystroke commands for top A - to use alternative display mode d - to change the interval time i - Turn on off including idle processes f, o - to add remove or alter display order l - to on off load statistics t - to on off task statistics m - to on off memory statistics H - Show threads U - show specified user owned processes only n - show only specified number of processes\nq - quit\nps ps command provides a detailed examination of the running process as a snapshot and is not interactive. Displays and exits. Without any options, the only process displayed is bash\nLots of options to get what is needed but complex\nOrphans, adoption from systemd zombies, sleeping parent, killing\n","date":"2024-12-31","id":130,"permalink":"/personal-site/docs/bash-linux/linux_os/linux-os-02-forms-of-process-management/","summary":"\u003cp\u003eTwo simplest entities support the UNIX System - \u003cem\u003efile\u003c/em\u003e and \u003cem\u003eprocess\u003c/em\u003e.\u003cbr\u003e\nA File is just an array of bytes that can virtually contain anything. It is also related to other files by being part of a single hierarchical structure. File is located with reference to a predetermined place.\u003c/p\u003e","tags":[],"title":"Linux OS - 02 - Forms of Process Management"},{"content":"All processes use system resources. At minimum, every process has a PCB stores in the operating system\u0026rsquo;s portion of memory and some amount of memory space allocated to it. plus a place in queue and access to CPU.\nOther resources may request are access to I/O, storage and communication devices, inter process communications with other processes through domain sockets, names pipes, remote procedure calls.\nMemory and Virtual Memory The OS maintains tables of process memory space in the the form of memory maps.\nAs user processes are given their own memory space, the computer must ensure that one process does not try to access memory allocated to another process.\nDRAM is limited in size and the processes that needs to be done will not wholly fit in main memory as large number of programs are running. The main memory is extended with reserved data on the hard disk (SSD) called swap space.\nPortions of our running programs reside in swap space rather than memory so that we can accommodate both a number of processes and large processes at one time.\nWe refer to this extension of memory as virtual memeory\nThe typical strategy to implement virtual memory in OS is to divide the programs into fixed size units called pages and memory into fixed size units called frames. One page fits precisely into one frame. The program\u0026rsquo;s pages are loaded when needed (on demand) by the OS.\npage table is the data structure which contains the info about which process pages are in which frames of memory. also which pages are stored in memory. each process has its own page table, and all page tables are stored in OS\u0026rsquo;s reserved portion of memory.\nWhen a process is running, the CPU generated address are virtual address which are not in memory but are locations of where to find the item within the program. The physical location of that item in memory is called physical address\nWe need a process to translate the virtual address to a physical address. This mapping is handled by exchanging the address page number for the frame number containing that page stored in DRAM in various frames.\npage fault for accessing page that is not in memory. Interrupt to let OS handle the page fault, obtaining the needed page from swap space and moving it into memory.\npage swapping moving the pages in and out of memory(frames)\nreplacement strategy to select a page to discard from memory. removing the the one that wont be used again using prediction based on least recently used (LRU), or other approximation algorithms are used. Or the unmodified page, as modified page has to be moved to swap space before being removed.\nLinux commands to Inspect System Resources Sytem monitor top ps were used to explore process usage.\niostat and mpstat might not come pre installed on Linux (its there)\nIf not installed, then can be got by -get install sysstat when in sudo\nmpstat is used to display multiprocessor statistics. It gives a snapshot of processor load.\nsujith@sujith-Latitude-7490:~$ mpstat Linux 6.8.0-51-generic (sujith-Latitude-7490) 12/27/2024 _x86_64_\t(8 CPU) 07:58:15 PM CPU %usr %nice %sys %iowait %irq %soft %steal %guest %gnice %idle 07:58:15 PM all 1.62 0.01 0.54 0.03 0.00 0.01 0.00 0.00 0.00 97.79\riostat reports on both process and I/O statistics. Without options it outputs almost same info as mpstat It can also output various device several statistics.\nTwo other instructions of use are to view memory and virtual memory usage are free and vmstat. free gives report on total amount of memory and swap space, amount currently using and amount free. vmstat provides average since last boot of virtual memory and CPU usage and process.\npmap allows us to explore the memory map of a specified process. (needs PID)\n","date":"2024-12-31","id":131,"permalink":"/personal-site/docs/bash-linux/linux_os/linux-os-03-system-resources/","summary":"\u003cp\u003eAll processes use system resources.\nAt minimum, every process has a PCB stores in the operating system\u0026rsquo;s portion of memory and some amount of memory space allocated to it.\nplus a place in queue and access to CPU.\u003c/p\u003e","tags":[],"title":"Linux OS - 03 System Resources"},{"content":"","date":"2024-12-29","id":132,"permalink":"/personal-site/docs/bash-linux/linux_bash/","summary":"","tags":[],"title":"Linx Bash"},{"content":"Bash: A User Interface A shell is a user interface that runs an interpreter. The interpreter is a program that accepts user input, determines how to execute that input, converts it into executable statements, and executes them. The environment\u0026rsquo;s role is to capture definitions and previous commands from the current session, allowing users to easily recall them and simplify their interaction with the system.\nThe development of shells has evolved over time, with major milestones including the Thompson Shell (1971), Mashey Shell, Bourne Shell (1977), C-shell (1978), and TC-Shell (1983). The Bourne Again Shell (Bash), released in 1989, is one of the most popular shells used today.\nBash - Bourne Again SHell (Git Bash - for Windows interaction with Git)\nThe grammar of a shell allows combining existing tools into powerful pipelines and handling large volumes of data automatically. Writing a sequence of commands in a script improves the reproducibility of workflows.\nTerminal Basics $ is the prompt for typing, followed by a blinking text cursor.\nCtrl + Alt + T # Launch terminal Ctrl + Shift + C # Copy from terminal Ctrl + Shift + V # Paste in terminal clear # Clear the terminal\rsu - Switch user to super user sudo - Execute a command with super user permissions apt - Package installer for Debian-based systems Switch between users using su (switch user) or sudo su to switch to root. exit to end the root session. sudo apt update # Update package index sudo apt upgrade # Upgrade installed packages\rShell Command Prompt The shell prompt shows essential information about the user, system, and their current state. A typical prompt looks like this:\nsujith @sujith-Latitude-7490 ~ $\r~ represents the home directory, $ indicates a normal user. When logged in as a root user, the prompt changes to #. The # symbol signifies that the user has root (administrator) privileges.:\nroot @sujith-Latitude-7490 :home/sujith #\rGeneral Syntax of a Shell Command The general structure for a Linux command is:\ncommand [option(s)] [parameter(s)]\r$ ls -F /\r$ is the prompt ls is the command -F is the option/flag / is the parameter (the root directory) Commands, Options, and Parameters\nA command does not always require arguments or options;\nit can be called with multiple options and arguments (collectively referred to as parameters).\nOptions change the command\u0026rsquo;s behavior:\nOptions typically follow a hyphen -.\nShort options start with a single dash (-), e.g., -r, -a.\nLong options start with double dashes (--), e.g., --reverse, --all.\nSome options may act differently in different commands or same way across multiple commands.\n-f / --force for force and -i / --interactive is in cp, mv, rm -r / --recursive perform recursive operation for cp rm -a for all and -h / --help are common in most commands Parameters or Arguments are often required or optional, depending on the command. These specify the target of the command, such as file names or directories.\nCommand options arguments have to be separated by spaces or tabs for the system to interpret them as words. Omitting spaces causes confusion about commands, options, and arguments.\n(e.g., ls-F searches for a command called ls-F, which does not exist)\nA contiguous string of spaces and tabs together form whitespace. Systems permits the use of one white space which can be many tabs and spaces. Which gets compressed to single space.\nCase sensitivity matters:\nls -s displays the size of files. ls -S sorts files by size. Common Shell Commands Some common shell commands and their functions include:\ncd: Change the directory\nls: List files in the current directory\npwd: Display the current directory path\nvi or emacs: Text editors for editing files\nwho: Show who is logged in\nwhoami: Display the current username\nhostname: Display the computer’s hostname\nuname: Show system information (e.g., uname -o for the operating system)\narch: Show the computer’s architecture\necho: Print text or values to the screen (e.g., echo $SHELL to display the shell being used)\nbash: Start a new Bash session within the current session\nexit: Exit the current Bash session (If it is the outermost one, it will close the window)\npasswd: Change the user password\nps : Report a snapshot of the current processes.\nstty : Change and prints Terminal Settings (-a to show all settings)\nExecuting Multiple Commands Multiple commands can be executed on a single line by separating them with a semicolon ;. This allows to run multiple commands consecutively, one after the other. The white space between two commands is just for readability purpose.\n$ uname -o; echo $SHELL; who; whoami; GNU/Linux /bin/bash sujith seat0 2024-12-24 08:55 (login screen) sujith tty2 2024-12-24 08:55 (tty2) sujith\runame -o shows the operating system type. echo $SHELL displays the shell being used. who lists logged-in users. whoami displays the current username. Grouping together commands within parentheses:\n(wc note ; ls -l note) \u0026gt; newlist (wc note;ls -l note)\u0026gt;newlist\rTab Completion When typing a directory or command name, pressing Tab will auto-complete the name if there is only one option. Double pressing Tab will show all possible options.\nTyping Doc + Tab may automatically complete to Documents.\n~/Documents/Odin-Project/foundations/java-script/calculator/ Doc tab O tab f tab j tab cal tab\r. refers to the current directory.\ngit add . stages all files in the current directory for Git. In VS Code, navigate to your project directory and use code . to open it. Simply typing code in the terminal launches VS Code. Command Substitution Shell enables connecting commands in yet another way, shell enables one or more command argument to be obtained from the standard output of another command. Which is called as Command substitution.\necho \u0026#34;The date today is `date` \u0026#34; echo The date today is `date` echo The date today is $(date) # The date today is Sat Jan 4 11:33:27 AM IST 2025\rThe last part represents the output of the date command.\nThe date is put inside backquotes which are not single quotes.\nUsing single quotes will not execute the command but treats it literally and prints whatever was inside.\nIn Bash it is recommended to use of the form $(command) rather than the backquotes.\n","date":"2024-10-22","id":133,"permalink":"/personal-site/docs/bash-linux/linux_bash/bash-01-basics/","summary":"\u003ch3 id=\"bash-a-user-interface\"\u003e\u003cstrong\u003eBash: A User Interface\u003c/strong\u003e\u003c/h3\u003e\n\u003cp\u003eA \u003cstrong\u003eshell\u003c/strong\u003e is a user interface that runs an interpreter.\nThe \u003cem\u003einterpreter\u003c/em\u003e is a program that accepts user input, determines how to execute that input, converts it into executable statements, and executes them.\nThe \u003cstrong\u003eenvironment\u003c/strong\u003e\u0026rsquo;s role is to capture definitions and previous commands from the current session, allowing users to easily recall them and simplify their interaction with the system.\u003c/p\u003e","tags":[],"title":"Bash - 01 - Basics"},{"content":"Command-Line Editing Bash supports several special keystrokes for command-line editing. These keystrokes are combinations of the Control key, Escape key, or other keys and are based on the emacs text editor.\nControl Key (Ctrl) : Hold the Control key and press the other key.\nEscape Key (Esc) : Press the Escape key, release it, and then press the other key.\nNavigation and Editing Keystrokes\nCtrl + p / ↑ : Move up in the history list (previous command).\nCtrl + n / ↓ : Move down in the history list (next command).\nCtrl + a : Move the cursor to the beginning of the line.\nCtrl + e : Move the cursor to the end of the line.\nCtrl + d or Delete : Delete the character the cursor is on.\nBackspace or Ctrl + h : Delete the character before the cursor.\nCtrl + w : Delete one word, removing characters from the cursor to the beginning of the word.\nCtrl + k : Delete everything from the cursor to the end of the line.\nCtrl + u : Delete everything from the current command line.\nCtrl + l : Clear the terminal screen but leave the current command line intact.\nText Transformation\nCtrl + y : Yank (paste) the last deleted characters. Esc + u : Uppercase the word from the cursor position to the next space. Esc + l : Lowercase the word from the cursor position to the next space. Esc + c : Capitalize the first letter of the word at the cursor position. Crtl + c : or Delete to interrupt a command (Interrupt character).\nCtrl + s : and Ctrl + q to Freeze and Release the terminal.\nCtrl + j or Ctrl + m : Alternative to Enter Key\nRedirection Redirection is the process of using operators to control where input or output from a command goes.\nWriting to a File / Capturing Output \u0026gt; : Redirects output to a file, overwriting its contents.\n$ cat *.txt \u0026gt; newfile.txt\rThis command combines all .txt files in the directory and writes them to newfile.txt. If the file already exists, it will be overwritten.\n\u0026gt;\u0026gt; : Appends output to a file if it already exists.\n$ cat *.txt \u0026gt;\u0026gt; newfile.txt\rThis command appends the content of all .txt files to newfile.txt.\n\u0026lt; : Redirect input to a command.\n$ cat \u0026lt; *.txt\rThis will feed the content of all .txt files as input to the cat command.\nHere Documents (\u0026lt;\u0026lt;) : Accepts input until a specified delimiter is reached.\n$ cat \u0026lt;\u0026lt; quit\rThis will take input until the word quit is typed.\n$ cat \u0026lt;\u0026lt; done \u0026gt; fruit.txt\rThis will take input until done is typed and save it into fruit.txt.\nList and redirect output to a file:\nThis command lists the contents of /home/sujith and writes it to user_entries.txt.\n$ ls -l /home/sujith \u0026gt; user_entries.txt\rCount lines of .pdb files and redirect to a new file:\nThis command counts the number of lines in each .pdb file and writes the result to lengths.txt.\n$ wc -l *.pdb \u0026gt; lengths.txt\rRead and write specific lines from a file:\nThis creates animals-subset.csv containing the first 3 lines of animal.csv.\n$ head -n 3 animal.csv \u0026gt; animals-subset.csv\rThis appends the last 2 lines of animals.csv to animals-subset.csv.\n$ tail -n 2 animals.csv \u0026gt;\u0026gt; animals-subset.csv\rTwo Special files are /dev/null and dev/tty.\nThese files always have zero size and will incinerate any output written to it. This facility is useful to redirecting error messages away from terminal. Or to check the program running successfully without seeing the output.\nPipes Pipes (|) allow the output of one command to be used as input for another command, enabling efficient chaining of multiple commands.\nBasic Pipe Usage Sort a file and display the smallest value.\n$ sort -n lengths.txt | head -n 1\rThis command sorts lengths.txt numerically and then displays the first line (smallest value).\nChain wc with sort and head.\n$ wc -l *.pdb | sort -n | head -n 1\rThis command counts the lines in all .pdb files, sorts them, and then displays the shortest file.\nPipe output to a new file.\n$ cat *.txt | sort \u0026gt; newfile.txt\rThis command concatenates all .txt files, sorts their contents, and writes the sorted output to newfile.txt.\nWhen a Command Needs to be Ignorant of Its Source\nIf wc *.c would give the individual count of all the files and also the total count.\nBy passing the input to wc using pipe when the command does not know the source, it outputs just the total of the stream from pipe.\ncat *.c | wc -c # 9636 if [`cat *c | wc -c` -lt 1474560] ; then echo \u0026#39;These files will fit into a single 3.5\u0026#34; diskette\u0026#39; fi\rUsing Tilde Expansion In Bash, tilde expansion allows the ~ symbol to represent the home directory, eliminating the need to type the full path /home/username/.\nChange to the home directory:\n$ cd ~\rList .txt files in the home directory:\n$ ls ~/*.txt\r* is a wildcard that replaces everything found and there are more. it is termed as filename expansion.\nls -l *.txt the .*txt is replaced by all the files before execution.\nBrace Expansion Brace expansion allows for grouping file names or directories that share the same path. It’s useful for creating multiple files or directories in one go.\nList specific files or directories:\n$ ls -l /home/{one,two/{.,stuff},underwood,overwood/{.,lyrics,music}}\rHere the . are used to include the current directories also.\nThis will expand to:\n/home/one\r/home/two\r/home/two/.stuff\r/home/two/stuff\r/home/underwood\r/home/overwood\r/home/overwood/.lyrics\r/home/overwood/music\rHistory List All entered commands are stored in a history list. Can be viewed by typing history.\nsujith@sujith-Latitude-7490:~/Desktop$ cd Desktop/; history \u0026gt; comm.txt;\rCreates a file (comm.txt) containing all the commands typed, which can have thousands of commands.\nThe history list can store a maximum of 1000 commands. Older commands are discarded when the list exceeds this limit.\nThe number preceding the command in the history list can be used to recall it.\nUsing !100 recalls the command at position 100 in the history list.\nRecalling Instructions from the History List !! : Recalls and runs the last instruction. !n : Recalls and runs the n-th instruction from the history list. !str : Recalls the latest instruction that uniquely starts with str. Using parameters from the last command:\ncommand !^ : Issues the command and uses the first parameter/option from the last instruction. command !$ : Issues the command and uses the last parameter/option from the last instruction. command !* : Issues the command and uses all parameters/options from the last instruction. ls -l !^ ls -l !$ ls !*\rRecalling Previous Instructions to Edit or Display \u0026lt;up arrow\u0026gt; or Ctrl + p : Retrieve the last instruction in the history list. \u0026lt;down arrow\u0026gt; or Ctrl + n : Move forward in the history list. Can also use:\n!!:p : Prints the last instruction from the history list. !:2000 : Prints the 2000th instruction from the history (may not work if there are fewer than 2000 entries). !:str : Prints the last instruction that starts with str. Options for the history Command history -c : Clears the history list.\nhistory -d n : Deletes the n-th entry from the history list, causing the remaining entries to shift up.\nhistory -r filename : Loads the history list from filename and replaces the current history list. (Note: Previous history numbers may be appended to the commands.)\nhistory -w filename : Writes the current history list to a file.\nhistory -a filename : Appends the current history list to a file.\nhistory -n filename : Reads from filename, adding any new lines not already in the current history list to the current history.\n","date":"2024-10-22","id":134,"permalink":"/personal-site/docs/bash-linux/linux_bash/bash-02-features/","summary":"\u003ch3 id=\"command-line-editing\"\u003e\u003cstrong\u003eCommand-Line Editing\u003c/strong\u003e\u003c/h3\u003e\n\u003cp\u003eBash supports several special keystrokes for command-line editing. These keystrokes are combinations of the \u003cstrong\u003eControl\u003c/strong\u003e key, \u003cstrong\u003eEscape\u003c/strong\u003e key, or other keys and are based on the \u003ccode\u003eemacs\u003c/code\u003e text editor.\u003c/p\u003e","tags":[],"title":"Bash - 02 - Features"},{"content":"Linux provides several forms of support, with the most commonly used being the man (manual) pages.\n--help : Pass this option to any command to see the available options.\ncd --help ls --help mkdir --help\rhelp : Provides help for built-in shell commands.\nhelp cd help echo # Works for built-in commands only\rFor commands with both long (--option) and short (-o) versions, use the short version in the terminal and the long version in scripts for clarity.\nman Pages man is the manual for a command (if it exists). It expects the name of the command as its argument and displays the corresponding man page.\nman ls man mkdir\rIn the manual:\nSpace or B to scroll down. N to navigate between search hits. Shift + N to navigate backwards. Note: man cd doesn\u0026rsquo;t exist because cd is a built-in shell function. Use --help instead.\nThe man page is displayed within the vi editor (view/search mode only).\nA man page typically contains sections like:\nName Synopsis Description Options Configuration Files Exit Codes Files Other man pages to consult Other Command Line Help whatis whatis : Provides a brief description of a command.\nsujith@sujith-Latitude-7490:~$ whatis ls pwd rm rmdir mkdir touch echo ls (1) - list directory contents pwd (1) - print name of current/working directory rm (1) - remove files or directories rmdir (1) - remove empty directories rmdir (2) - delete a directory mkdir (1) - make directories mkdir (2) - create a directory touch (1) - change file timestamps echo (1) - display a line of text\rwhatis also supports the -w option for wildcards.\nsujith@sujith-Latitude-7490:~$ whatis -w mkd* mkdir (1) - make directories mkdir (2) - create a directory mkdirat (2) - create a directory mkdosfs (8) - create an MS-DOS FAT filesystem mkdtemp (3) - create a unique temporary directory\rSearching in /usr/bin To see all available commands which are present in contents of /usr/bin.\nUsing apropos apropos allows finding commands using a description.\nIt takes a string and searches for commands that has description that match the string provided as an argument.\napropos delete apropos delete directory\rUsing \u0026quot; \u0026quot; can help narrow down the search to specific phrases:\napropos \u0026#34;remove directory\u0026#34;\rUsing regular expressions (e.g., .*) to match anything between words:\napropos \u0026#34;remove .* directory\u0026#34; apropos \u0026#34;delete .* directory\u0026#34;\rsujith@sujith-Latitude-7490:~$ apropos \u0026#34;virtual memory\u0026#34; mremap (2) - remap a virtual memory address proc_sys_vm (5) - virtual memory subsystem proc_vmstat (5) - virtual memory statistics tmpfs (5) - a virtual memory filesystem vmstat (8) - Report virtual memory statistics rmdir (2) - delete a directory\rsujith@sujith-Latitude-7490:~$ apropos \u0026#34;user account\u0026#34; userdel (8) - delete a user account and related files usermod (8) - modify a user account\r","date":"2024-10-22","id":135,"permalink":"/personal-site/docs/bash-linux/linux_bash/bash-03-help-pages/","summary":"\u003cp\u003eLinux provides several forms of support, with the most commonly used being the \u003cstrong\u003eman (manual)\u003c/strong\u003e pages.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e\u003ccode\u003e--help\u003c/code\u003e\u003c/strong\u003e : Pass this option to any command to see the available options.\u003c/p\u003e","tags":[],"title":"Bash - 03 - help pages"},{"content":"In Bash, variables can be defined from the command line and used later in the same shell session or from within a script.\nAll variables are typically capitalized but not a requirement.\nWhen a variable is available throughout the environment for use, not just one session or script, it is called an environment variable.\nenv The env command can be used to see all the environment variables defined (these can vary across distributions).\nsujith@sujith-Latitude-7490:~/Desktop$ env SHELL=/bin/bash SESSION_MANAGER=local/sujith-Latitude-7490:@/tmp/.ICE-unix/1537,unix/sujith-Latitude-7490:/tmp/.ICE-unix/1537 QT_ACCESSIBILITY=1 PWD=/home/sujith/Desktop LOGNAME=sujith HOME=/home/sujith USERNAME=sujith IM_CONFIG_PHASE=1 LANG=en_US.UTF-8 USER=sujith GNOME_TERMINAL_SERVICE=:1.132 DISPLAY=:0 SHLVL=1 PATH=/home/sujith/.nvm/versions/node/v20.17.0/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/snap/bin:/snap/bin GDMSESSION=ubuntu DBUS_SESSION_BUS_ADDRESS=unix:path=/run/user/1000/bus NVM_BIN=/home/sujith/.nvm/versions/node/v20.17.0/bin _=/usr/bin/env OLDPWD=/home/sujith\rThese environment variables can also be viewed by using echo where string is the name of the environment variable. To output the value of a variable, use the $ sign before the variable name.\nsujith@sujith-Latitude-7490:~/Desktop$ echo $USER; echo $SHELL; echo $PWD; echo $OLDPWD; sujith /bin/bash /home/sujith/Desktop /home/sujith\rCommon Bash Environment Variables DESKTOP_SESSION: Name of the desktop GUI (e.g., gnome) HISTSIZE: Size of the history list (e.g., 1000) LANG: The specified language and character encoding (e.g., en_US.UTF-8) MAIL: Location of the user\u0026rsquo;s main mail storage OLDPWD: The previous working directory (prior to the current one) PATH: List of directories to search for executable programs PS1: Defines the user prompt SHELL: The user’s default shell PATH is a crucial environment variable in Linux. It contains a list of directories in which the shell searches for executable programs. Most are found in /user/bin /user/sbin\nPATH=/home/sujith/.nvm/versions/node/v20.17.0/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/snap/bin:/snap/bin\rWithout the PATH variable, you would need to specify the full path to the executable before running any command.\nDefining Variables To store a value in a variable, use an assignment statement.\nThe syntax is VAR=VALUE with no spaces around the equal sign.\nWe can define new variables or redefine existing ones.\n$ FIRST=Sujith $ LAST=kumar $ echo $FIRST $LAST Sujith Kumar\rUsing Single Quotes:\nWhen using single quotes (' '), the Bash interpreter treats the content literally and does not expand the value of variables.\nSo it will not apply $ to retrieve the value from variables.\n$ FULL_NAME=\u0026#39;$FIRST $LAST\u0026#39; $ echo $FULL_NAME $FIRST $LAST\rUsing Double Quotes:\nIf there is any blank space in the Value being assigned, then value has to be in \u0026quot; \u0026quot;\nWhen using double quotes (\u0026quot; \u0026quot;), the Bash interpreter will expand variables.\n$ FULL_NAME=\u0026#34;$FIRST $LAST\u0026#34; $ echo $FULL_NAME Sujith Kumar\rIf a command like pwd is stored in a variable and called, Bash will execute it.\nunset variable will remove the variable from the list of variables.\nreadonly variable will not allow the variable to be reassigned.\n$ psit=~/Desktop/website/site $ cd $psite $ pnote=~/Desktop/obsid/notes $ cd $pnote $ size=`wc -c \u0026lt; file.text`\rThe Shell Order of Processing can be:\nParsing : Breaking command into words with space or tab as delimiter. Variable evaluation : All $ prefixed strings are evaluated as variables, unless quoted or escaped. Command Substitution : Any command surrounded by back quotes are executed by the shell which then replaces the standard output of the command into the command line. Redirection : Looks for \u0026lt; \u0026gt; \u0026gt;\u0026gt; to open files they point to. Wildcard Interpretation : Replacing with matching file names. PATH Evaluation : Searching for the command in directories. Escape Character (\\):\nThe escape character is used to tell the Bash interpreter to treat the following character literally and not interpret it.\n\\$$AMOUNT escapes the first $, so it is not interpreted as a variable.\nOther Escape Characters:\n\\\\ : outputs a backslash (\\) \\b : backspace \\n : newline \\t : tab \\! , \\$ , \\\u0026amp; , \\; , \\' , \\\u0026quot; : escaping special symbols Putting a string of command in ' ' single quotes will also work as escaping all the characters in it.\n[!Important] All variables and aliases defined in the terminal in a session in that environment is temporary by default and will get erased after the terminal session ends. To make it permanent, they need to be defined in the configuration files that are loaded when the shell starts like ~/.bashrc, for system wide environment variables like /etc/environemnt, /etc/bash.bashrc\nAliases An alias is used to define a shortcut for a command.\nSimilar to defining a variable, name can be assigned to a command to shorten its execution.\nTo define an alias, use an assignment statement:\nalias name=\u0026quot;command\u0026quot;\nThe name is the alias, and the command is the Linux command it represents.\nalias ..=\u0026#34;cd ..\u0026#34; alias ~=\u0026#34;cd ~\u0026#34; alias lss=less alias sl=ls alias rm=\u0026#39;rm -i\u0026#39; # -i for interactive mode\rrm is given in single quotes to input the interactive version.\nalias psite=\u0026#34;cd ~/Desktop/Sites/Personal\u0026#34;\rYou can view all the predefined aliases by typing alias:\nalias egrep=\u0026#39;egrep --color=auto\u0026#39; alias fgrep=\u0026#39;fgrep --color=auto\u0026#39; alias grep=\u0026#39;grep --color=auto\u0026#39; alias l=\u0026#39;ls -CF\u0026#39; alias la=\u0026#39;ls -A\u0026#39; alias ll=\u0026#39;ls -alF\u0026#39; alias ls=\u0026#39;ls --color=auto\u0026#39; alias alert=\u0026#39;notify-send --urgency=low -i \u0026#34;$([ $? = 0 ] \u0026amp;\u0026amp; echo terminal || echo error)\u0026#34; \u0026#34;$(history|tail -n1|sed -e \u0026#39;\\\u0026#39;\u0026#39;s/^\\s*[0-9]\\+\\s*//;s/[;\u0026amp;|]\\s*alert$//\u0026#39;\\\u0026#39;\u0026#39;)\u0026#34;\u0026#39;\rTo remove an alias, use the unalias command:\nunalias ll\r","date":"2024-10-22","id":136,"permalink":"/personal-site/docs/bash-linux/linux_bash/bash-04-variables-and-aliases/","summary":"\u003cp\u003eIn Bash, variables can be defined from the command line and used later in the same shell session or from within a script.\u003cbr\u003e\nAll variables are typically capitalized but not a requirement.\u003c/p\u003e","tags":[],"title":"Bash - 04 - Variables and Aliases"},{"content":"The ls command is used to list files and directories in the current directory.\nls ~/Desktop/trial # Using absolute path ls /Users/sujith/Desktop/trial # Another way using absolute path ls -F Desktop # List contents of Desktop directory\rThese commands display the contents of the Desktop directory (or any specified directory).\nThe -F option appends a character to each file to indicate its type (e.g., / for directories, * for executables).\nls with Multiple Directories sujith@sujith-Latitude-7490:~$ ls ./ Desktop/ Documents/ Downloads/\rIn this example, the ls command lists the contents of multiple directories. However, using semicolons ; between the commands might not work as intended because semicolons separate commands rather than options.\nsujith@sujith-Latitude-7490:~$ ls .; Desktop/; Documents/; Downloads/; Desktop Downloads Music Public snap Videos Documents grep.txt Pictures repos Templates bash: Desktop/: Is a directory bash: Documents/: Is a directory bash: Downloads/: Is a directory\rThe ls command should be executed separately for each directory or with valid options that do not cause errors.\nLong Listing Format -l option to get a more detailed view of files and directories:\nsujith@sujith-Latitude-7490:~/Desktop$ ls -l\rtotal 24 drwxrwxr-x 4 sujith sujith 4096 Sep 3 15:29 courses drwxr-xr-x 2 sujith sujith 4096 Dec 22 16:11 \u0026#39;MCA Sem1 Text Books\u0026#39; drwxr-xr-x 4 sujith sujith 4096 Dec 18 19:56 obsidian-vaults drwxrwxr-x 7 sujith sujith 4096 Oct 6 15:21 Opage drwxrwxr-x 6 sujith sujith 4096 Dec 24 10:09 pylab drwxrwxr-x 8 sujith sujith 4096 Oct 26 09:04 websites -rw-rw-r-- 1 sujith sujith 68146 Dec 24 12:43 sujith.jpeg -rw-rw-r-- 1 sujith sujith 2957628 Oct 30 13:52 \u0026#39;Option WorkSheet.pdf\u0026#39;\rUnderstanding the Output of ls -l File Type: The first part of file permissions. d represents a directory - represents a regular file l represents a symbolic link\nPermissions (Mode): Shows the file’s access permissions for the owner, group, and others. rw- r-- --- 9 characters combined with file type becomes 10 characters. (. at end of permissions to indicate the SELinux content)\nHard Links: The number of hard links pointing to the file. For files, it is usually 1, and for directories, it is typically 2 but can be more.\nUser, Group: The user who owns the file and the group to which it belongs. For most users the group is the user\u0026rsquo;s private group. sujith sujith\nSize: The size of the file or directory in bytes. 68146 for the sujith.jpeg file.\nLast Modified Date: The last modification date and time of the file or directory. (creation date/time if not modified)\nName: The name of the file or directory. For a symbolic link, the name is followed by -\u0026gt;\nUseful Options for ls Options combined with ls to modify its output:\n-a Show hidden files (those starting with .) and the . (current directory) and .. (parent directory).\n-A Similar to -a but excludes . and ..\n-g Similar to -l but the owner is not shown.\n-G Group owner is hidden (along with -l)\n-h Displays file sizes in human readable format (KB, MB) (along with -l).\n-i Shows inode numbers for the files\n-r Reverse alphabetical order of file listing.\n-R Recursive listing (listing all contents of all sub directories)\n-s Size shown in blocks instead of bytes (along with -l).\n-S Sort files by size (used with -l)\n-t Sorts files by modification time (along with -l).\n-X Extension based sorting (along with -l)\n-C Displays the output in columns (default behavior).\n-1 Displays 1 file per line (not to use columns)\nThese options an be combined in any order:\nls -Fal # Combined options (file types, human-readable sizes, and long listing) ls -la # Long listing with hidden files ls -al # Another variation\r","date":"2024-10-22","id":137,"permalink":"/personal-site/docs/bash-linux/linux_bash/bash-05-listing-files/","summary":"\u003cp\u003eThe \u003cstrong\u003e\u003ca href=\"/personal-site/docs/bash-linux/command-docs/ls-list\"\u003e\u003cem\u003els\u003c/em\u003e\u003c/a\u003e\u003c/strong\u003e command is used to list files and directories in the current directory.\u003c/p\u003e\n\r\n\r\n\r\n\u003cdiv class=\"expressive-code\"\u003e\r\n  \u003cfigure class=\"frame not-content\"\u003e\r\n  \u003cfigcaption class=\"header\"\u003e\r\n    \u003cspan class=\"title\"\u003e\u003c/span\u003e\r\n  \u003c/figcaption\u003e\r\n  \u003cdiv class=\"highlight\" frame=\"none\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003els ~/Desktop/trial\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# Using absolute path\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003els /Users/sujith/Desktop/trial\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# Another way using absolute path\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003els -F Desktop\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# List contents of Desktop directory\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\r\n  \u003c/figure\u003e\r\n\u003c/div\u003e\r\n\u003cp\u003eThese commands display the contents of the \u003ccode\u003eDesktop\u003c/code\u003e directory (or any specified directory).\u003cbr\u003e\nThe \u003ccode\u003e-F\u003c/code\u003e option appends a character to each file to indicate its type (e.g., \u003ccode\u003e/\u003c/code\u003e for directories, \u003ccode\u003e*\u003c/code\u003e for executables).\u003c/p\u003e","tags":[],"title":"Bash - 05 - Listing Files"},{"content":"Computer\u0026rsquo;s don\u0026rsquo;t have the ability to translating the commands into action, it requires a Command Interpreter, which is handled by the outer part of the Operating system called Shell .\nIt is actually the interface between the user and the kernel.\nShell A shell session consists of an environment that includes all the variables, functions, and other entities defined during the session.\nWhen a session ends (using exit), or when a new session is started within a session (e.g., using bash), the entities defined in that session are no longer available.\nHowever, it is possible to create a new session inside the current one, which is referred to as a subshell or a nested shell.\nA subshell allows you to create a new environment for performing tasks without affecting the parent shell. This is useful for executing commands or running scripts without modifying the original session.\nA item defined in a shell can be made to persist in the subshell by using export. exporting variables from the parent shell to the subshell, ensuring that they are available within the subshell. However, changes made to variables within the subshell will not affect the parent shell.\nexport VAR=value # Exports the variable to the subshell\rexport -f: Exports a function to the subshell. export -p: Displays all exported variables. export -n: Removes the export property from a variable. Configuration Files for Shell Sessions There are four important configuration files in Linux, two for users and two for system administrators:\nThe two profile files execute for both interactive and non interactive sessions. Non interactive session is one where a shell is needed to run a script but there is no user interaction.\nWhen we login to Linux and open a window, we are running an interactive shell. Then both the profile and bashrc scripts will execute.\nFor System Administrators: /etc/profile: This file is executed for all users when they log in.\nIt defines a function called pathmunge.\nIt sets up environment variables such as USER, LOGNAME, MAIL, HOSTNAME, PATH, and other system-wide variables. It is primarily used for system-wide settings.\nAll defined variables are exported. A umask instruction is executed.\n/etc/bashrc: This file is executed for interactive non-login shells. It sets additional environment variables, defines system-wide aliases, and modifies the PATH variable. It is a good place to define system-wide functions and aliases.\nFor Users: ~/.bash_profile: This file is executed for login shells. It typically contains an if statement that checks if the user’s .bashrc exists, and if so, runs it. It can also be used for user-specific environment variables.\n~/.bashrc: This file is executed for non-login interactive shells. It is where users can define their own functions, aliases, and environment variables. It also sources /etc/bashrc to include system-wide settings.\nHow Shell Configuration Files Work When a user logs in:\n/etc/profile is executed first. This file typically contains functions like pathmunge to construct the PATH variable and defines environment variables like USER, LOGNAME, MAIL, and others. It also executes umask to set file creation permissions. /etc/bashrc is executed next, setting additional environment variables and modifying the PATH. It is where system-wide aliases and functions should be defined. Then, ~/.bash_profile executes:\nIt checks if the .bashrc file exists in the user’s home directory, and if so, sources it to run the user-specific configuration. ~/.bashrc:\nIt checks if /etc/bashrc exists and sources it, even though it may have already been executed by /etc/profile. This file concludes by adding local bin directories ($HOME/.local/bin and $HOME/bin) to the PATH variable. You can add custom aliases and functions in this file. Logout and Session Cleanup ~/.bash_logout: This file is invoked when a Bash session is closed. Users can define commands to run before the session ends, such as cleaning up temporary files or logging out of remote sessions. Changes made to these configuration files do not take effect until a new session is started. To apply changes immediately within the current session, the source command can be used to reload a script:\nsource ~/.bashrc\rInternal and External Commands $ type echo\necho is a shell builtin\necho is not an external command, Shell won\u0026rsquo;t look for it in the PATH variable to locate it when it is called. Rather it will execute it from its own set of built in commands that are not stored as separate files. These Built-in commands are called as Internal commands.\nCertain commands are built into the shell because it is difficult or impossible to implement them as separate external commands.\nThe child process inherits the current working directory from its parent as one of the environmental parameters. It is important for the cd command to not spawn any children to achieve a change of directory. If it did so through a separate process then after cd had completed its run, control would revert to the parent and the original directory would be restored. Then it would be impossible to change directory.\nCompiler vs Interpreter Compiler: A compiler translates the entire source code of a program into machine code (binary code) that can be executed by the computer. It produces an independent executable file. Interpreter: An interpreter directly executes instructions written in a programming language, without converting them into machine code beforehand. It processes the code line by line. Some languages, like Java, use an intermediate bytecode, which is platform-independent. The bytecode is then interpreted by the Java Virtual Machine (JVM), making the code portable across different systems.\n","date":"2024-10-22","id":138,"permalink":"/personal-site/docs/bash-linux/linux_bash/bash-06-environment-and-subshell/","summary":"\u003cp\u003eComputer\u0026rsquo;s don\u0026rsquo;t have the ability to translating the commands into action, it requires a \u003cem\u003e\u003cstrong\u003eCommand Interpreter\u003c/strong\u003e\u003c/em\u003e, which is handled by the outer part of the Operating system called \u003cem\u003e\u003cstrong\u003eShell\u003c/strong\u003e\u003c/em\u003e .\u003cbr\u003e\nIt is actually the interface between the user and the kernel.\u003c/p\u003e","tags":[],"title":"Bash - 06 - Environment and Subshell"},{"content":"Many file commands can operate on many different types of items because Linux treats them all as files.\nLinux treats various entities such as regular files, directories, symbolic links, pipes, sockets, and device files as files.\nfile Command The file command is used to determine the type of a file. It analyzes the contents of a file and returns a description of its type.\nfile \u0026lt;filename\u0026gt;\rsujith@sujith-Latitude-7490:~$ file /home/sujith/Downloads/Print\\ Resume.pdf /home/sujith/Downloads/Print Resume.pdf: PDF document, version 1.4, 1 page(s) sujith@sujith-Latitude-7490:~$ file /etc/passwd /etc/passwd: ASCII text sujith@sujith-Latitude-7490:~$ file -i /etc/passwd /etc/passwd: text/plain; charset=us-ascii\rThe -i flag adds MIME type information along with the file description.\nCommon File Commands pwd (Print Working Directory) pwd - Displays the current working directory. ~ tilde character at the start of a path mean the current users home directory ~/data refers to /Users/sujith/data, useful for absolute path typing.\ncd (Change Directory) cd - Used to change the current directory.\ncd /home/user/Documents cd ~ # Go to the home directory cd .. # Go to the parent directory cd - # Toggle to previous directory cd / # goes to root directory cd ../.. # goes up two levels (parent of parent)\rls (List Directory Contents) Lists files in the current directory with several options:\nmv (Move or Rename Files) Used to move or rename files and directories.\n-f: Force move (overwrite without prompting). -i: Interactive move (prompt before overwriting). -n: Do not overwrite existing files. mv oldfile.txt newfile.txt mv file1 /home/user/dir/ # Move file1 to a directory\rcp (Copy Files) Copies files or directories.\n-r: Recursive copy (used for directories). -b: Create backups of each destination file. -L: Follow symbolic links. -p: Preserve the original file’s metadata (permissions, timestamps). -v: Verbose mode (shows each step). -I -s Create hard/symbolic link rather than physical copy -u copy only if source is newer than the destination or destination missing cp file1.txt file2.txt # Copy a file cp -r dir1 dir2 # Copy a directory recursively\rrm (Remove Files) Deletes files and directories.\n-f: Force removal (no confirmation). -i: Interactive removal (prompt before each deletion). -r: Recursive removal (for directories). rm file1.txt rm -r dir1 # Remove a directory and its contents\rmkdir (Make Directory) Creates a new directory.\nmkdir newdir\rrmdir (Remove Directory) Removes an empty directory.\nrmdir emptydir\rcat (Concatenate and Display Files) Displays the contents of files.\n-n: Add line numbers to output. -T: Show tab characters as ^I. cat file.txt cat -n file.txt # Display with line numbers\rless (View File Content Page by Page) Displays a file\u0026rsquo;s content one screen at a time.\n-c: Clear the screen before displaying content. -f: Open non-regular files. less file.txt\rmore (View File Content Page by Page) Similar to less, but with fewer features.\n-num #: Specify screen size in rows. +#: Start viewing at a specific line number. more file.txt more -10 file.txt # View file starting at line 10\rhead (Display the First Part of a File) Displays the first 10 lines of a file by default.\n-n #: Specify the number of lines to display. -c #: Display the first number of bytes. head file.txt head -n 5 file.txt # Display the first 5 lines\rtail (Display the End of a File) Displays the last 10 lines of a file by default.\n-n #: Specify the number of lines to display. -c #: Display the last number of bytes. tail file.txt tail -n 5 file.txt # Display the last 5 lines\rfind (Locate Files) Searches for files based on conditions like name, type, size, etc.\nfind /home/user/ -name \u0026#34;*.txt\u0026#34; # Find all .txt files find / -type d -name \u0026#34;mydir\u0026#34; # Find a directory named \u0026#34;mydir\u0026#34;\rcmp (Compare Files) Compares two files byte by byte.\n-i : Ignore case differences. -E : Ignore tabs. -Z : Ignore trailing space -b : Ignore white space -B : Ignore blank lines cmp file1.txt file2.txt\rcut (Remove Portions of Each Line) Extracts parts of lines from a file based on specified delimiters.\n-b: Select bytes. -c: Select characters. -d: Specify a delimiter. -f: Select specific fields. cut -d: -f1 /etc/passwd # Extract first field of /etc/passwd\rwc (Word Count) Counts lines, words, and characters in a file.\n-c: Count characters. -w: Count words. -l: Count lines. wc file.txt wc -l file.txt # Count lines in file\rtouch (Create/Modify File Timestamps) Creates a new empty file or updates the access/modification timestamp of an existing file.\n-a: Update access time. -m: Update modification time. touch newfile.txt # Create a new empty file\rDirectory Stack Commands If you need to manage multiple directories you frequent, you can use the directory stack:\npushd \u0026lt;dirname\u0026gt;: Adds a directory to the stack and changes to it. popd: Removes the top directory from the stack and switches to it. dirs: Displays the contents of the directory stack. ","date":"2024-12-29","id":139,"permalink":"/personal-site/docs/bash-linux/linux_bash/bash-08-basic-file-commands/","summary":"\u003cp\u003eMany file commands can operate on many different types of items because Linux treats them all as files.\u003cbr\u003e\nLinux treats various entities such as regular files, directories, symbolic links, pipes, sockets, and device files as files.\u003c/p\u003e","tags":[],"title":"Bash - 08 - Basic File Commands"},{"content":"Key concepts related to storage and file management in Linux.\nFile Space File space is the physical collection of storage devices (like hard drives or SSDs) used to store files and makes up the locations of all files and directories. This space can be viewed in two ways:\nLogical View: This is the way we interact with files and directories. Files and directories are organized hierarchically and accessed by logical names (e.g., home/user/documents).\nPhysical View: This is the actual layout of the files on physical storage devices. We can view the file space as devices, partitions, mountings and breakdown of the files into their disk block. The files are stored as blocks scattered across disk surfaces.\nOS have commands to show both views but we prefer to see logical view.\nFiles and Directories Files: A File is the smallest logical unit within the file space. It is a container for storing information or a sequence of characters. It has properties like name, type, and data.\nThe file will contain only what is written in it, there is no end-of-file (eof) mark. A file\u0026rsquo;s size, nor even it\u0026rsquo;s name is not stored in the file itself. It is all kept separately in the disk which is only accessible to the kernel.\nFiles are stored as a collection of disk blocks. These blocks might not be stored contiguously on the disk and can be scattered.\nUNIX treats directories and devices also as files only, so is the shell and kernel.\nOrdinary file (Regular files) :\nContains only data as a stream of characters. Text files and Binary files.\nText file contains printable characters which makes up viewable contents. Binary files contain both printable and unprintable characters that cover the entire ASCII range. Most of UNIX commands are Binary files. Executable files, Pictures, sound and video files are all binary files.\nDirectory files :\nA directory contains no data but keeps the names of files / directories it contains and a number associated with them called the inode number.\nDevice files :\nAll devices and peripherals are represented by files. To read or write a device, operations has to be performed on its associated file.\nDevice file names are usually found within the /dev directory.\nDirectories: Directories are a folder to store filenames and other directories.\nDirectories are used to organize files in a hierarchical structure. Sub-directories can be created within a directory to form a deeper organizational structure.\nPartitioning A partition is a physical division of storage on a device. Linux allows partitions to be mounted into specific locations (directories) in the filesystem. Partitions can be used to separate system files, user files, and virtual memory (swap space).\nMounting: The process of associating a partition with a directory so that the files on the partition are accessible through that directory. For backing up, we can unmount a specific partition containing that content and while unmounted, no one can access it. Other partitions will not be affected.\nLogical Volume Manager (LVM): An alternative to physical partitioning that allows more flexible management of disk space so no restriction on partition growth. It can dynamically allocate disk space without the need for physical partitions, but it may introduce overhead to disk access and also problem loading kernel files.\nLinux offers three separate partitions: /boot, LVM and swap /boot must be separated from LVM and also swap as swap space (virtual memory) is treated differently from rest of the file space and not directly accessed by the user.\nInode An inode is additional part of Linux file space, it is a data structure that doesn\u0026rsquo;t contain the name and contents but stores all metadata about a file, such as:\nFile type (regular file, directory, symbolic link, etc.) File owner UID and group GID File Permissions (nine permissions and three more) Timestamps (creation, modification, access times) An Array of Pointers to the data blocks on disk that store the file\u0026rsquo;s content Number of links (number of aliases the file has) File size in bytes Each file, directory, and symbolic link has an associated inode. The inode does not contain the file\u0026rsquo;s name, but the name is associated with the inode through directory entries.\nLinks link is a pointer which points from a file in a directory to its inode which contains pointers to point at the files\u0026rsquo;s physical blocks.\nHard Link: Points directly at the file\u0026rsquo;s inode. A hard link is a direct reference to the inode of a file. Multiple hard links can point to the same inode, and they are indistinguishable from the original file. When the link count of a file (i.e., the number of hard links) is greater than one, the file is still accessible as long as one link exists.\nSymbolic (Soft) Link: Points at a hard link. A symbolic link is a reference to another file or directory by its path. A symbolic link can point to a file in another directory and is distinguishable from regular files by the leading l in the file permissions (lrwxrwxrwx).\nThe name is indicated as link -\u0026gt; file where link is the symbolic link and the file is the item being pointed at. The file will be in another directory.\nRelative and Absolute Paths We will be in current working directory and accessing files in another directory needs specifying a directory path.\nThere are two primary ways to access files:\nAbsolute Path: Starts from the root directory (/) and specifies the full path to a file or directory. /home/user/Documents/file.txt\nRelative Path: Describes the location relative to the current working directory. It does not start with a / and uses . for the current directory and .. for the parent directory. ../Documents/file.txt (moving up one directory and then down into Documents).\nSpecial Directory References:\n. : Represents the current directory. .. : Represents the parent directory. The path can be omitted for executable files if the file is stored in our PATH variable. PATH Variable The PATH environment variable holds a list of directories where executable files are located. When you type a command like ls or cat, the system checks these directories to find the corresponding executable.\n/home/sujith/.nvm/versions/node/v20.17.0/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/snap/bin:/snap/bin\rPATH variable can be modified, to add new directories:\nPATH=$PATH:/new/directory PATH=new_directory:$PATH\rFilename Arguments and Wildcards Wildcard Expansion (Globbing): Bash allows the use of wildcards (also called globbing) to match multiple files. *: Matches any number of characters. ?: Matches exactly one character. [chars]: Matches one character from the specified list. [char1-char2]: Matches one character within the specified range. [0-9] [a-e] [A-Z] {word1,word2, word3}: Matches any of the specified words. [!chars] match any one character not in the list ls [!a]* means first character not a ls *.txt: Lists all files with a .txt extension. ls f*: Lists all files starting with f.\nls [abc]*: Lists all files starting with either a, b, or c. [] is for one character only. ls [abc][abc][abc]\nls file?.{dat,txt}: Lists files like file1.dat, file2.txt, etc.\nThe Top-Level Directory Structure [image of top-level directory structure of Linux]\nEvery Linux distribution has a standard set of top-level directories. Some of the common top-level directories include:\n/boot: Contains files required to boot the system, such as the Linux kernel.\n/dev: Contains all device files, which represent hardware devices. These files do not occupy space on the disk.\n/etc: Contains system configuration files.\n/proc: A virtual filesystem providing information about processes and kernel parameters.\n/usr: Contains user binaries, libraries, and documentation.\n/usr/share/man : Contains the man pages.\n/bin and /usr/bin : Contains all commonly used UNIX commands (Binaries, hence the name bin).\n/sbin and /usr/sbin : Commands a system administrator can execute would be in these directories.\nUsers work with their own files, write programs and create files. These are available in /tmp, /var, /home.\n/home: The home directory for all the users.\n/tmp : Where a user is allowed to create temporary files which are wiped away regularly by the system.\n/var: Contains variable data such as log files and databases of the file system.\n","date":"2024-12-29","id":140,"permalink":"/personal-site/docs/bash-linux/linux_bash/bash-07-storage-terminology-in-linux/","summary":"\u003cp\u003eKey concepts related to storage and file management in Linux.\u003c/p\u003e\n\u003ch4 id=\"file-space\"\u003e\u003cstrong\u003eFile Space\u003c/strong\u003e\u003c/h4\u003e\n\u003cp\u003eFile space is the physical collection of storage devices (like hard drives or SSDs) used to store files and makes up the locations of all files and directories. This space can be viewed in two ways:\u003c/p\u003e","tags":[],"title":"Bash - 07 - Storage Terminology in Linux"},{"content":"The date command in Unix-like operating systems is used to display or set the system date and time.\ndate [OPTION]... [+FORMAT] date [-u|--utc|--universal] [MMDDhhmm[[CC]YY][]]\rOPTION : Various options to customize how the date is displayed. FORMAT : The format in which you want to display the date. (it has to follow +)\ndate Format Specifiers $ date +%a : Abbreviated weekday name (e.g., Sun, Mon) $ date +%A : Full weekday name (e.g., Sunday, Monday) $ date +%b : Abbreviated month name (e.g., Jan, Feb) $ date +%B : Full month name (e.g., January, February) $ date +%m : Month as a number (01 to 12) $ date +%d: Day of the month (01 to 31) $ date +%H: Hour in 24-hour format (00 to 23) $ date +%I: Hour in 12-hour format (01 to 12) $ date +%r: 12-hour clock time (hh:mm:ss AM/PM) $ date +%R: 24-hour format time without seconds (hh:mm) $ date +%T: Time in 24-hour format with seconds (hh:mm:ss). $ date +%Y : Year with century (e.g., 2024) $ date +%j : Day of the year (001 to 366) $ date +%s : Seconds since the Unix epoch (January 1, 1970) Customizing Date Output Combine multiple format specifiers to display a custom formatted date.\nCombining two Formats\n$ date +%a:%A Sun:Sunday\r$ date \u0026#34;+%a, %b %d, %Y - %r\u0026#34; Sun, Dec 31, 2024 - 02:00:00 PM\rMaking a Date String: The -d or --date option allows to specify a date string, which date will interpret and display.\n$ date --date=\u0026#39;@2147483647\u0026#39; Wed Feb 16 06:46:07 UTC 2038\rThis will display the date corresponding to the Unix timestamp 2147483647.\nUTC/Universal Time: The -u, --utc, or --universal option allows you to display the date and time in UTC.\n$ date -u Tue Dec 31 23:59:59 UTC 2024\rbc (Basic Calculator) bc is an arbitrary precision calculator language. It\u0026rsquo;s used for performing arithmetic operations, and it supports a variety of functions and operations, including basic math, variable assignments, and more.\nInteractive Mode or Command-Line Usage\nSimply typing bc will start an interactive mode, where we can input mathematical expressions and get results.\nWe can also use bc for calculations directly from the command line.\n$ echo \u0026#34;3 + 4\u0026#34; | bc 7\rSome Key Operators in bc: Arithmetic: +, -, *, /, ^ (exponentiation) Comparison: ==, !=, \u0026lt;, \u0026gt;, \u0026lt;=, \u0026gt;= Logical: \u0026amp;\u0026amp;, || Bitwise: \u0026amp;, |, ^, ~, \u0026lt;\u0026lt;, \u0026gt;\u0026gt; Options -l (Standard Math Library) : loads the standard math library, which enables functions like sine, cosine, sqrt, exp, etc.\n$ echo \u0026#34;scale=2; sqrt(2)\u0026#34; | bc -l 1.41\rscale : The scale variable determines the number of decimal places in the output.\n$ echo \u0026#34;scale=3; 22/7\u0026#34; | bc 3.142\r-q (Quiet Mode): Suppresses the welcome message that is normally displayed.\n$ bc -q\r-s (Single Precision Mode) : Forces bc to use single precision for floating-point calculations (often leading to fewer decimal places).\n$ echo \u0026#34;scale=3; 1/3\u0026#34; | bc -s 0.333\rMath Functions Available with -l :\nTrigonometric: s(), c(), a(), etc. (for sine, cosine, arctangent, etc.) Logarithmic: l(), e(), etc. Exponential: exp(), etc. Example Commands: Addition and Division: $ echo \u0026#34;5 + 3\u0026#34; | bc 8 $ echo \u0026#34;10 / 4\u0026#34; | bc 2\rUsing scale for Decimal Precision: $ echo \u0026#34;scale=4; 7/3\u0026#34; | bc 2.3333\rUsing Functions with -l: $ echo \u0026#34;scale=5; sqrt(100)\u0026#34; | bc -l 10.00000\rAssigning Variables: $ echo \u0026#34;a=5; b=3; a*b\u0026#34; | bc 15\r","date":"2025-01-01","id":141,"permalink":"/personal-site/docs/bash-linux/linux_bash/bash-08.1-bc-and-date/","summary":"\u003cp\u003eThe \u003ccode\u003edate\u003c/code\u003e command in Unix-like operating systems is used to display or set the system date and time.\u003c/p\u003e\n\r\n\r\n\r\n\u003cdiv class=\"expressive-code\"\u003e\r\n  \u003cfigure class=\"frame not-content\"\u003e\r\n  \u003cfigcaption class=\"header\"\u003e\r\n    \u003cspan class=\"title\"\u003e\u003c/span\u003e\r\n  \u003c/figcaption\u003e\r\n  \u003cdiv class=\"highlight\" frame=\"none\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003edate \u003cspan class=\"o\"\u003e[\u003c/span\u003eOPTION\u003cspan class=\"o\"\u003e]\u003c/span\u003e... \u003cspan class=\"o\"\u003e[\u003c/span\u003e+FORMAT\u003cspan class=\"o\"\u003e]\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003edate \u003cspan class=\"o\"\u003e[\u003c/span\u003e-u\u003cspan class=\"p\"\u003e|\u003c/span\u003e--utc\u003cspan class=\"p\"\u003e|\u003c/span\u003e--universal\u003cspan class=\"o\"\u003e]\u003c/span\u003e \u003cspan class=\"o\"\u003e[\u003c/span\u003eMMDDhhmm\u003cspan class=\"o\"\u003e[[\u003c/span\u003eCC\u003cspan class=\"o\"\u003e]\u003c/span\u003eYY\u003cspan class=\"o\"\u003e][]]\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\r\n  \u003c/figure\u003e\r\n\u003c/div\u003e\r\n\u003cp\u003e\u003cstrong\u003eOPTION\u003c/strong\u003e : Various options to customize how the date is displayed.\n\u003cstrong\u003eFORMAT\u003c/strong\u003e : The format in which you want to display the date. (it has to follow \u003ccode\u003e+\u003c/code\u003e)\u003c/p\u003e","tags":[],"title":"Bash - 08.1 - bc and date"},{"content":"Naming Conventions\nAvoid spaces; use _ or - instead. Do not start names with - to prevent confusion with options/flags. Stick to characters: 0-9, a-z, ., -, _. Special characters can have different meanings. Use single quotes ' ' for names with spaces or special characters. File Movement and Copy Command Moving / Renaming (mv), copying (cp), creating, deleting (rm) files and directories.\nThese work by modifying the directory entries of the files they access.\ncp adds an entry to the directory with the name of destination file and inode number that is allotted by the kernel. mv replaces the name of an existing directory entry without disturbing its inode number. rm removes an entry from the directory. mv mv is used to move or rename both files and directories.\nmv [options] source destination\rTo rename a file, source is the old name and destination is the new name. Otherwise, both need to be in different directories. If destination is a directory without a file name, the file\u0026rsquo;s name is not changed.\nmv fo1.txt ~/temp # moves to temp mv fo1.txt ~/temp/fo2.txt # moves and renames mv *.txt /home/zapp\rTo move a file into the current directory, . can be used as the destination.\nRenaming Files To rename a file or move it to a new location:\nmv [old] [new] # Moves or renames a file\rmv trial/draft.txt trial/quotes.txt # Renames draft.txt to quotes.txt mv draft.txt quotes.txt # Renames within the same directory\rNote: Moving a file to a directory with the same name will silently overwrite the original. Use mv -i to prompt for confirmation.\nTo move files to a different directory:\nmv trial/quotes.txt . # Moves to the current directory mv sucrose.dat maltase.dat ../raw # Moves files to the parent directory\u0026#39;s raw folder\rWe are not allowed to rename multiple files using a single mv command as it has only a single destination parameter. mv *.txt *.dat will cause an error because *.dat means multiple destinations, but it needs to be a single directory or file name.\n-i and -f are interactive and force modes. The difference occurs when a file being moved has the same name at the destination. If not interactive, the destination file is overwritten.\ncp The format is the same as mv:\ncp [options] source destination\rcp [old] [new] # Copies a file cp quotes.txt thesis/quotation.txt # Copies to a new location\rThere are three combinations that can be used:\nDestination is another directory, then the file name remains the same after copying. Destination is a directory and a file name, then the file is copied with a new name. Destination is a filename, then the file is copied into the current directory with a new name. cp fo.txt ~zap/fo1.txt cp *.txt ~ cp ~zapp/foo.txt .\r-i and -f remain the same as mv.\n-b: Creates a backup of every destination file. -I/-s: Creates a hard or symbolic link rather than a physical copy. -u: Copies only if the source is newer than the destination or if the destination is missing. -L: If the source is a symbolic link, it follows the link to the actual file and copies that file, not the link. -v: Provides output for each file copied. (verbose) -p: Preserves the original ownership, permissions, and timestamps. (When cp creates a copy, it\u0026rsquo;s ownership and permissions are updated to that pf the user who issued the command.) -r: Recursive copy for directories and their contents. To copy a directory and all its contents, use -r:\ncp -r thesis thesis_backup # Copies the entire directory\rOperations with Multiple Files and Directories To copy or move multiple files, list the files followed by the target directory. If given more than one file name followed by a directory name, the directory must be the last argument.\ncp file1.txt file2.txt target_directory/ # Copy multiple files mv file1.txt file2.txt target_directory/ # Move multiple files\rUsing wildcards simplifies this process:\ncp *.txt backup/ # Copies all .txt files to backup/\r$ mkdir backup $ cp cretures/minotaur.dat creatures/unicorn.dat backup/ $ cp minotaur.dat unicorn.dat basilisk.dat # Error occurs with multiple files; use wildcards instead\rWildcards Wildcards represent unknown characters in commands.\nCommon wildcards include:\n*: Represents zero or more characters.\n*.pdb matches all files ending with .pdb. *ethane.pdb matches ethane and methane. p*.pdb matches files starting with p and ending with .pdb. ?: Represents exactly one character.\n?ethane.pdb matches methane.pdb. Using Wildcards in Commands ls *t*ane.pdb # Lists files with \u0026#39;t\u0026#39; and \u0026#39;ane\u0026#39; in their names cp *dataset* backup/datasets # Copies all files with \u0026#39;dataset\u0026#39; in the name ls *t?ne.* # matches octane, pentane ls *t??ne.pdb # matches ethane, methane ls ethane.* # only ethane\rWildcards can be combined for more specific patterns:\nls ???ane.pdb # Matches any three characters followed by \u0026#39;ane.pdb\u0026#39;\rWhen a shell sees a wildcard, it expands the wildcard to create a list of matching filenames before running the preceding command.\nNote: Be cautious when using wildcards, as errors can occur if not handled properly (e.g., *.pdf in a directory with .pdb files).\nUsing Wildcards for Copying $ cp *dataset* backup/datasets # Copy anything with \u0026#39;dataset\u0026#39; in the name to the datasets directory inside backups $ cp *calibration.txt backup/calibration # Copy all calibration files $ cp 2015-11-* send_to_bob/all_november_files/ # Copy just November files $ cp *-23-dataset* send_to_bob/all_datasets_created_on_23rd/ # Copy only 23rd files\rrm rm is the delete command.\nrm [options] file(s)\rIt can work on multiple files by listing, using wildcards, or both.\nrm my_file.txt # Deletes the specified file\rUse rm -i to prompt for confirmation before deletion. rm permanently deletes files, so it\u0026rsquo;s advisable to use -i to ask for confirmation before deleting. The alias for rm can be set as rm -i\nIf too many files are being deleted and you want to override the prompts, use -f, but this can be dangerous: rm -f *.txt.\nrm cannot remove directories directly. To remove a directory and its contents, use the recursive -r option:\nrm -r directory_name # Deletes the directory and all its contents\rTo delete a complete sub-hierarchy and override the prompts, use rm -fr *.\nTo remove files matching a pattern (e.g., all .txt files) with confirmation: rm -i *.txt # Prompts for each .txt file\rNote: The shell does not have a trash bin, so deleted files are permanently removed.\nrmdir is the only way to delete an empty directory. Use rmdir -p to recursively delete parent and current directories.\nmkdir Creating Directories Used to create a directory, in the current directory or a specified path.\n-m --mode: Specify the initial permissions of the directory. -z --context: Specify the SELinux context. mkdir [name] # Create a directory\rTo create multiple directories at once:\nmkdir north south pacific # Creates three separate directories\rCreating a Directory Tree, by creating the main directory first, then child directories inside.\nmkdir place place/one place/two\rThe -p option is used to create multiple directories at once:\nmkdir -p [path/to/nested/directories] # Creates nested directories mkdir -p ../project/data ../project/results\rTo list all nested subdirectories within a directory, use ls -R.\nExample: To create a directory 2016 with a sub-directory data that contains two directories, processed and raw:\nMethod 1: Step-by-Step Creation\nmkdir 2016 mkdir 2016/data mkdir 2016/data/processed mkdir 2016/data/raw\rMethod 2: Navigating and Creating\nmkdir 2016 cd 2016 mkdir data cd data mkdir processed raw\rMethod 3: Using -p\nmkdir -p 2016/data/{processed,raw} # Creates the full structure in one command\r","date":"2024-12-29","id":142,"permalink":"/personal-site/docs/bash-linux/linux_bash/bash-09-file-movement-and-copy-commands/","summary":"\u003cp\u003e\u003cem\u003e\u003cstrong\u003eNaming Conventions\u003c/strong\u003e\u003c/em\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eAvoid spaces; use \u003ccode\u003e_\u003c/code\u003e or \u003ccode\u003e-\u003c/code\u003e instead.\u003c/li\u003e\n\u003cli\u003eDo not start names with \u003ccode\u003e-\u003c/code\u003e to prevent confusion with options/flags.\u003c/li\u003e\n\u003cli\u003eStick to characters: \u003ccode\u003e0-9\u003c/code\u003e, \u003ccode\u003ea-z\u003c/code\u003e, \u003ccode\u003e.\u003c/code\u003e, \u003ccode\u003e-\u003c/code\u003e, \u003ccode\u003e_\u003c/code\u003e. Special characters can have different meanings.\u003c/li\u003e\n\u003cli\u003eUse single quotes \u003ccode\u003e' '\u003c/code\u003e for names with spaces or special characters.\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003ch3 id=\"file-movement-and-copy-command\"\u003eFile Movement and Copy Command\u003c/h3\u003e\n\u003cp\u003eMoving / Renaming (\u003ccode\u003emv\u003c/code\u003e), copying (\u003ccode\u003ecp\u003c/code\u003e), creating, deleting (\u003ccode\u003erm\u003c/code\u003e) files and directories.\u003cbr\u003e\nThese work by modifying the directory entries of the files they access.\u003c/p\u003e","tags":[],"title":"Bash - 09 - File Movement and Copy Commands"},{"content":"Filters are Commands which accepts data from standard input, manipulates it and write the result to standard output.\nEach performs a simple function, these can be combined with other tools using redirection and piping.\n1. File Creation and Editing Creating a Text File Using the Nano Editor To create a text file with the nano editor:\nnano draft.txt # Opens nano for editing\rEditing in Nano:\nType your content, then save using Ctrl + O, followed by Enter, and exit with Ctrl + X. Note: nano is a simple text editor suitable for plain text files. For more complex editing, consider Emacs, Vim, or graphical editors like Gedit or VS Code. Alternatives: On Windows, you can use editors like Notepad++ or Notepad.\nCreating a Blank File with touch touch my_file.txt # Creates a blank text file\rtouch primarily modifies the last access or modification time of a file. If the file doesn’t exist, it creates an empty one.\n-a: Modifies only the access time. -m: Modifies only the modification time. -t: Allows you to specify a custom timestamp in the format [[CC]YY]MMDDhhmm[.ss]. 2. Text File Viewing and Analysis Word Count with wc The wc command outputs the count of characters (bytes), words (whitespace between characters), and lines (\\n) in a text file.\n-c, -m: Limits count to characters. -l: Line count. -w: Word count. -L: Displays the length of the longest line. wc -l *.pdb # Displays the word count for all .pdb files in the current directory\rPiping the result of a command to wc: Counts the number of lines in the output of ls -l\nls -l | wc -l\rIf wc -l is run without specifying a filename, it waits for input, can exit using Ctrl + C.\nFinding Printable Characters with strings strings sujith.jpeg -n 10\rstrings extracts printable characters from a file, even from binary files like .jpeg. -n number can override the length of strings to search for. 6*\u0026amp;\u0026amp;*6\u0026gt;424\u0026gt;LDDL_Z_|| 6*\u0026amp;\u0026amp;*6\u0026gt;424\u0026gt;LDDL_Z_|| Bm\u0026amp;EmvX{2; !1 0AQ@Paq\r3. Text File Navigation Commands Viewing Files with more, less, and cat cat: Displays the entire content of a file. Best for small files.\nmore: Displays a screen of content at a time. Press \u0026lt;space\u0026gt; to scroll forward, and q to quit.\n-n: Specify the number of lines to show per screen.\n+linenumber: Start viewing from a specific line number.\nless: Similar to more, but allows both forward and backward navigation with arrow keys. To quit, press q.\nBonus: less works like a vi browser, allowing vi-style navigation.\nViewing Specific Parts of a File with head and tail head and tail head: By default, shows the first 10 lines of a file.\nWe can precede the integer with a minus sign to indicate that the program should skip that number of bytes or lines.\nhead -n 5 file.txt: Displays the first 5 lines. head -n -3 file.txt: Shows all but the last 3 lines. head -c -20 file.txt: Stops at the 21st byte of the file. tail: By default, shows the last 10 lines of a file.\nPrecede the integer with plus to indicate the starting point within the file.\ntail -n 5 file.txt: Displays the last 5 lines. tail -n +12 file.txt: Displays the file starting from line 12. 4. Sorting and Manipulating Files Sorting Files with sort The sort command sorts lines of text files / output:\nsort lengths.txt # Sorts alphanumerically by default sort -n # Sorts numerically sort -r # Sorts in reverse order\r-r: Reverse order. -f: Ignore case differences. -n: Numeric sorting. Sort doesn\u0026rsquo;t change the file, but sends results to screen.\nTo sort a file and redirect the output to a new file:\nsort -n lengths.txt \u0026gt; sorted-lengths.txt\r5. File Comparison and Difference Commands Comparing Files with cmp, comm, and diff cmp : Comparing two files cmp: Compares two files byte by byte. It stops when the first difference is found, showing the byte and line number.\ncmp file1 file2 -i 100:150 -n 1024\rCompares files one and two, starting at 101 of file1 and 151 of file2. Comparing 1024 bytes.\ncmp can be forced to skip over a specified number of bytes for each file or stop after reaching a specified limit. If no mismatch then no output. The default counting used with cmp -i (--ignore-initial) is a value in bytes (characters)\nWhen the two files are identical, cmp returns a prompt without any message. This behavior is important as comparison return a true value which is used in shell script to control the flow of the program.\ncomm : What is Common? comm: Compares two sorted files and outputs three columns:\nColumn 1: Lines only in the first file. Column 2: Lines common to both files. Column 3: Lines only in the second file. Options can be used to drop a particular column, they can also be combined. -1: Suppress lines unique to the first file.\n-2: Suppress lines unique to the second file.\n-3: Suppress lines common to both files.\ndiff : Converting one file to another. diff: Compares two files or directories and outputs differences. Useful for checking changes between files.\nIt also tells which lines have to be changed to make the two files identical using special symbols and instructions to indicate the changes required.\n-i: Case-insensitive comparison.\n-b: Ignore differences in spaces.\n-y: Output in columns for side-by-side comparison.\nRemoving Duplicate Lines with uniq It operates on a single file, searching for consecutive duplicate lines. Parameters can be used to remove duplicate lines.\nIt does not overwrite the file but the output can be can be moved to a new file.\nuniq file.txt \u0026gt; file_without_duplicates.txt\r-c for counting occurrences,\n-d for displaying only duplicate lines.\n6. File Manipulation Commands Joining Files with join Joins two sorted files based on a common field (default is field 1).\njoin file1.txt file2.txt\rWhen the two files contain a row that contains that same value, then those two lines are joined together. Lines that do not contain a matching first field are not joined.\n(Joining tables using a matching keys)\n-1 NUM: Specifies which field to join on in the first file.\n-2 NUM: Specifies which field to join on in the second file.\n-i: Ignore case differences.\n-e uses STRING in place of an empty field\n-a 1 or -a 2 outputs lines from the first or second file which did not contain a match to the other file.\nMerging Files with paste paste file1.txt file2.txt\rpaste merges files line by line without requiring a common field. The first line is appended to the first line of other file.\nSplitting Files with split split -b 1000 file.txt prefix\rsplit divides a large file into smaller files. By default, each file is 1000 bytes.\nWe specify the file to split and a prefix which is name used for new files.\n-b value: Specifies the byte size per file.\n-d: Use numeric suffixes (e.g., 00, 01).\nExtracting Data with cut Slitting a file vertically.\nThe cut command is used to remove or extract specific sections of each line in a file:\ncut -d , -f 2 animals.csv # Extracts the second field from a comma-delimited file\r-d: Specifies the delimiter (e.g., comma, space).\n-f: Specifies the field(s) to extract.\n--complement: Returns everything except the specified fields.\nTo get the three (fields)columns of data within a table which are delimited by tab\ncut -f 3,4,6 file\rif the delimiter was space then it has to specified using -d ' '\nWe can pipe the results of other command to reduce the output.\nTo remove duplicates from the output, you can pipe cut into sort and uniq:\n$ cut -d , -f 2 animals.csv | sort | uniq\rRemoving the duplicates using uniq\nUsing uniq -c gives the count of occurrences for each line in input.\nls -l | cut -c 2-10 outputs only the permissions of the files which starts from 2nd character to 10th.\nsujith@sujith-Latitude-7490:~/Desktop$ ls -l | cut -c 2-10 otal 56 rw-rw-r-- rwxrwxr-x rw-rw-r-- rwxr-xr-x rwxr-xr-x rwxrwxr-x rwxrwxr-x rwxrwxr-x\rTo get the permissions and the file name (getting the first 2-10 chars and also the 9th field where the names are present, with delimiter being space.) ls -l | cut -f 1,9 -d ' ' won\u0026rsquo;t work properly due to unevenness.\n(awk offers better solution that cut for selecting fields)\nExample Workflow cd nart-pacific-gyre wc -l *.txt # Get the word count for all .txt files wc -l *.txt | sort -n | head -n 5 # Display the first five file line counts wc -l *.txt | sort -n | tail -n 5 # Display the last five file line counts\rText Editors: vi and vim vi (or its improved version vim) is the default text editor found in most Linux distributions. It is used for editing text files from the command line. vim (Vi IMproved) offers additional features like syntax highlighting, better search functionalities, and more. While vi is still widely used, vim is recommended due to its enhanced capabilities.\n","date":"2024-12-29","id":143,"permalink":"/personal-site/docs/bash-linux/linux_bash/bash-10-file-viewing-and-editing-commands/","summary":"\u003cp\u003eFilters are Commands which accepts data from standard input, manipulates it and write the result to standard output.\u003cbr\u003e\nEach performs a simple function, these can be combined with other tools using redirection and piping.\u003c/p\u003e","tags":[],"title":"Bash - 10 - File Viewing and Editing Commands"},{"content":"File permissions are a mechanism that supports operating system protection, ensuring that users do not misuse system resources like CPU, memory, or the network.\nSince users primarily interact with files, the resources that we protect with permissions are files and directories.\nAccess Control Mechanism Many operating systems implement file permissions using Access Control Lists (ACLs). An ACL is attached to a specific file or directory and lists the users and groups that have access rights to that resource. The list can become lengthy, depending on the number of users.\nEach user or group can have specific access rights to a file.\nThe owner might have read, write, and execute permissions. Other users (members of the group or the world) might have different levels of access, such as read or execute only. Permission Types and Access Rights In Linux, file permissions are defined for three categories:\nOwner (u) Group (g) Others (o), also known as world Access Rights: r (read):\nFor files: Allows viewing, copying, or opening as read-only. For directories: Allows listing the contents with ls. w (write):\nFor files: Allows overwriting or modifying the file. For directories: Allows creating, modifying, or deleting files in the directory. x (execute):\nFor files: Allows executing the file (important for programs or shell scripts). For directories: Allows cd into the directory. Changing Permissions from the Command Line Using the chmod Command chmod (change mode) is used to alter the permissions of a file or directory.\nchmod permissions file(s)\rfile(s) refers to the file(s) or directories to which you want to apply the permissions.\npermissions can be specified in three ways: using symbols (+, -, =), or numeric values (3-digit numbers).\n1. Using + and - for Permission Changes This approach adds (+) or removes (-) specific permissions for the user (u), group (g), or others (o) along with r, w, x\nTo remove write permission for the group and read permission for others:\nchmod g-w,o-r file.txt\rTo add execute permission for the owner and group:\nchmod u+x,g+x file.txt\rTo apply changes to all categories (owner, group, others) at once using a:\nchmod a+x file.txt\r2. Using = to Set Exact Permissions Instead of adding or removing permissions, you can assign permissions directly using =.\nTo assign rwx (read, write, and execute) permissions to the owner, r (read) to the group, and no permissions to others:\nchmod u=rwx,g=r,o= file.txt\rIf you do not specify a category (like u=), it will not change the permissions for that category:\nchmod g=,o= file.txt # Does not change owner permissions\rYou can combine = with + or -:\nchmod u=rwx,g-w,o-r file chmod u=rwx,g-w,o= file chmod u+x,g=r,o-r file chmod u+x,g-w,o= file\r3. Using Numeric Permissions This approach uses 3-digit numbers to represent permissions. Each digit corresponds to the permissions for owner, group, and others, respectively.\nThe numbers are calculated by adding:\n4 for read (r) 2 for write (w) 1 for execute (x) To set rwx (7), r-x (5), and no permissions (0) for owner, group, and others respectively:\nchmod 750 file.txt # rwx (7) for owner, r-x (5) for group, no permissions (0) for others\rBreakdown of Permission Calculation: rwx = 4 + 2 + 1 = 7 r-x = 4 + 1 = 5 --- = 0 = 0 So, 750 represents the permissions rwx r-x ---.\n----- 000\n--x--x--x 111 r----- 400 Many more combinations\n[table of 3 digit permission meaning]\nPermission rwx rw- r-x --- Owner 7 6 5 0 Group 7 6 5 0 Others 7 6 5 0 Changing Ownership and Group Note: Only the root user can change ownership of files. Non-root users can only change the group of a file they own, provided they are a member of the target group.\nCommands to Change Ownership chown is used to change both owner and group of a file or directory.\nchown newowner file(s) chown newowner:newgroup file(s)\rchgrp is used to change only the group of a file.\nchgrp newgroup file(s)\rchown fox /home/fox/*.txt chown www:www /usr/local/apache/htdocs/* chgrp citg /home/fox/citg/project-data.txt\rChanging Permissions from the GUI Many File Browsers allow you to view and change file permissions graphically. You can typically right-click on a file or directory, select Properties, and then navigate to the Permissions tab to make changes.\nAdvanced Permissions There are additional, advanced permission types in Linux that provide more complex control over file access:\n1. SELinux (Security-Enhanced Linux) SELinux provides a more complex and granular mechanism for defining access policies compared to the traditional ugo/rwx permission system. SELinux operates at a higher level, allowing administrators to enforce security policies that go beyond basic file permissions.\n2. User ID (Setuid) and Group ID (Setgid) Setuid (s in the owner’s execute position) is used for executable files. When a user runs a setuid program, it executes with the privileges of the file owner, not the user running it. Setgid (s in the group’s execute position) is used for executable files or directories. When a setgid program is run, it executes with the privileges of the file\u0026rsquo;s group, not the user\u0026rsquo;s group. 3. Sticky Bit The sticky bit is used for directories. When set on a directory, it restricts the deletion of files within the directory so that only the owner of a file can delete or modify it, even if other users have write permissions for the directory.\nSetting the sticky bit on a directory: chmod +t /some/directory\rExample Scenario: A directory with 777 permissions would allow anyone to read, write, or execute files in it. However, when the sticky bit is set, only the file owner can delete or modify their files, even though others can still read and write.\n","date":"2024-12-29","id":144,"permalink":"/personal-site/docs/bash-linux/linux_bash/bash-11-file-permissions/","summary":"\u003cp\u003eFile permissions are a mechanism that supports operating system protection, ensuring that users do not misuse system resources like CPU, memory, or the network.\u003c/p\u003e","tags":[],"title":"Bash - 11 - File Permissions"},{"content":"In a file system, directories store links to files and subdirectories.\nThese links are primarily categorized into hard links and symbolic links (also called soft links). Both types of links allow files to have multiple names or references, but they function in different ways.\nHard Links A hard link is essentially an additional directory entry that associates a file name with the same inode number.\nAn inode is a data structure that stores information about a file, including its physical location on the disk.\nHow Hard Links Work A hard link consists of a file\u0026rsquo;s name and its associated inode number. Each file and directory has at least one hard link that connects its name in the directory to the inode, which contains the pointers to the actual file data on disk. Inodes contain metadata, such as the file\u0026rsquo;s size, permissions, and the physical disk block locations where the data is stored. A directory typically contains links to files and other directories. These links are always associated with inodes. A file can have multiple hard links, meaning it can be referenced by different names from different locations in the filesystem. All links point to the same inode, and thus, the same data. Characteristics of Hard Links Hard links are efficient because they don’t require additional storage for the content of the file, only another directory entry pointing to the same inode. Hard links can only be created within the same partition. For example, a hard link in /home cannot point to a file in /etc, as these are typically separate partitions. Deleting one hard link does not delete the file. The file will remain in the filesystem until all hard links to it are removed.\nExample: If a file has two hard links, the link count will be 2. Deleting one link reduces the count to 1, but the file still exists. Only when the last link is deleted does the file get removed from the filesystem. Permissions with Hard Links When creating a hard link, it inherits the permissions of the original file. The link does not have its own permissions; it simply points to the same inode, which determines access. Symbolic Links (Soft Links) A symbolic link (also known as a soft link) is a special type of file that contains a reference to another file or directory in the form of a path. Unlike hard links, symbolic links can span across partitions and point to files or directories located elsewhere in the filesystem.\nHow Symbolic Links Work A symbolic link is essentially a pointer to the original file or directory. It does not point directly to the inode of the target file; instead, it contains a path to the file or directory. This makes symbolic links more flexible but also less efficient than hard links. Symbolic links are identified by the l file type when viewed using the ls -l command. Symbolic links do not increase the link count of the original file, unlike hard links. Characteristics of Symbolic Links Symbolic links can point to files or directories that are located on different partitions or even remote systems. If the target of a symbolic link is deleted or moved, the symbolic link becomes a \u0026ldquo;dead link\u0026rdquo; (i.e., a broken reference that no longer points to an existing file). Deleting a symbolic link does not affect the target file or its link count, as the symbolic link is just a reference to the target, not part of the actual file structure. Permissions with Symbolic Links Symbolic links themselves have their own set of permissions, but they are typically not used to control access to the target file. Instead, permissions are controlled on the target file or directory. If a user does not have permission to access the original file, they won’t be able to follow the symbolic link to access it either. Creating Hard and Symbolic Links The ln command is used to create both hard and symbolic links.\nln [-s] existingfile newfile\rexistingfile: The file that you want to create a link to. newfile: The new link that you want to create. -s: (Optional) This flag is used to create a symbolic link. If omitted, the link created will be a hard link by default. Creating a Hard Link:\nln file1.txt file2.txt\rThis creates a hard link file2.txt that points to the same inode as file1.txt.\nCreating a Symbolic Link:\nln -s /path/to/original/file /path/to/link\rThis creates a symbolic link pointing to /path/to/original/file.\nKey Differences Between Hard and Symbolic Links Feature Hard Link Symbolic Link (Soft Link) Reference Points to the same inode as the original file. Points to the file path, not directly to the inode. Link Count Increases the link count of the file. Does not affect the original file\u0026rsquo;s link count. Cross-Partition Links Cannot span across partitions. Can span across partitions. Target File Deletion File is not deleted until all hard links are removed. If the target is deleted, the symlink becomes a dead link. Efficiency More efficient as it directly refers to the inode. Less efficient due to storing the file path. File Type Representation Displays as a regular file. Displays as a symbolic link (indicated by l in ls -l). Permissions Inherits permissions from the original file. Has its own permissions, but does not control access to the target file. Target Can only link to files within the same filesystem. Can link to files or directories across different filesystems. Common Use Cases Hard Links: Backup systems: Hard links are often used in backup systems to create multiple references to files, saving space without duplicating the data. File management: Allowing multiple names for the same file, useful in cases where you want to organize or move files but keep the same content under different names. Symbolic Links: Shortcut creation: Symbolic links are commonly used to create shortcuts to files or directories. For example, in user directories or for frequently used files. Redirecting files: Symbolic links can be used to point to files that have been moved to a different location, helping maintain compatibility with existing scripts or applications. Cross-partition linking: Because symbolic links can span filesystems, they are useful for linking files across different partitions. ","date":"2024-12-29","id":145,"permalink":"/personal-site/docs/bash-linux/linux_bash/bash-12-hard-and-soft-links/","summary":"\u003cp\u003eIn a file system, directories store links to files and subdirectories.\u003c/p\u003e\n\u003cp\u003eThese links are primarily categorized into \u003cstrong\u003ehard links\u003c/strong\u003e and \u003cstrong\u003esymbolic links\u003c/strong\u003e (also called soft links). Both types of links allow files to have multiple names or references, but they function in different ways.\u003c/p\u003e","tags":[],"title":"Bash - 12 - Hard and Soft Links"},{"content":"A regular expression (regex) is a string that defines a search pattern.\nIt consists of a combination of literal characters and meta-characters.\nThe meta-characters modify the literal characters to introduce flexibility and variability in pattern matching.\nregex can match more than just a literal string. It can match a wide range of text patterns, allowing for flexible search, validation, and manipulation of strings.\nRegular expressions are commonly used to search for strings that follow a pattern of interest.\n\u0026quot;aeiou\u0026quot; will match exactly the string \u0026quot;aeiou\u0026quot;. It does not allow for any variation.\n\u0026quot;[aeiou]{5}\u0026quot; will match any string that consists of five consecutive vowels (in lowercase). characters must appear consecutively. It will match strings like \u0026quot;aeiou\u0026quot;, \u0026quot;aaaee\u0026quot;, but not \u0026quot;abcde\u0026quot;.\nWildcards and Regex:\nWhile wildcards, such as * or ?, can be used to express basic patterns, regex provides a more powerful and flexible mechanism for creating complex search patterns like,\nMatching sequences of characters. Requiring specific numbers of characters. Allowing optional characters. Metacharacters in Regex The regex used in Linux was adopted from POSIX (Portable Operating System Interface for Unix), a series of standards that OS developers followed to ensure Unix and Unix-like systems shared features.\nThe original metacharacters described by POSIX form the Basic Regular Expression (BRE) set. Later, POSIX introduced the Extended Regular Expression (ERE) set, which uses the same metacharacters but with some differences, such as not requiring the backslash (\\) for certain characters.\nIn regex, brackets ([]) are used to define a set of possible characters that can be matched. These brackets allow for more flexible and complex pattern matching.\n[aeiou] : Matches any lowercase vowel. It will match a, e, i, o, or u. [a-e]: Matches any of the characters from a to e. This includes a, b, c, d, and e. [[:lower:]] : This is an example of a POSIX character class within brackets. It matches any lowercase letter (equivalent to [a-z]). POSIX Metacharacters in Regular Expressions: ^: Anchors the match to the beginning of the string.\n^cat matches \u0026ldquo;cat\u0026rdquo; only if it appears at the start of the string.\n$: Anchors the match to the end of the string.\ncat$ matches \u0026ldquo;cat\u0026rdquo; only if it appears at the end of the string.\n*: Matches 0 or more occurrences of the preceding element.\na* matches \u0026ldquo;a\u0026rdquo;, \u0026ldquo;aa\u0026rdquo;, \u0026ldquo;aaa\u0026rdquo;, or even an empty string.\n+: Matches 1 or more occurrences of the preceding element.\na+ matches \u0026ldquo;a\u0026rdquo;, \u0026ldquo;aa\u0026rdquo;, \u0026ldquo;aaa\u0026rdquo;, but not an empty string.\n?: Matches 0 or 1 occurrence of the preceding element.\na? matches \u0026quot;\u0026quot; (empty string) or \u0026ldquo;a\u0026rdquo;.\n.: Matches any single character (except newline).\na.b matches \u0026ldquo;aab\u0026rdquo;, \u0026ldquo;acb\u0026rdquo;, \u0026ldquo;a1b\u0026rdquo;, but not \u0026ldquo;ab\u0026rdquo; (missing character between \u0026ldquo;a\u0026rdquo; and \u0026ldquo;b\u0026rdquo;).\n[]: Character class; matches any one of the characters inside the brackets.\n[aeiou] matches any vowel (e.g., \u0026ldquo;a\u0026rdquo;, \u0026ldquo;e\u0026rdquo;, \u0026ldquo;i\u0026rdquo;, etc.).\n|: Alternation; matches either the pattern on the left or right.\ncat|dog matches either \u0026ldquo;cat\u0026rdquo; or \u0026ldquo;dog\u0026rdquo;.\n**()**: Grouping; groups part of a regular expression.\n(abc)+ matches \u0026ldquo;abc\u0026rdquo; repeated one or more times, e.g., \u0026ldquo;abc\u0026rdquo;, \u0026ldquo;abcabc\u0026rdquo;, etc.\n\\: Escape character; used to escape special characters.\n\\. matches a literal dot \u0026ldquo;.\u0026rdquo;, and \\$ matches a literal dollar sign \u0026ldquo;$\u0026rdquo;.\n{m}: Matches exactly m occurrences of the preceding element.\na{3} matches exactly \u0026ldquo;aaa\u0026rdquo;.\n{m,n}: Matches between m and n occurrences of the preceding element.\na{3,5} matches \u0026ldquo;aaa\u0026rdquo;, \u0026ldquo;aaaa\u0026rdquo;, or \u0026ldquo;aaaaa\u0026rdquo;.\n? (as non-greedy): Makes the preceding character optional or non-greedy.\na+? matches the smallest possible match, i.e., it will match \u0026ldquo;a\u0026rdquo; rather than \u0026ldquo;aaa\u0026rdquo;.\n\\b: Word boundary. \\bcat\\b matches \u0026ldquo;cat\u0026rdquo; only if it appears as a whole word, not as part of a larger word like \u0026ldquo;catalog\u0026rdquo;.\n\\B: Non-word boundary. \\Bcat\\B matches \u0026ldquo;cat\u0026rdquo; if it is not at the start or end of a word (e.g., \u0026ldquo;scatalog\u0026rdquo;).\n\\d: Matches any digit (equivalent to [0-9]). \\d+ matches one or more digits, such as \u0026ldquo;123\u0026rdquo; or \u0026ldquo;42\u0026rdquo;.\n\\D: Matches any non-digit character. \\D+ matches one or more non-digit characters, such as \u0026ldquo;abc\u0026rdquo; or \u0026ldquo;!@#\u0026rdquo;.\n\\w: Matches any word character (letters, digits, and underscore, equivalent to [a-zA-Z0-9_]). \\w+ matches a sequence of word characters, such as \u0026ldquo;abc123\u0026rdquo; or \u0026ldquo;_username\u0026rdquo;.\n\\W: Matches any non-word character. \\W+ matches a sequence of non-word characters, such as !!, @#$, etc.\n\\s: Matches any whitespace character (space, tab, newline). \\s+ matches one or more whitespace characters, such as spaces or tabs.\n\\S: Matches any non-whitespace character. \\S+ matches a sequence of non-whitespace characters, such as \u0026ldquo;abc123\u0026rdquo; or \u0026ldquo;_hello\u0026rdquo;.\nPOSIX Character Classes: [:alnum:]: Matches any alphanumeric character (letters in any case and digits, equivalent to [a-zA-Z0-9]).\n[[:alnum:]] matches \u0026ldquo;a\u0026rdquo;, \u0026ldquo;1\u0026rdquo;, \u0026ldquo;X\u0026rdquo;, \u0026ldquo;b2\u0026rdquo;, etc.\n[:alpha:]: Matches any alphabetic character (letters, equivalent to [a-zA-Z]).\n[[:alpha:]] matches \u0026ldquo;a\u0026rdquo;, \u0026ldquo;b\u0026rdquo;, \u0026ldquo;Z\u0026rdquo;, \u0026ldquo;X\u0026rdquo;, but not digits or symbols.\n[:blank:]: Matches a space or tab character ([ \\t]).\n[[:blank:]] matches spaces and tabs.\n[:cntrl:]: Matches any control character (ASCII 0–31).\n[[:cntrl:]] matches control characters like ^C, ^D, etc.\n[:digit:]: Matches any digit (equivalent to [0-9]).\n[[:digit:]] matches \u0026ldquo;0\u0026rdquo;, \u0026ldquo;5\u0026rdquo;, \u0026ldquo;9\u0026rdquo;, etc.\n[:graph:]: Matches any printable character excluding space (e.g., a, A, 1, etc.).\n[[:graph:]] matches \u0026ldquo;a\u0026rdquo;, \u0026ldquo;A\u0026rdquo;, \u0026ldquo;!\u0026rdquo;, \u0026ldquo;1\u0026rdquo;, but not space.\n[:lower:]: Matches any lowercase letter (equivalent to [a-z]).\n[[:lower:]] matches \u0026ldquo;a\u0026rdquo;, \u0026ldquo;b\u0026rdquo;, \u0026ldquo;z\u0026rdquo;, etc.\n[:print:]: Matches any printable character, including space (equivalent to [[:graph:] ]).\n[[:print:]] matches \u0026ldquo;a\u0026rdquo;, \u0026ldquo;1\u0026rdquo;, \u0026quot; \u0026ldquo;, but not control characters.\n[:punct:]: Matches any punctuation character (e.g., ., !, ?, ;, etc.).\n[[:punct:]] matches \u0026ldquo;.\u0026rdquo;, \u0026ldquo;!\u0026rdquo;, \u0026ldquo;?\u0026rdquo;, \u0026ldquo;;\u0026rdquo;, etc.\n[:space:]: Matches any whitespace character (space, tab, newline, carriage return, etc.).\n[[:space:]] matches \u0026quot; \u0026ldquo;, \u0026ldquo;\\t\u0026rdquo;, \u0026ldquo;\\n\u0026rdquo;, etc.\n[:upper:]: Matches any uppercase letter (equivalent to [A-Z]).\n[[:upper:]] matches \u0026ldquo;A\u0026rdquo;, \u0026ldquo;B\u0026rdquo;, \u0026ldquo;Z\u0026rdquo;, etc.\n[:xdigit:]: Matches any hexadecimal digit (equivalent to [0-9a-fA-F]).\n[[:xdigit:]] matches \u0026ldquo;1\u0026rdquo;, \u0026ldquo;a\u0026rdquo;, \u0026ldquo;F\u0026rdquo;, \u0026ldquo;9\u0026rdquo;, etc.\n^[[:alpha:]]+$ : This will match strings that consist only of alphabetic characters (both lowercase and uppercase).\n[[:digit:]]{3,5} : This will match 3 to 5 consecutive digits.\n","date":"2024-12-29","id":146,"permalink":"/personal-site/docs/bash-linux/linux_bash/bash-13-regular-expressions/","summary":"\u003cp\u003eA \u003cstrong\u003eregular expression (regex)\u003c/strong\u003e is a string that defines a search pattern.\u003cbr\u003e\nIt consists of a combination of \u003cstrong\u003eliteral characters\u003c/strong\u003e and \u003cstrong\u003emeta-characters\u003c/strong\u003e.\u003cbr\u003e\nThe meta-characters modify the literal characters to introduce flexibility and variability in pattern matching.\u003c/p\u003e","tags":[],"title":"Bash - 13 - Regular Expressions"},{"content":"Controlling Repeated Characters Through *, +, ? These are used to express a variable number of times that preceding character in regex can appear in the string.\n*: The preceding character can appear 0 or more times.\n1*0* matches 11111000000, 111111110, 10, 0, or even an empty string.\n+ : The preceding character can appear 1 or more times.\n1+0+ matches 111110000, 1111110, 10\nbut not 0, 1111, or an empty string.\n? : The preceding character can appear 0 or 1 time.\n1?0? matches 1, 0, 10, or an empty string.\na*b*c* : Matches aaaaabbbc, abc, ab, bbbbb, or even empty string. (will match abacab).\na+b+c+ : Matches aaaaabbbc, abc, abbbbbc, but not an empty string or 1111.\na?b?c? : Matches abc, ab, or empty string.\nNone will match with abaaabcas the letters are not in correct sequence.\nLiteral Characters: A regex can contain literal characters without the metacharacters modifying them.\njpe?g : Matches jpeg or jpg (with e being optional and j,p, g a must).\nhello!? : Matches hello or hello! (with ! being optional).\nUsing . (Dot) . matches any single character except a newline.\nb.t will match any string that has b followed by any one character, followed by t.\nIt will match: bat, bbt, b0t, b#t, b t It will not match: bt (missing the middle character) batt (too many characters) ... (three dots) will match any three characters, including three blank spaces.\nCombining with Other Metacharacters like *, +, and ? can modify . to allow for more flexible matches:\n.*: Matches any sequence of characters (including zero characters). b.?t means b followed by zero or one character of any kind followed by a t.\nb.*t will match: bat, bbt, b0t, b#t, b t, bt, batt, b t\n.+: Matches any sequence of one or more characters.\nb.+t will match: bat, bbbbbbt, b t, b?!!#\u0026amp;*t, bait, b00t\nIt will not match: bt (since there must be at least one character between b and t)\n.?: Matches zero or one character of any kind.\nb.?t will match: bt, bat, b?t, b#t, etc.\nControlling Where a Pattern Matches A regular expression need not match the full string, it can match any substring within a string, which is a contiguous sequence of characters found within the larger string.\na*b*c* will match abacab because it looks for zero or more occurrences of a, b, and c in any order. b.t will match batt as it matches b, any character (represented by .), and t. It will also match strings like bbbbbatttt because it matches the substring \u0026ldquo;bat\u0026rdquo;. b?.t and b?.t+ will also match substrings within bbbbbatttt. regex patterns like a*, char*, or a*b* can be too broad, matching anything and everything, becoming useless.\nTo control where the regex matches, we can use anchors to enforce specific positions in the string.\n^ : Asserts the beginning of a string. $ : Asserts the end of a string. ^ and $ : Asserts the start and end of the string, ensuring the entire string must match the pattern. ^b?.t:\nWill not match bbbbbbatttt because the pattern starts at the beginning of the string, where it expects an optional b (b?), followed by any character (.), and then t. However, the sequence does not match at the start. b? matches the first b, the . marks the second b but the t+ does not match as the next character is not t. ^b?.t+:\nThis will not match bbbbbbatttt either because it starts with an optional b, followed by any character, and then t+ (one or more ts). The next character after the first b does not meet the pattern. Matches a string that starts with 0 or 1 b because b? insists that there should be no more than one b. The next should be any one character followed by t. b?.t+$:\nThis will match bbbbbatttt because it scans the string from left to right, allowing for zero or more bs, followed by one character, and ending with one or more ts at the end of the string. ^b?.t+$:\nThis will match strings that start with zero or one b, followed by any character, and ending with one or more ts. batttt, bbttttt, attttt. ^0a*1+:\nThis will match strings that start with a 0, followed by zero or more a\u0026rsquo;s, and at least one 1. 0a1, 0aaaa111, 101111, 01. There can be any character after 1. 0a1a 011100 ^0a*1+$:\nThis variation fixes the ending part to ensure it ends with one or more 1s, with no characters following the 1. It will match: 0a1, 0aaaa111, 10111. ^$:\nThis matches the empty string. It asserts that there is nothing between the start and end of the string. Matching From a List of Options When we want to match a set of characters without caring about their specific order to indicate \u0026ldquo;any of these\u0026rdquo;, we can use character classes.\nThese are defined with square brackets ([]), which specify that the next character in the string must match any single character from the list of options inside the brackets.\nTypes of Lists: as given by the notation inside the bracket.\n1. Enumerated List : [abcd] Matches any one of the characters a, b, c, or d, in any order. There should be no separators.\n[abc][abc][abc] or [a-c][a-c][a-c]: This matches any three consecutive characters where each character is one of a, b, or c, in any combination.\nabc, acb, bca, aaa, bbb, bcc, zyxaaa, @aaa@, aaaaa, 1cba2.\n[abcxyz] [abcdABCD] [abc1234]\n2. Range : [a-f] Matches any one of the characters from a to f, inclusive. This is equivalent to writing [a, b, c, d, e, f].\nRange Combinations:\n[a-cx-z] : Matches any character from the sets a to c or x to z. [a-d1-4] : Matches any character from the sets a to d or 1 to 4. [a-dA-D] : Matches any character from the sets a to d or A to D. 3. Character Class : A POSIX character class is a predefined group that matches a set of characters based on a certain property.\n[:alpha:] matches any alphabetic character (equivalent to [a-zA-Z]). [:punct:] matches any punctuation character such as ., ,, !, etc. (there\u0026rsquo;s no direct range for all punctuation marks). ","date":"2025-01-01","id":147,"permalink":"/personal-site/docs/bash-linux/linux_bash/bash-13.1-regex-expanded/","summary":"\u003ch3 id=\"controlling-repeated-characters-through---\"\u003e\u003cstrong\u003eControlling Repeated Characters Through \u003ccode\u003e*\u003c/code\u003e, \u003ccode\u003e+\u003c/code\u003e, \u003ccode\u003e?\u003c/code\u003e\u003c/strong\u003e\u003c/h3\u003e\n\u003cp\u003eThese are used to express a variable number of times that \u003ccode\u003epreceding character\u003c/code\u003e in regex can appear in the string.\u003c/p\u003e","tags":[],"title":"Bash - 13.1 - regex Expanded"},{"content":"Combining [] with * + ? [abc]+ Matches one or more occurrences of a, b, or c. The sequence must contain at least one character from the set. Matches: a, ab, bbac, c [abc]* Matches zero or more occurrences of a, b, or c, including an empty string. Matches: a, ab, bbb, acb will always match something without the ^$. ^[abc]*$ Matches strings consisting solely of a, b, or c, including empty strings. Matches: a, ab, abc, aaa. Does not match: abc123 ^[a-zA-Z]+$ or ^[[:alpha:]]+$ Matches strings containing only alphabetic characters. ^[0-9]+$ or ^[[:digit:]]+$ Matches strings that consist of only numeric digits. ^[[:punct:]]+$ Matches strings containing only punctuation marks. ^[A-Za-z]+[[:punct:]]+$ or ^[[:alpha:]]+[[:punct:]]+$ Matches strings of letters followed by one or more punctuation marks. Hello!, word? Does not match: Hello, word123, !word ^[[:alpha:][:punct:]]+$ Matches strings of letters and punctuation marks (one or more). Order is not needed. ^[A-Z][a-z]+ [A-Z]? [A-Z][a-z]+$ Matches a name with a capitalized first name, optional middle initial, and capitalized last name. Matches: John Doe, John A Doe. Does not match: john doe, JohnDoe If there is no middle name then the regex will be searching for two spaces, So for optional middle initial without extra spaces:\n^[A-Z][a-z]+( [A-Z]? [A-Z][a-z]+)?$.\nMatching characters that Must Not appear To not contain a specific character. Like without any blank space in it. \u0026ldquo;must not include\u0026rdquo; using [^ ].\nThe ^, when used inside of brackets means \u0026ldquo;match if the next character in the string is not matching anything in the bracket\u0026rdquo;.\nThe blank space indicates the only character we do not want to match against is a space. Adding ^$ to match entire string and to specify that it can contain multiple characters as long as it is not a space using + we will have ^[^ ]+$\nMatching Metacharacters Literally When you need to use punctuation or special characters in a regular expression as literals (not as metacharacters), you can escape them using a backslash (\\).\n\\$[0-9]+\\.[0-9][0-9]\nA regex for a dollar and a cent amount. An alternative is to place the punctuation marks in the []\n[$][0-9]+[.][0-9][0-9]\nTo find a addition number + number = number here = is not a meta character.\n[0-9]+ \\+ [0-9]+ = [0-9]+ or [0-9]+ [+] [0-9]+ = [0-9]+\nTo match any other mathematical expression we can go with the [] and - is in beginning or end or it can be escaped \\-\n[0-9]+ [-+\\*] [0-9]+ = [0-9]+\n$ is a metacharacter used to express the end of a expression, so if $ appears anywhere other than the end, it is taken literally as dollar sign so does not require backslash.\nSimilarly ^ appearing anywhere other than the beginning is taken literally.\n- also should appear in the middle of the []\n$[0-9]+ [+] [0-9]+ \\. [0-9][0-9]\nMore precisely controlling repetition With * + we can indicate that a pattern of characters can be repeated but cannot control the number of repetition.\nwith ? we have slight control in that the number occurrences is limited to either 0 or 1.\nTo control the number of repetitions we use {} within which we can specify one or two numbers which will represent the maximum or the minimum number of occurrences.\nThe three formats are :\n{m} to match exactly m occurrences of preceding character. {m.n} to indicate that the preceding characters must match between m and n where m\u0026lt;n {n,} to indicate at least n occurrences. [0-9]{5} matches exactly five digits. [0-9]{3}-[0-9]{4} to represent a phone number like 123-4567\n[0-9]{3,4} matches between 3 and 4 digits.\n[0-9]{3,} matches 3 or more digits.\nTo get IPv4 address with four octet numbers between 0 and 255.\nwrong method would be [0-255].[0-255].[0-255].[0-255] because there is no range defined between 0 and 255, it is just 0 to 9.\nso [0-255] is interpreted as 0 to 2 and 5 and 5 (0, 1, 2, 5, 5).\nThe . is also a metacharacter to match any single character.\n[0-9]{0-3}\\.[0-9]{0-3}\\.[0-9]{0-3}\\.[0-9]{0-3}\nStill the three numbers can be more than 255 and go upto 999 which is not right.\n^[^0-9]*[0-9]{5}[^0-9]*$\nmeans \u0026ldquo;match any string that consists of zero or more non-digits followed by zero or more non-digits\u0026rdquo;.\nA correct pattern for an IPv4 address should handle the numbers between 0 and 255: Correct:\n^(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$\nSelecting Between Sequences | : The OR operator, used to match either of two patterns.\n(cat|dog) matches either cat or dog.\nUsing ():\n(...)+: Matches one or more occurrences of the group inside parentheses. (...)?: Matches 0 or 1 occurrence of the group inside parentheses. ^[A-Z][a-z]+ ([A-Z]\\. )?[A-Z][a-z]+$ : Matches a name like John Doe or John A. Doe, where the middle initial is optional.\nSample Problems for Regular Expressions 1. Regular Expressions for Numbers Match a number :\n[0-9]+ - Matches a string that contains at least one number.\nMatch a string that consists only numbers :\n^[0-9]+$ - Matching the entire string.\nMatch a 5-digit zip code :\n[0-9]{5} - Matches: 12345, Does not match: 1234, 123456\nMatch a string that consists of a number which may include a single decimal point :\n^[0-9]+\\.?[0-9]*$ - Matches: 0.123, Does not match: 123.4\nMatch a string that contains No digits :\n^[^0-9]+$ - Matches every single character is a non digit.\nMatch a phone number in the format XXX-XXX-XXXX :\n[0-9]{3}-[0-9]{3}-[0-9]{4} - Matches: 123-456-7890, Does not match: 1234567890, 123-45-6789\nMatch a number with optional decimal point which must be followed by at least one digit :\n^[0-9]+(\\.[0-9]+)?$ - Matches: 123, 123.45\nMatch a number with optional decimal point and 2 digits after it :\n^\\d+(\\.\\d{2})?$ - Matches: 123, 123.45, Does not match: 123.456, abc\nMatch a credit card number (16 digits) :\n^\\d{4}-\\d{4}-\\d{4}-\\d{4}$ - Matches: 1234-5678-9876-5432, Does not match: 1234-5678-9876-543, 1234567898765432\n2. Regular Expressions for Words Match a string that consists of any sequence of upper lower :\n^[A-Za-z]+$ - Matches: Hello, world, hello Does not match: world123\nMatch a word that starts with a capital letter :\n^[A-Z][a-z]+$ - Matches: Hello, World, Does not match: hello, world123\nMatch a word that contains only letters and is 5-10 characters long :\n^[a-zA-Z]{5,10}$ - Matches: hello, WorldWide, Does not match: hello123, hi\nMatch a word that starts with a vowel:\n^[aeiouAEIOU][a-zA-Z]*$ - Matches: apple, Orange, Does not match: banana, grape\nMatch a name with first letter uppercase and remaining lowercase :\n^[A-Z][a-z]+$ - Matches: John, Alice, Does not match: john, JOHN\nMatch words containing some consonants, single vowel and some consonants :\n^[b-df-hj-np-tv-z]+[aeiou][b-df-hj-np-tv-z]+$ - taking all as lower case\nMatch several (at least two) words with blank space between them :\n^([A-Za-z]+ )+[A-Za-z]+$ - words separated by blank space.\nMatch several (at least two) words where a punctuation mark may follow any word :\n^([A-Za-z]+[[:punct:]]? )+[A-Za-z]+[[:punct:]]?$\nSame as above but allows for words with hyphens and apostrophes ' - :\n^([A-Za-z'-]+[[:punct:]]? )+[A-Za-z'-]+[[:punct:]]?$ - Matches: play-by-play, y'all's (Care needed when placing hyphen in braces)\n3. Possible Regular Expressions for Spam Terms Match common spam keywords like \u0026ldquo;free\u0026rdquo; or \u0026ldquo;win\u0026rdquo; :\n\\b(free|win)\\b - Matches: free, win, Does not match: winner, freedom\nMatch email addresses containing \u0026ldquo;offer\u0026rdquo; :\noffer[0-9]*@[a-zA-Z0-9]+\\.[a-zA-Z]{2,} - Matches: offer123@mail.com, Does not match: info@mail.com\nMatch phrases like \u0026ldquo;limited time offer\u0026rdquo; or \u0026ldquo;guaranteed\u0026rdquo; :\n\\b(limited time offer|guaranteed)\\b - Matches: limited time offer, guaranteed, Does not match: limited, guarantee\nMatch common spam email subject lines containing \u0026ldquo;urgent\u0026rdquo;:\n\\burgent\\b.*\\b(action|reply)\\b - Matches: URGENT action required, urgent reply needed. Does not match: urgent request, action taken\n[Aa]ct n[oO]w!? - Act now! act nOw\n[Cc]lick h[e3] - Click here click h3r3\n[Ll][oO][t4][t4][e3]ry - lo44ry Lott3ry\n[Oo]rder [nN]ow!? - Order Now order now!\n[Yy]ou (may already be|are) a winner!? - You are a winner! you may already be a winner\n","date":"2025-01-01","id":148,"permalink":"/personal-site/docs/bash-linux/linux_bash/bash-13.2-regex-matching/","summary":"\u003ch3 id=\"combining--with------\"\u003eCombining [] with  *  +  ?\u003c/h3\u003e\n\u003cdl\u003e\n\u003cdt\u003e\u003ccode\u003e[abc]+\u003c/code\u003e\u003c/dt\u003e\n\u003cdd\u003eMatches one or more occurrences of \u003ccode\u003ea\u003c/code\u003e, \u003ccode\u003eb\u003c/code\u003e, or \u003ccode\u003ec\u003c/code\u003e. The sequence must contain at least one character from the set.\nMatches: \u003ccode\u003ea\u003c/code\u003e, \u003ccode\u003eab\u003c/code\u003e, \u003ccode\u003ebbac\u003c/code\u003e, \u003ccode\u003ec\u003c/code\u003e\u003c/dd\u003e\n\u003cdt\u003e\u003ccode\u003e[abc]*\u003c/code\u003e\u003c/dt\u003e\n\u003cdd\u003eMatches zero or more occurrences of \u003ccode\u003ea\u003c/code\u003e, \u003ccode\u003eb\u003c/code\u003e, or \u003ccode\u003ec\u003c/code\u003e, including an empty string.\nMatches: \u003ccode\u003ea\u003c/code\u003e, \u003ccode\u003eab\u003c/code\u003e, \u003ccode\u003ebbb\u003c/code\u003e, \u003ccode\u003eacb\u003c/code\u003e  will always match something without the \u003ccode\u003e^$\u003c/code\u003e.\u003c/dd\u003e\n\u003cdt\u003e\u003ccode\u003e^[abc]*$\u003c/code\u003e\u003c/dt\u003e\n\u003cdd\u003eMatches strings consisting solely of \u003ccode\u003ea\u003c/code\u003e, \u003ccode\u003eb\u003c/code\u003e, or \u003ccode\u003ec\u003c/code\u003e, including empty strings.\nMatches: \u003ccode\u003ea\u003c/code\u003e, \u003ccode\u003eab\u003c/code\u003e, \u003ccode\u003eabc\u003c/code\u003e, \u003ccode\u003eaaa\u003c/code\u003e.   Does not match: \u003ccode\u003eabc123\u003c/code\u003e\u003c/dd\u003e\n\u003cdt\u003e\u003ccode\u003e^[a-zA-Z]+$\u003c/code\u003e or \u003ccode\u003e^[[:alpha:]]+$\u003c/code\u003e\u003c/dt\u003e\n\u003cdd\u003eMatches strings containing only alphabetic characters.\u003c/dd\u003e\n\u003cdt\u003e\u003ccode\u003e^[0-9]+$\u003c/code\u003e or \u003ccode\u003e^[[:digit:]]+$\u003c/code\u003e\u003c/dt\u003e\n\u003cdd\u003eMatches strings that consist of only numeric digits.\u003c/dd\u003e\n\u003cdt\u003e\u003ccode\u003e^[[:punct:]]+$\u003c/code\u003e\u003c/dt\u003e\n\u003cdd\u003eMatches strings containing only punctuation marks.\u003c/dd\u003e\n\u003cdt\u003e\u003ccode\u003e^[A-Za-z]+[[:punct:]]+$\u003c/code\u003e or \u003ccode\u003e^[[:alpha:]]+[[:punct:]]+$\u003c/code\u003e\u003c/dt\u003e\n\u003cdd\u003eMatches strings of letters followed by one or more punctuation marks.  \u003ccode\u003eHello!\u003c/code\u003e, \u003ccode\u003eword?\u003c/code\u003e\nDoes not match: \u003ccode\u003eHello\u003c/code\u003e, \u003ccode\u003eword123\u003c/code\u003e, \u003ccode\u003e!word\u003c/code\u003e\u003c/dd\u003e\n\u003cdt\u003e\u003ccode\u003e^[[:alpha:][:punct:]]+$\u003c/code\u003e\u003c/dt\u003e\n\u003cdd\u003eMatches strings of letters and punctuation marks (one or more). Order is not needed.\u003c/dd\u003e\n\u003cdt\u003e\u003ccode\u003e^[A-Z][a-z]+ [A-Z]? [A-Z][a-z]+$\u003c/code\u003e\u003c/dt\u003e\n\u003cdd\u003eMatches a name with a capitalized first name, optional middle initial, and capitalized last name. Matches: \u003ccode\u003eJohn Doe\u003c/code\u003e, \u003ccode\u003eJohn A Doe\u003c/code\u003e.  Does not match: \u003ccode\u003ejohn doe\u003c/code\u003e, \u003ccode\u003eJohnDoe\u003c/code\u003e\u003c/dd\u003e\n\u003c/dl\u003e\n\u003cp\u003eIf there is no middle name then the regex will be searching for two spaces, So for optional middle initial without extra spaces:\u003cbr\u003e\n\u003ccode\u003e^[A-Z][a-z]+( [A-Z]? [A-Z][a-z]+)?$\u003c/code\u003e.\u003c/p\u003e","tags":[],"title":"Bash - 13.2 - regex Matching"},{"content":"Linux offers several methods to search for files or directories, with the find command being one of the most powerful and versatile tools.\nFile Browser A file browser provides a graphical interface for searching files. It includes:\nA search bar where you can enter search terms. Drop-down menus to filter by criteria such as modification date, file type, or size. In some cases, file browsers also allow full-text searching, where the search examines both the filename and the contents of text files.\nfind Command The find command is used to search for files and directories based on specific criteria. It’s a flexible and powerful tool with many options and actions.\nTo start using find, specify the directory in which to search and the search criteria:\nfind [directory] [expression] find path_list selection_criteria action\rTo list all files and directories under the current directory:\n$ find .\rThis command will recursively list all files and directories starting from the current directory.\nFiltering by Type You can filter the search results by file type using the -type option:\n-type d: Lists only directories.\n$ find . -type d\r-type f: Lists only files.\n$ find . -type f\rSearching by Name To search for files based on their name, use the -name option with the string or pattern you\u0026rsquo;re looking for.\n$ find . -name \u0026#34;*.txt\u0026#34;\rThis finds all .txt files in the current directory and all its subdirectories. (* gets expanded before expansion)\nNote: Enclose the pattern in quotes to prevent shell expansion of *. Otherwise, it will only search for files named literally *.txt.\nfind /etc -name \u0026#34;*.conf\u0026#34;\rto locate files ending in .conf in the /etc directory.\nTo search case-insensitively, use -iname:\n$ find . -iname \u0026#34;*.txt\u0026#34;\rCombining find with Other Commands You can use find with other commands. For example, to count the lines in all .txt files found by find, use command substitution:\n$ wc -l $(find . -name \u0026#34;*.txt\u0026#34;)\rThis will pass all .txt files to wc -l to count their lines.\nTo count lines in all .dat files and sort the results numerically:\n$ wc -l $(find . -name \u0026#34;*.dat\u0026#34;) | sort -n\rThis command finds all .dat files, counts their lines, and sorts the results.\nThere are three categories of options\nSearch criteria: which -name and -iname are part Options that alter find\u0026rsquo;s behavior. Actions: which control what should happen when it has located an item. The search criteria options\nMost but not all search expression require a parameter.\nn indicates an integer (time, size or UID/GID)\nfile indicates filename.\ntest indicates a set of permissions.\ntype represents file type or file system type.\nname is user or group name.\npattern is regular expression.\n[+-]n for time and size, if the number is by itself then it tries to find an exact match.\nIf the integer is preceded by + then find looks for matches where the property is greater than the integer.\n-5 looks for property values less than 5.\nSearch Criteria Options find offers many search criteria to refine searches, including time-based, size-based, and type-based options.\nTime-Based Options These options let you search for files based on when they were last accessed or modified:\n-amin [+-]n: Files accessed n minutes ago (use + for older, - for more recent). $ find . -amin -5 # Files accessed in the last 5 minutes\r-mmin [+-]n: Files modified n minutes ago. $ find . -mmin -100 # Files modified in the last 100 minutes\r-atime [+-]n: Files accessed n days ago. -mtime [+-]n: Files modified n days ago. $ find . -mtime +10 # Files modified more than 10 days ago\rSize-Based Options You can search for files based on their size:\n-size [+-]n: Files of a specific size. Use suffixes like c (bytes), k (kilobytes), M (megabytes), etc. $ find . -size +1M # Files larger than 1MB\rn can be followed by b (512-byte blocks), c (byte), w (2-word bytes), k (kilobytes), M (megabytes) and G (Gigabytes)\n-size +1024c -size +1k\n-size 1000c means exactly 1000 bytes in size.\n-size -1000c means less than 1000 bytes in size.\nFile Type Options You can filter by file type:\n-type d: Directories -type f: Regular files -type l: Symbolic links (s - socket, p - pipe, c - characters, b - block) $ find . -type f # Regular files\rPermission-Based Options Search for files based on their permissions:\n-perm: Files with specific permissions. For example, to find files with 755 permissions: $ find . -perm 755\rOwner and Group Search Search for files based on their owner or group:\n-user username: Files owned by a specific user. $ find . -user alice # Files owned by \u0026#39;alice\u0026#39;\r-group groupname: Files belonging to a specific group. $ find . -group staff # Files belonging to the \u0026#39;staff\u0026#39; group\rLogical Operators You can combine multiple conditions using logical operators:\n-and or -a: Represents ANDed conditions.\n$ find . -size +100c -and -size -200c $ find . -size +100c -size -200c $ find . -size +100c -a -200c # Files between 100 and 200 bytes\r-or or -o: Represents ORed conditions.\n$ find . -size +100c -o -name \u0026#34;*.txt\u0026#34; # Files larger than 100 bytes OR .txt files\r-not or !: Negates a condition.\n$ find . -not -type d # Files that are not directories\rfind /dev ! -type c find /dev -not -type c # All files that are not character type.\rWithout parenthesis, not is applied first, followed by and, then or.\nDepth and Mounting Options -maxdepth: Limit the search to a certain depth. $ find . -maxdepth 2 # Search only two levels deep\r-mount: Prevents find from descending into other mounted filesystems. $ find . -mount -name \u0026#34;*.txt\u0026#34; # Only search the current filesystem\r3. Actions with find You can specify actions to take on the found files using options like -exec, -delete, and others.\n-delete: Deletes all files that match the criteria. $ find . -empty -delete # Delete all empty files and directories\r-exec: Executes a command on each found file. For example, to count lines in each file: $ find . -type f -exec wc -l {} \\; # Count lines in each file\r-ok: Similar to -exec, but asks for confirmation before executing the command on each file. $ find . -type f -exec chmod 755 {} \\; # Change permissions, with confirmation\r-ls: Lists the files using ls -l format. $ find . -name \u0026#34;*.txt\u0026#34; -ls\r-prune: Prevents find from descending into directories. $ find . -name \u0026#34;*.txt\u0026#34; -prune # Skip directories\r-quit: Stops the search after finding the first match. $ find . -name \u0026#34;*.txt\u0026#34; -quit # Stop after finding the first .txt file\r4. Other Methods of Locating Files which: Finds the path of an executable file which is present in PATH.\n$ which name $ which ls # Locate the \u0026#39;ls\u0026#39; command\rwhereis: Locates binary, source, and man pages for a command (not reliant on PATH).\n$ whereis man # Locate the \u0026#39;man\u0026#39; command and its files\rlocate: Uses a database to quickly find files. The database must be updated with updatedb.\n$ locate man # Locate files related to \u0026#39;man\u0026#39;\r","date":"2024-12-29","id":149,"permalink":"/personal-site/docs/bash-linux/linux_bash/bash-14-file-searching/","summary":"\u003cp\u003eLinux offers several methods to search for files or directories, with the \u003ccode\u003efind\u003c/code\u003e command being one of the most powerful and versatile tools.\u003c/p\u003e","tags":[],"title":"Bash - 14 - File Searching"},{"content":"Command mode : keystrokes act as commands.\nInsert and Replace mode for editing. (\u0026lt;Esc\u0026gt; to exit to Command mode)\nInsert mode inserts any characters at cursor position.\nReplace mode the characters entered replaces the character at the cursor position.\nFive categories of keystrokes:\nMode commands Cursor movement commands Editing commands File commands Miscellany Mode commands : \u0026lt;Esc\u0026gt; to move out of insert / replace mode.\nI, i, A, a, O, o to move into insert mode at a particular place.\nI at beginning of line i at current cursor position.\na immediately after the cursor position, A at the end of the line.\nO in a blank line immediately above the cursor o immediately below the cursor.\nR, r to enter replace mode and staying there or replacing one character and moving out after that to command mode.\nCursor Movement Commands: hjkl for moving around.\nh--l for left and right.\n-jk- for down and up.\nThese can be prefixed with numbers to move certain distance. 2k, 10j, 13h.\nMoving to Line Extremes :\n0 just zero to move to left end (beginning) of the line.\n$ (shift+4) to move to end of line.\nMoving Over words :\nb is beginning of current word, e is end of current word, w is jumping to next words.\nw, b to move forward or backwards to the next/previous word or punctuation mark. (3w to move 3 word).\nW, B moves one word\nE, e similar but takes to end of current word or to next punctuation mark.\nPage Motion :\nCtrl + b and Ctrl + d to move up and down by half page.\nCtrl + u and Ctrl + f to move up down by one full screen.\nH, M, L Head, Middle, Last moves to these points in the file.\nAbsolute movement : Ctrl + G gives the current line number. (Capital G)\nnG can be given to move to a particular line as if needed when it mentioned in an error.\n40G moves to the 40th line 1G to the first line G moves to the end of the file.\nEditing Commands Which allows for cut copy an paste.\nDeleting Text :\nThere are various forms of Cut (deletion) commands.\nx deletes the current character.\nD deletes from cursor to end of the line.\ndd deletes the current line (5dd to delete multiple lines below it)\ndw to delete current word or from cursor till next word (d5w to delete 5 words)\ndb deletes the previous word or to the left of cursor till end of word.\nMoving Text :\nDeleted items are moved into buffer, can be recalled or pasted anywhere.\np to paste/put before the cursor\nP to paste/put after the cursor\nCopying Text:\nyanking is used to copy the file.\nyy to copy the current line and yw to copy the current word to buffer.\n6yy copies the 6 lines from cursor.\nBuffer space : adding any letter from a to z to command allows to select 26 additional buffers.\na6yy copies 6 lines from the cursor into buffer a, then typing ap will paste those 6 lines after the cursor.\nJoining Lines :\nJ to join two consecutive lines into one,\n4J joins the following four lines with the current one.\nUndoing Last Editing Instructions : u undoes the last changes made.\nu can be combined with number also so undo multiple steps. 10u.\nU undoes all changes made to the current line after the cursor moved to that line. If the cursor moved to another line then it won\u0026rsquo;t work.\nCtrl + r to redo the last command\n10[Ctrl + r] also redoes multiple undoes.\nxp transposes the current character with next character (similar to cut paste)\nFile Commands File commands start with :\n: will go to command line (when in Command mode)\n:w to save the file\n:w filename to save as (change file name)\n:r filename to open a new file.\n:q for closing a window\n:wq to save and exit\n:q! to discard changes and exit\n:qa! Get out of Vim (all changes are lost) exiting from all deeper layers at once.\nMiscellany /string or ?string to search for a string\nSubstitution - Search and replace (:s/ /) : :address/source_pattern/target_pattern/flags\nThe source pattern will be replaced by the target pattern in all lines specified by the address.\nThe address can be 1 or many numbers separated by a comma.\n1,$ represents all lines in a file, from 1 to the end. % can be used instead.\n:1,$s/director/member/g or :%s/director/member/g\nLeaving out the g, the substitution will be carried out for the first occurrence in each address line, but not all in the line.\nTarget pattern is also optional, if left out then all the occurrences will deleted.\n:1,50s/unsigned//g will delete unsigned from everywhere in lines 1 to 50.\n$./director/member/g works on the current line.\n$s/director/member/g works on only the last line.\nTo Make the substitution interactive, one by one with commands, using c as a flag.\n:1,$s/director/member/gc\ny to confirm and n to cancel. q to quit.\n% to match the current section closing braces\nv to start selection(visual) and moving any direction. (gU to Uppercase everything selected)\n:help is general help window\nHelp can anything specific can be given as argument to :help command.\n:help x, :help i_\u0026lt;esc\u0026gt;, :help :quit\nCtrl+] (square brace) or double mouse click on any tag vim will jump to that subject similar to help page. (if there are no help pages for that particular word, does\u0026rsquo;t go anywhere )\nCtrl+O (its not zero), or Ctrl + right mouse click or Ctrl+T to jump back to previous position. (repeat to go further back)\n:help quit or :help word and pressing Ctrl+D will bring up all matching help entries to see\n:Tutor for a tutorial on basics\n:help quickref for the reference of command shortcuts\n:terminal for a terminal session inside editor\n:index for all the : commands\nLinks are opened by moving on it and pressing enter. Capital K which is Shift+K on any item will search for documentation ( Ctrl+] searches for tags of the word)\nPressing \u0026lt;Esc\u0026gt; will put in Command mode (or will cancel the partially typed command), which allows to retype a command.\n","date":"2025-01-01","id":150,"permalink":"/personal-site/docs/bash-linux/linux_bash/bash-15-neovim/","summary":"\u003cp\u003e\u003cem\u003e\u003cstrong\u003eCommand mode\u003c/strong\u003e\u003c/em\u003e : keystrokes act as commands.\u003cbr\u003e\n\u003cem\u003e\u003cstrong\u003eInsert and Replace mode\u003c/strong\u003e\u003c/em\u003e for editing. (\u003ccode\u003e\u0026lt;Esc\u0026gt;\u003c/code\u003e to exit to Command mode)\u003c/p\u003e\n\u003cp\u003eInsert mode inserts any characters at cursor position.\u003cbr\u003e\nReplace mode the characters entered replaces the character at the cursor position.\u003c/p\u003e","tags":[],"title":"Bash - 15 - Neovim"},{"content":"grep stands for \u0026ldquo;global/regular expression/print.\u0026rdquo;\nIt is a powerful tool for searching text and is commonly used in UNIX text editors.\ngrep program searches one or more files by line to match against a specified regular expression. Each line is treated as the string and grep searches for any substring of the line that matches the regex. If found, by default grep outputs the matching lines.\ngrep only applies the POSIX basic regular expression set and extended regular expressions set egrep is used.\negrep can do everything grep can do, there is no need to use anything other than egrep.\negrep [options] regex filename(s)\rregex is a string that can but does not have to include metacharacters.\nFiles can be listed with space or wildcards.\n[!important] The regex is placed in single quotes ' ' to avoid metacharacters being interpreted as wildcards and doing filename expansion (globbing) on wildcards * ? [].\n| will sets up pipes instead of performing OR action. Items Found in \u0026quot; \u0026quot; are interpreted, they are not treated literally like in ' '\nTo search for a specific phrase using quotes makes it easier to search for phrases or single words:\n$ egrep \u0026#34;is not\u0026#34; haiku.txt $ egrep \u0026#34;not\u0026#34; haiku.txt\regrep 2022 *.txt # all lines that contain 2022 egrep ^a *.txt # all lines that start with an a\regrep \u0026#39;[Ss]mith\u0026#39; *.txt # Find lines having smith or Smith egrep \u0026#39;Duke|Zappa\u0026#39; *.txt # Find lines containing Duke or Zappa\regrep \u0026#39;[0-9]+\u0026#39; *.txt # Find lines that contain atleast one digit egrep \u0026#39;[A-Za-z]+[[:punct:]]\u0026#39; *.txt # Find lines that contain letters followed by any punctuation mark anywhere in the line. egrep \u0026#39;^[0-9]*[^0-9]+$\u0026#39; *.txt # Finds lines that if they have digits are found at the beginning of the line. egrep \u0026#39;^[A-Z][a-z]+ [A-Z][a-z]+$\u0026#39; *.txt # Find all lines that contain exactly two words, both capitalized egrep \u0026#39;[a-z]+ [a-z]+ [a-z]+\u0026#39; *.txt # Find lines that contain at least 3 words, lowercased\rOptions Recursive Search (-r): Searches through all files in the directory and subdirectories. $ egrep -r \u0026#34;Yesterday\u0026#34;\rCount (-c): Gives the count of the matches for each file instead of a list. $ egrep -c \u0026#39;[0-9]{1,3}\u0026#39; /etc/resolve.conf\rWord Boundary (-w): Limits matches to whole words only. $ grep -w \u0026#34;The\u0026#34; haiku.txt\rLine Numbers (-n): Numbers the results with the line numbers. $ grep -n \u0026#34;it\u0026#34; haiku.txt\rCase Insensitivity (-i): Makes the search case insensitive. $ grep -n -w -i \u0026#34;the\u0026#34; haiku.txt\rInvert Match (-v): Inverts the search to get all lines that do not match. $ grep -v -n -w \u0026#34;the\u0026#34; haiku.txt\rRegex can be placed in a file and -f option can be used to reference the file.\n-e and -f ???\nThe outputs of ls are piped to egrep, Outputs are all regular files whose owner permissions are rwx. ^ starts the regex, since $ is not given, doesn\u0026rsquo;t match whole string.\nls -l /etc | egrep \u0026#39;^-rwx\u0026#39;\r???\nls -l /etc | egrep \u0026#39;.{13}[^1]\u0026#39;\r","date":"2024-12-29","id":151,"permalink":"/personal-site/docs/bash-linux/linux_bash/bash-16-egrep/","summary":"\u003cp\u003e\u003ca href=\"/personal-site/docs/bash-linux/command-docs/grep\"\u003e\u003cem\u003egrep\u003c/em\u003e\u003c/a\u003e stands for \u0026ldquo;global/regular expression/print.\u0026rdquo;\u003cbr\u003e\nIt is a powerful tool for searching text and is commonly used in UNIX text editors.\u003c/p\u003e","tags":[],"title":"Bash - 16 - egrep"},{"content":"sed is stream-editor which a program that takes a stream of text and modifies it.\nIt is a multipurpose tool that combines the work of several filters.\nA stream is a short for I/O stream meaning the stream of text characters that are being input from one source and output to another.\nThe role of sed is to manipulate the text in the stream en route from input to output.\nLike diff command, sed uses instructions to act on text.\nAn instruction combines an address for selecting lines, with an action to be taken on them.\nsed [options] script file(s) sed [options] \u0026#39;address action\u0026#39; file(s)\r[!note] The address and action are enclosed within single quotes. Double quotes should be used only when variable evaluation or command substitution is embedded in the quoted string.\nAddressing in sed is done in two ways:\nOne line number to select a single line or two line numbers (3,7), which specifies a group of contiguous lines. By specifying a / enclosed pattern which occurs in a line (/From:/) The action component is drawn from sed\u0026rsquo;s internal commands.\nsed processes several instruction in a sequential manner. each instruction operates on the previous instruction.\nOptions -eoption that lets use multiple instructions\n-f to take instructions from a file.\nBoth work the same way they do in grep\nsed \u0026#39;3q\u0026#39; emp.lst\r3q can be broken down to the address 3 and the action q (quit).\nWhen it is enclosed in quotes and followed by a file name, then it simulates the head -n 3 which prints the first three lines.\n[!note] Generally p command is used for printing, it has a strange behavior to print the selected lines and also all the lines. So selected lines appear twice.\nUsing -n option with p command will suppress this.\nTo select first two lines similar to head command.\nsed -n \u0026#39;1,2p\u0026#39; emp.lst\r$ to select the last line. which is simulating the tail command.\nsed -n \u0026#39;$p\u0026#39; emp.lst\rBut sed can select a contiguous lines from anywhere (9,11)which is not possible with head and tail.\nIt can also select multiple groups of lines from many sections.\nsed -n \u0026#39;1,2p 7,9p $p\u0026#39; emp.lst\rNegating the action using ! negation operator which can be used with any action.\nSelecting the first two lines by Not selecting the 3rd line till the last line.\nsed -n \u0026#39;3,$!p\u0026#39; emp.lst\rUsing -e and -f for multiple instructions -e allows for entering multiple instructions each preceded by the option.\nsed -n -e \u0026#39;1,2p\u0026#39; -e \u0026#39;7,9p\u0026#39; -e \u0026#39;$p\u0026#39; emp.lst\rWhen there are too many instruction it is better to store them in a file first and then load them in.\n$ cat inst.fil 1,2p 7,9p $p\rNow -f can be used to direct sed to take instructions from the file\nsed -n -f inst.fil emp.lst\rUsing multiple files and combining -e -f\nsed -n -f inst.fil1 -f inst.fil2 emp.lst sed -n -e \u0026#39;/sen/p\u0026#39; -f instr.fil1 -f inst.fil2 emp?.lst\rContext Addressing Context addressing allows for specifying one or two patterns to locate lines. Patterns must be bordered with / on either side.\nsed -n \u0026#39;/director/p\u0026#39; emp.lst\rA comma separated pair of context addresses to select a group of lines. Line and context address can also be mixed.\nsed -n \u0026#39;/guptha/,/Sena/p\u0026#39; emp.lst sed -n \u0026#39;1,/guptha/p\u0026#39; emp.lst\rUsing Regular Expressions Context addressing can also use Regular expressions.\nsed -n \u0026#39;[aA]gg*[ar]wal/p\u0026#39; emp.lst sed -n \u0026#39;/sa[kx]s*ena/p guptha/p\u0026#39; emp.lst\rFirst to select all the Agarwals and second to select Saksena or guptha.\nWriting Selected lines to a file w write command can be used to write the selected line to a separate file.\nsed -n \u0026#39;/director/w dlist\u0026#39; emp.lst Here when -n is used there will be no display of all the lines but it is not needed to write to file.\nFull file can be split up by giving multiple address.\nsed -n \u0026#39;/director/w dlist /manager/w mlist /executive/w elist\u0026#39; emp.lst sed -n \u0026#39;1,500w file1 501,$w file2\u0026#39; file.main\rText editing sed can insert and change existing text in a file.\nIt is similar to the vi command i for insert, a for append, c to change, d to delete.\n. . . .\n","date":"2024-12-29","id":152,"permalink":"/personal-site/docs/bash-linux/linux_bash/bash-17-sed/","summary":"\u003cp\u003e\u003ccode\u003esed\u003c/code\u003e is \u003cstrong\u003estream-editor\u003c/strong\u003e which a program that takes a stream of text and modifies it.\u003cbr\u003e\nIt is a multipurpose tool that combines the work of several filters.\u003c/p\u003e","tags":[],"title":"Bash - 17 - sed"},{"content":"Logical Operators for Conditional Execution \u0026amp;\u0026amp;, || which is used to allow conditional execution of things.\ncmd1 \u0026amp;\u0026amp; cmd2 The cmd2 is executed only when the cmd1 succeeds.\ncmd1 || cmd2 plays an inverse role, where cmd2 is executed if cmd1 fails. Here the exit status of grep is being used to redirect the command execution.\ngrep \u0026#39;director\u0026#39; emp.lst \u0026amp;\u0026amp; echo \u0026#34;pattern found in file\u0026#34; grep \u0026#39;manager\u0026#39; emp.lst || echo \u0026#34;pattern not found\u0026#34;\r|| goes well with exit command, to terminate a script when a command fails.\ngrep \u0026#39;manager\u0026#39; emp.lst || exit 2 echo \u0026#34;Pattern found - Job Over\u0026#34;\rThese two are enough for basic decision making but if is needed to handle complex ones.\nif conditional The if statement makes two-way decision depending on the fulfillment of a certain condition. if also requires then to execute. else and elif are not always required.\nif is closed with corresponding fi.\nThe basic forms are:\nif command is successful then execute commands else execute commands fi\rif command is successful then execute commands fi\rif command is successful then execute commands elif command is successful then ... else ... fi\rAll commands return a exit status and these solely determine the course of action pursued by if and while.\nif grep \u0026#34;^$1\u0026#34; /etc/passwd 2\u0026gt;/dev/null then echo \u0026#34;pattern found\u0026#34; else echo \u0026#34;pattern not found\u0026#34; fi\rUsing test to evaluate expressions The test statement is needed because the true or false values returned by the expressions can\u0026rsquo;t be handles by the if.\ntest doesn\u0026rsquo;t display any output but simply sets the parameter $?.\nTests work in three ways:\nCompares two numbers Compares two strings or a single one for a null value. Checks a file\u0026rsquo;s attributes Numeric Comparison They always begin with a hyphen -, followed by a two letter string enclosed on either side by whitespace.\nOperator Meaning -eq Equal to -ne Not equal to -gt Greater than -ge Greater than or equal to -lt Less than -le Less than or equal to Numeric comparisons in shell is confined to integer values only; Decimal values are simply truncated. $ x=5; y=7; z=7.2 $ test $x -eq $y ; echo $? 1 $test $x -lt $y ; echo $? 0 $test $z -gt $y ; echo $? 1 $ test $z -eq $y ; echo $? 0\rEnsure that the messages meant to draw the attention of user (mainly from echo) are redirected to \u0026gt;/dev/tty. Even though it will work without it.\nif test $# -eq 0; then echo \u0026#34;Usage: $0 pattern file\u0026#34; \u0026gt;/dev/tty elif test $# -eq 2; then grep \u0026#34;$1\u0026#34; $2 || echo \u0026#34;$1 not found in $2\u0026#34; \u0026gt;/dev/tty else echo \u0026#34;You did not enter two arguments\u0026#34; \u0026gt;/dev/tty fi\rThe Short hand for test is placing the expression in [ ] .\n[ $x -eq $y ] is same as test $x -eq $y\nThere must be white space around operators like -eq and operands like $x and inside [ ].\nShorthand for testing if a number is greater than zero can be if [ $x -gt 0 ] can be written as if [ $x ]\nString Comparison test can used to compare strings too using another set of operators like = where equality is performed and != for inequality and ! for negation also.\nAlso -n stg is String stg is a not a null string. -z stg is String stg is a null string.\nstg when String stg is assigned and not null.\nif [ $# -eq 0 ] ; then echo \u0026#34;Enter the string to be searched: \\c\u0026#34; read pname if [ -z \u0026#34;$pname\u0026#34; ] ; then echo \u0026#34;you have not entered the string\u0026#34; ; exit 1 fi echo \u0026#34;Enter the filename to be used: \\c\u0026#34; read filename if [ ! -n \u0026#34;$filename\u0026#34; ] ; then # ! -n is same as -z echo \u0026#34;You have not entered the filename\u0026#34; ; exit 2 fi emp3a.sh \u0026#34;$pname\u0026#34; \u0026#34;$flname\u0026#34; else emp3a.sh \u0026#34;$@\u0026#34; fi\rUsing and -a or -o operators for checking more than one condition in the same line.\nif [ -n \u0026#34;$pname\u0026#34; -a -n \u0026#34;$flname\u0026#34; ] ; then emp3a.sh \u0026#34;$pname\u0026#34; \u0026#34;$flname\u0026#34; else echo \u0026#34;At least one input was a null string\u0026#34; ; exit 1 fi\rFile Tests test can be used to test the various file attributes like its type or its permissions.\n. . . .\nThe case Conditional The case statement is the second conditional offered by the shell. The statement matches an expression for more than one alternative, and uses a compact construction to permit multiway branching.\ncase also handles string tests better than if.\ncase expression in pattern1) commands1 ;; pattern2) commands2 ;; pattern3) commands3 ;; .... esac\recho \u0026#34; Menue\\n 1. List of files\\n2. Process of user\\n3. Today\u0026#39;s Date 4. Users of system\\n5. Quit to UNIX\\nEnter Your Option: \\c\u0026#34; read choice case \u0026#34;$choice\u0026#34; in 1) ls -l ;; 2) ps -f ;; 3) date ;; 4) who ;; 5) exit ;; *) echo \u0026#34;Invalid option\u0026#34; # ;; not requires for last option esac\rTo handle multiple patterns using same case by using | to delimit multiple patterns like when input can be y or Y\necho \u0026#34;Do you want to continue? (y/n): \\c\u0026#34; read answer case \u0026#34;$answer\u0026#34; in y|Y) ;; n|N) exit ;; esac\rexpr : Computation and String Handling Not needed for Korn or Bash shell\n","date":"2024-12-29","id":153,"permalink":"/personal-site/docs/bash-linux/linux_bash/bash-18.1-shell-scripts-conditionals/","summary":"\u003ch3 id=\"logical-operators--for-conditional-execution\"\u003eLogical Operators  for Conditional Execution\u003c/h3\u003e\n\u003cp\u003e\u003ccode\u003e\u0026amp;\u0026amp;\u003c/code\u003e, \u003ccode\u003e||\u003c/code\u003e which is used to allow conditional execution of things.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003ecmd1 \u0026amp;\u0026amp; cmd2\u003c/code\u003e  The \u003ccode\u003ecmd2\u003c/code\u003e is executed only when the \u003ccode\u003ecmd1\u003c/code\u003e succeeds.\u003c/p\u003e","tags":[],"title":"Bash - 18.1 - Shell Scripts - Conditionals"},{"content":"A shell program runs in interpretive mode. It is not compiled into a separate executable file as a C Program is. Each statement is loaded into memory when it is executed.\nShell Script When a group of commands have to be executed regularly, they should be stored in a file, and the file itself is executed as Shell Script or Shell Program. Though it is not mandatory to use .sh extension for shell scripts, it is used to make it easy to match with wildcards.\nShell scripts allow us to automate frequently used commands by saving them in a file, enabling us to execute them later with a single command. In essence, shell scripts are small programs.\nShell scripts are executed in a separate child shell process, it need to be of the same type as the login shell. A Borne shell use a Korn sub-shell to run the script by giving a interpreter first line of the script.\nExample shell script file\n#!/bin/sh # script.sh: Sample Shell Script echo \u0026#34;Today\u0026#39;s date: `date`\u0026#34; echo \u0026#34;Current Month and Year:\u0026#34; echo `date \u0026#34;+%m 20%y\u0026#34;` echo \u0026#34;My shell: $SHELL\u0026#34;\r# is comment and everything to the right of it is ignored, but,\nThe first line is the interpreter line which always begins with a #! and followed by the path- name of the shell to be running the script.\n( The file has to be made executable by giving permission to execute if it does\u0026rsquo;t have it before running it chmod +x script.sh)\nCreating a Simple Shell Script Navigate to the desired directory: $ cd alkanes\rCreate a new shell script file: $ nano middle.sh\rThis opens a file where you can write your commands.\nAdd the following command to the file to extract specific lines: head -n 15 octane.pdb | tail -n 5\rThis command collects lines 11-15 of the file octane.pdb.\nSave and close the file. Executing the Script, Once the script is saved, using:\n$ bash middle.sh\rUsing Command line arguments Shell scripts can accept arguments from command line. Therefore they can run non-interactively and be used with redirection and pipelines.\nWhen arguments are specified with a shell script, they are assigned to a special \u0026ldquo;variables\u0026rdquo; - rather a positional parameters.\nThe first argument is read by the shell into the parameter $1, second into $2 and so on.\nThere are other parameters used by the shell.\n$* It stores the complete set of positional parameters as a single string. $# It is set to the number of arguments specified. This lets you design scripts that check whether the right number of arguments have been entered. $0 holds the commands / programs name itself. $1, $2,... are positional arguments that represent the command line arguments. \u0026quot;$@\u0026quot; Each Quoted string is treated as a separate argument (recommended over $*) $? Exit status of last command #!/bin/sh # emp2.sh: Non Interactive version - uses Comamnd line arguemnts echo \u0026#34;Program: $0 The Number of arguments specified is $# The arguments are $* \u0026#34; grep \u0026#34;$1\u0026#34; $2 echo \u0026#34;\\nJob Over\u0026#34;\rOutput\n$ emp2 director emp.lst Program: emp2.sh The Number of arguments spcified is 2 The arguments are director emp.lst (Grep results...) Job Over\rMaking the Script Flexible To make the script more versatile, replace the specific file name with $1, which represents the first argument passed to the script:\nhead -n 15 \u0026#34;$1\u0026#34; | tail -n 5\rNow, you can provide different file names as arguments when executing the script:\n$ bash middle.sh octane.pdb $ bash middle.sh pentane.pdb\rHandling Spaces in Filenames:\nTo ensure the script works with filenames that contain spaces, always enclose $1 in double quotes\nUsing Additional Arguments You can also modify the script to accept line numbers as arguments:\nTo make sure the numbers for head and tail can be altered by arguments, they can also be taken as $1 $2 $3 in middle.sh.\nhead -n \u0026#34;$2\u0026#34; \u0026#34;$1\u0026#34; | tail -n \u0026#34;$3\u0026#34;\rNow you can specify the number of lines for head and tail:\n$ bash middle.sh pentane.pdb 15 5 # 15 and 5 arguments for head and tail $ bash middle.sh pentane.pdb 20 5\rAdding Comments using # to make the script understandable:\nComments are ignored by the shell but provide clarity for users.\n# Select lines from the middle of a file. # Usage: bash middle.sh filename end_line num_lines. head -n \u0026#34;$2\u0026#34; \u0026#34;$1\u0026#34; | tail -n \u0026#34;$3\u0026#34;\rUsing $@ to Process Multiple Files To handle multiple files, use $@, which represents all command-line arguments:\n$ nano sorted.sh\rScript to sort files by their length:\n# Sort files by their length. # Usage: bash sorted.sh one_or_more_filenames wc -l \u0026#34;$@\u0026#34; | sort -n\rExecuting the script with multiple files:\n$ bash sorted.sh *.pdb ../creatures/*.dat\rexit and Exit status of command To terminate a program shell scripts use exit which is similar to exit() in C.\nThe command is generally run with a numeric arguments:\nexit 0 - Used when everything went fine.\nexit 1 - Used when something went wrong.\nNo Need to place them in script as shell understands when execution is complete.\nIt\u0026rsquo;s through the exit command that every command returns an exit status to caller as true or false. $? stores the exit status of the last command. echo $? showing 0 is success.\nExit status is important to devise program logic that branches into different paths on the success or failure of a command.\nMaking Scripts Interactive using read read statement is the shell\u0026rsquo;s internal tool for taking input from the user which makes the script interactive.\nIt is used with variables and the Input supplied through the standard input is real into these variables.\nWhen read name statement is used, script pauses and takes input from keyboard and stores it in the variable name.\nSince this is an assignment, no $ sign is needed before the name\necho \u0026#34;Enter the pattern to be searched: \\c\u0026#34; read pname echo \u0026#34;Enter the file to be used: \\c\u0026#34; read flname echo \u0026#34;Searching for $pname from file $flname\u0026#34; grep \u0026#34;$pname\u0026#34; $flname echo \u0026#34;Selected records shown above\u0026#34;\rA single read can be used with multiple variables to enter multiple arguments:\nread pname flname\nIf there are more variables then they stay unassigned, and if there are more arguments passed then thee extras are assigned to the last variable.\n","date":"2024-12-29","id":154,"permalink":"/personal-site/docs/bash-linux/linux_bash/bash-18-shell-scripts/","summary":"\u003cp\u003eA shell program runs in interpretive mode. It is not compiled into a separate executable file as a C Program is.  Each statement is loaded into memory when it is executed.\u003c/p\u003e","tags":[],"title":"Bash - 18 - Shell Scripts"},{"content":"Most commonly used Bash commands:\nls - List directory contents. cd - Change the current directory. pwd - Print the current working directory. cp - Copy files and directories. mv - Move or rename files and directories. rm - Remove files or directories. touch - Create an empty file or update the timestamp of an existing file. mkdir - Create a new directory. rmdir - Remove an empty directory. cat - Concatenate and display file contents. echo - Display a line of text or variables. grep - Search for patterns in files. find - Search for files and directories in a directory hierarchy. chmod - Change file permissions. chown - Change file owner and group. tar - Archive files. wget - Download files from the web. curl - Transfer data to or from a server. man - Display the manual for a command. history - Show the command history. These commands form the backbone of file management and system navigation in the Bash shell.\nhelp These shell commands are defined internally. Type `help\u0026#39; to see this list. Type `help name\u0026#39; to find out more about the function `name\u0026#39;. Use `info bash\u0026#39; to find out more about the shell in general. Use `man -k\u0026#39; or `info\u0026#39; to find out more about commands not in this list. A star (*) next to a name means that the command is disabled. job_spec [\u0026amp;] history [-c] [-d offset] [n] or hist\u0026gt; (( expression )) if COMMANDS; then COMMANDS; [ elif C\u0026gt; . filename [arguments] jobs [-lnprs] [jobspec ...] or jobs \u0026gt; : kill [-s sigspec | -n signum | -sigs\u0026gt; [ arg... ] let arg [arg ...] [[ expression ]] local [option] name[=value] ... alias [-p] [name[=value] ... ] logout [n] bg [job_spec ...] mapfile [-d delim] [-n count] [-O or\u0026gt; bind [-lpsvPSVX] [-m keymap] [-f file\u0026gt; popd [-n] [+N | -N] break [n] printf [-v var] format [arguments] builtin [shell-builtin [arg ...]] pushd [-n] [+N | -N | dir] caller [expr] pwd [-LP] case WORD in [PATTERN [| PATTERN]...)\u0026gt; read [-ers] [-a array] [-d delim] [-\u0026gt; cd [-L|[-P [-e]] [-@]] [dir] readarray [-d delim] [-n count] [-O \u0026gt; command [-pVv] command [arg ...] readonly [-aAf] [name[=value] ...] o\u0026gt; compgen [-abcdefgjksuv] [-o option] [\u0026gt; return [n] complete [-abcdefgjksuv] [-pr] [-DEI]\u0026gt; select NAME [in WORDS ... ;] do COMM\u0026gt; compopt [-o|+o option] [-DEI] [name .\u0026gt; set [-abefhkmnptuvxBCEHPT] [-o optio\u0026gt; continue [n] shift [n] coproc [NAME] command [redirections] shopt [-pqsu] [-o] [optname ...] declare [-aAfFgiIlnrtux] [name[=value\u0026gt; source filename [arguments] dirs [-clpv] [+N] [-N] suspend [-f] disown [-h] [-ar] [jobspec ... | pid \u0026gt; test [expr] echo [-neE] [arg ...] time [-p] pipeline enable [-a] [-dnps] [-f filename] [na\u0026gt; times eval [arg ...] trap [-lp] [[arg] signal_spec ...] exec [-cl] [-a name] [command [argume\u0026gt; true exit [n] type [-afptP] name [name ...] export [-fn] [name[=value] ...] or ex\u0026gt; typeset [-aAfFgiIlnrtux] name[=value\u0026gt; false ulimit [-SHabcdefiklmnpqrstuvxPRT] [\u0026gt; fc [-e ename] [-lnr] [first] [last] o\u0026gt; umask [-p] [-S] [mode] fg [job_spec] unalias [-a] name [name ...] for NAME [in WORDS ... ] ; do COMMAND\u0026gt; unset [-f] [-v] [-n] [name ...] for (( exp1; exp2; exp3 )); do COMMAN\u0026gt; until COMMANDS; do COMMANDS-2; done function name { COMMANDS ; } or name \u0026gt; variables - Names and meanings of so\u0026gt; getopts optstring name [arg ...] wait [-fn] [-p var] [id ...] hash [-lr] [-p pathname] [-dt] [name \u0026gt; while COMMANDS; do COMMANDS-2; done help [-dms] [pattern ...] { COMMANDS ; }\rinfo * Menu: Basics * Common options: (coreutils)Common options. * Coreutils: (coreutils). Core GNU (file, text, shell) utilities. * Date input formats: (coreutils)Date input formats. * Ed: (ed). The GNU line editor * File permissions: (coreutils)File permissions. Access modes. * Finding files: (find). Operating on files matching certain criteria. * Time: (time). time Compression * Gzip: (gzip). General (de)compression of files (lzw). Development * SSIP: (ssip). Speech Synthesis Interface Protocol. * Speech Dispatcher: (speech-dispatcher). Speech Dispatcher. Editors * nano: (nano). Small and friendly text editor. GNU organization * Maintaining Findutils: (find-maint). Maintaining GNU findutils GNU Utilities * dirmngr-client: (gnupg). X.509 CRL and OCSP client. * dirmngr: (gnupg). X.509 CRL and OCSP server. * gpg-agent: (gnupg). The secret key daemon. * gpg2: (gnupg). OpenPGP encryption and signing tool. * gpgsm: (gnupg). S/MIME encryption and signing tool. Individual utilities * arch: (coreutils)arch invocation. Print machine hardware name. * b2sum: (coreutils)b2sum invocation. Print or check BLAKE2 digests. * base32: (coreutils)base32 invocation. Base32 encode/decode data. * base64: (coreutils)base64 invocation. Base64 encode/decode data. * basename: (coreutils)basename invocation. Strip directory and suffix. * basenc: (coreutils)basenc invocation. Encoding/decoding of data. * cat: (coreutils)cat invocation. Concatenate and write files. * chcon: (coreutils)chcon invocation. Change SELinux CTX of files. * chgrp: (coreutils)chgrp invocation. Change file groups. * chmod: (coreutils)chmod invocation. Change access permissions. * chown: (coreutils)chown invocation. Change file owners and groups. * chroot: (coreutils)chroot invocation. Specify the root directory. * cksum: (coreutils)cksum invocation. Print POSIX CRC checksum. * cmp: (diffutils)Invoking cmp. Compare 2 files byte by byte. * comm: (coreutils)comm invocation. Compare sorted files by line. * cp: (coreutils)cp invocation. Copy files. * csplit: (coreutils)csplit invocation. Split by context. * cut: (coreutils)cut invocation. Print selected parts of lines. * date: (coreutils)date invocation. Print/set system date and time. * dd: (coreutils)dd invocation. Copy and convert a file. * df: (coreutils)df invocation. Report file system usage. * diff: (diffutils)Invoking diff. Compare 2 files line by line. * diff3: (diffutils)Invoking diff3. Compare 3 files line by line. * dir: (coreutils)dir invocation. List directories briefly. * dircolors: (coreutils)dircolors invocation. Color setup for ls. * dirname: (coreutils)dirname invocation. Strip last file name component. * du: (coreutils)du invocation. Report file usage. * echo: (coreutils)echo invocation. Print a line of text. * env: (coreutils)env invocation. Modify the environment. * expand: (coreutils)expand invocation. Convert tabs to spaces. * expr: (coreutils)expr invocation. Evaluate expressions. * factor: (coreutils)factor invocation. Print prime factors * false: (coreutils)false invocation. Do nothing, unsuccessfully. * find: (find)Invoking find. Finding and acting on files. * fmt: (coreutils)fmt invocation. Reformat paragraph text. * fold: (coreutils)fold invocation. Wrap long input lines. * groups: (coreutils)groups invocation. Print group names a user is in. * gunzip: (gzip)Overview. Decompression. * gzexe: (gzip)Overview. Compress executables. * head: (coreutils)head invocation. Output the first part of files. * hostid: (coreutils)hostid invocation. Print numeric host identifier. * hostname: (coreutils)hostname invocation. Print or set system name. * id: (coreutils)id invocation. Print user identity. * install: (coreutils)install invocation. Copy files and set attributes. * join: (coreutils)join invocation. Join lines on a common field. * kill: (coreutils)kill invocation. Send a signal to processes. * link: (coreutils)link invocation. Make hard links between files. * ln: (coreutils)ln invocation. Make links between files. * locate: (find)Invoking locate. Finding files in a database. * logname: (coreutils)logname invocation. Print current login name. * ls: (coreutils)ls invocation. List directory contents. * md5sum: (coreutils)md5sum invocation. Print or check MD5 digests. * mkdir: (coreutils)mkdir invocation. Create directories. * mkfifo: (coreutils)mkfifo invocation. Create FIFOs (named pipes). * mknod: (coreutils)mknod invocation. Create special files. * mktemp: (coreutils)mktemp invocation. Create temporary files. * mv: (coreutils)mv invocation. Rename files. * nice: (coreutils)nice invocation. Modify niceness. * nl: (coreutils)nl invocation. Number lines and write files. * nohup: (coreutils)nohup invocation. Immunize to hangups. * nproc: (coreutils)nproc invocation. Print the number of processors. * numfmt: (coreutils)numfmt invocation. Reformat numbers. * od: (coreutils)od invocation. Dump files in octal, etc. * paste: (coreutils)paste invocation. Merge lines of files. * patch: (diffutils)Invoking patch. Apply a patch to a file. * pathchk: (coreutils)pathchk invocation. Check file name portability. * pr: (coreutils)pr invocation. Paginate or columnate files. * printenv: (coreutils)printenv invocation. Print environment variables. * printf: (coreutils)printf invocation. Format and print data. * ptx: (coreutils)ptx invocation. Produce permuted indexes. * pwd: (coreutils)pwd invocation. Print working directory. * readlink: (coreutils)readlink invocation. Print referent of a symlink. * realpath: (coreutils)realpath invocation. Print resolved file names. * rm: (coreutils)rm invocation. Remove files. * rmdir: (coreutils)rmdir invocation. Remove empty directories. * runcon: (coreutils)runcon invocation. Run in specified SELinux CTX. * sdiff: (diffutils)Invoking sdiff. Merge 2 files side-by-side. * seq: (coreutils)seq invocation. Print numeric sequences * sha1sum: (coreutils)sha1sum invocation. Print or check SHA-1 digests. * sha2: (coreutils)sha2 utilities. Print or check SHA-2 digests. * shred: (coreutils)shred invocation. Remove files more securely. * shuf: (coreutils)shuf invocation. Shuffling text files. * sleep: (coreutils)sleep invocation. Delay for a specified time. * sort: (coreutils)sort invocation. Sort text files. * split: (coreutils)split invocation. Split into pieces. * stat: (coreutils)stat invocation. Report file(system) status. * stdbuf: (coreutils)stdbuf invocation. Modify stdio buffering. * stty: (coreutils)stty invocation. Print/change terminal settings. * sum: (coreutils)sum invocation. Print traditional checksum. * sync: (coreutils)sync invocation. Sync files to stable storage. * tac: (coreutils)tac invocation. Reverse files. * tail: (coreutils)tail invocation. Output the last part of files. * tee: (coreutils)tee invocation. Redirect to multiple files. * test: (coreutils)test invocation. File/string tests. * timeout: (coreutils)timeout invocation. Run with time limit. * touch: (coreutils)touch invocation. Change file timestamps. * tr: (coreutils)tr invocation. Translate characters. * true: (coreutils)true invocation. Do nothing, successfully. * truncate: (coreutils)truncate invocation. Shrink/extend size of a file. * tsort: (coreutils)tsort invocation. Topological sort. * tty: (coreutils)tty invocation. Print terminal name. * uname: (coreutils)uname invocation. Print system information. * unexpand: (coreutils)unexpand invocation. Convert spaces to tabs. * uniq: (coreutils)uniq invocation. Uniquify files. * unlink: (coreutils)unlink invocation. Removal via unlink(2). * updatedb: (find)Invoking updatedb. Building the locate database. * uptime: (coreutils)uptime invocation. Print uptime and load. * users: (coreutils)users invocation. Print current user names. * vdir: (coreutils)vdir invocation. List directories verbosely. * wc: (coreutils)wc invocation. Line, word, and byte counts. * who: (coreutils)who invocation. Print who is logged in. * whoami: (coreutils)whoami invocation. Print effective user ID. * xargs: (find)Invoking xargs. Operating on many files. * yes: (coreutils)yes invocation. Print a string indefinitely. * zcat: (gzip)Overview. Decompression to stdout. * zdiff: (gzip)Overview. Compare compressed files. * zforce: (gzip)Overview. Force .gz extension on files. * zgrep: (gzip)Overview. Search compressed files. * zmore: (gzip)Overview. Decompression output by pages. Kernel * grub-dev: (grub-dev). The GRand Unified Bootloader Dev * grub-install: (grub)Invoking grub-install. Install GRUB on your drive * grub-mkconfig: (grub)Invoking grub-mkconfig. Generate GRUB configuration * grub-mkpasswd-pbkdf2: (grub)Invoking grub-mkpasswd-pbkdf2. * grub-mkrelpath: (grub)Invoking grub-mkrelpath. * grub-mkrescue: (grub)Invoking grub-mkrescue. Make a GRUB rescue image * grub-mount: (grub)Invoking grub-mount. Mount a file system using GRUB * grub-probe: (grub)Invoking grub-probe. Probe device information * grub-script-check: (grub)Invoking grub-script-check. * GRUB: (grub). The GRand Unified Bootloader Libraries * RLuserman: (rluserman). The GNU readline library User\u0026#39;s Manual. Math * bc: (bc). An arbitrary precision calculator language. Miscellaneous * dc: (dc). Arbitrary precision RPN \u0026#34;Desktop Calculator\u0026#34;. Network applications * Wget: (wget). Non-interactive network downloader. Sound * SSIP: (ssip). Speech Synthesis Interface Protocol. * Say for Speech Dispatcher: (spd-say). Say. * Speech Dispatcher: (speech-dispatcher). Speech Dispatcher. Texinfo documentation system * info stand-alone: (info-stnd). Read Info documents without Emacs. Text creation and manipulation * Diffutils: (diffutils). Comparing and merging files. * grep: (grep). Print lines that match patterns. * sed: (sed). Stream EDitor. info bash Total manual\r","date":"2024-10-22","id":155,"permalink":"/personal-site/docs/bash-linux/command-docs/bash-commands/","summary":"\u003cp\u003eMost commonly used Bash commands:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\u003ca href=\"/personal-site/docs/bash-linux/command-docs/ls-list\"\u003e\u003cstrong\u003els\u003c/strong\u003e\u003c/a\u003e - List directory contents.\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"/personal-site/docs/bash-linux/command-docs/cd-change-directory\"\u003e\u003cstrong\u003ecd\u003c/strong\u003e\u003c/a\u003e - Change the current directory.\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"/personal-site/docs/bash-linux/command-docs/pwd\"\u003e\u003cstrong\u003epwd\u003c/strong\u003e\u003c/a\u003e - Print the current working directory.\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"/personal-site/docs/bash-linux/command-docs/cp-copy\"\u003e\u003cstrong\u003ecp\u003c/strong\u003e\u003c/a\u003e - Copy files and directories.\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"/personal-site/docs/bash-linux/command-docs/mv-move\"\u003e\u003cstrong\u003emv\u003c/strong\u003e\u003c/a\u003e - Move or rename files and directories.\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"/personal-site/docs/bash-linux/command-docs/rm-remove\"\u003e\u003cstrong\u003erm\u003c/strong\u003e\u003c/a\u003e - Remove files or directories.\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"/personal-site/docs/bash-linux/command-docs/touch\"\u003e\u003cstrong\u003etouch\u003c/strong\u003e\u003c/a\u003e - Create an empty file or update the timestamp of an existing file.\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"/personal-site/docs/bash-linux/command-docs/mkdir\"\u003e\u003cstrong\u003emkdir\u003c/strong\u003e\u003c/a\u003e - Create a new directory.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003ermdir\u003c/strong\u003e - Remove an empty directory.\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"/personal-site/docs/bash-linux/command-docs/cat-concatenate\"\u003e\u003cstrong\u003ecat\u003c/strong\u003e\u003c/a\u003e - Concatenate and display file contents.\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"/personal-site/docs/bash-linux/command-docs/echo\"\u003e\u003cstrong\u003eecho\u003c/strong\u003e\u003c/a\u003e - Display a line of text or variables.\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"/personal-site/docs/bash-linux/command-docs/grep\"\u003e\u003cstrong\u003egrep\u003c/strong\u003e\u003c/a\u003e - Search for patterns in files.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003efind\u003c/strong\u003e - Search for files and directories in a directory hierarchy.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003echmod\u003c/strong\u003e - Change file permissions.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003echown\u003c/strong\u003e - Change file owner and group.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003etar\u003c/strong\u003e - Archive files.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003ewget\u003c/strong\u003e - Download files from the web.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003ecurl\u003c/strong\u003e - Transfer data to or from a server.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eman\u003c/strong\u003e - Display the manual for a command.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003ehistory\u003c/strong\u003e - Show the command history.\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003eThese commands form the backbone of file management and system navigation in the Bash shell.\u003c/p\u003e","tags":[],"title":"Bash Commands"},{"content":"Loops are programming constructs that allow us to repeat a command or set of commands for each item in a list.\nShell features three loops - while, until and for. All of them repeat the instruction enclosed by certain keywords as often as their control command permits.\nwhile : Looping while performs a set of instructions until the control command returns a true exit status.\nwhile condition is true do commands done\rAny UNIX command or test can be used as the condition.\nanswer=y # must set it to y to enter the loop while [ \u0026#34;$answer\u0026#34; = \u0026#34;y\u0026#34; ] do echo \u0026#34;Enter the code and description: \\c\u0026#34; \u0026gt;/dev/tty read code description # reading both together echo \u0026#34;$code|$description\u0026#34; \u0026gt;\u0026gt; newlist echo \u0026#34;Enter any more (y/n)? \\c\u0026#34; \u0026gt;/dev/tty read anymore case $anymore in y*|Y*) answer=y ;; # accepts Yes, yes etc n*|N*) answer=n ;; *) answer=y ;; esac done\t\u0026gt;dev/tty is used to bring some outputs to the terminal.\nThe \u0026gt;\u0026gt; used inside to append the file opens and closes the file every time it is called, this can be avoided by providing the redirection of output at the done keyword itself as done \u0026gt; newlist which opens the file once and writes all the outputs.\nRedirection is available at the esac and fi keywords also, it can also include input redirection and piping.\ndone \u0026lt; param.lst - Statements in loops take inputs from param file.\ndone | while true - Pipes out to a while loop.\nfi \u0026gt; fio - Affects statements between if and fi.\nesac \u0026gt; foo - Affects statements between case and esac\nsleep command can be set inside the while loop to introduce delay in a script for some files or functions to occur and to check repeatedly after certain interval of time.\nusing true as the condition, the script can be made to run endlessly in the background to check or clear some processes.\nwhile true ; do df -t # df reports free space on disk sleep 300 done \u0026amp; # \u0026amp; after done runs the loop in the background\rThis keeps running in the background and it cannot be stopped with interrupt key ctrl + c to kill this loop. kill $! has to be used to kill the last background job.\nfor : Looping with a List for doesn\u0026rsquo;t test a condition, but uses a list instead:\nfor variable in list do commands done\rEach space separated word in list is assigned to the variable in turn, and commands are executed until list is exhausted.\nfor filename in basilisk.dat minotaur.dat unicorn.dat do echo $filename head -n 2 $filename | tail -n 1 done\r$ is used to denote a variable that will be replaced by its value. When Handling Filenames that has Spaces in them, enclose them in quotes:\nfor filename in \u0026#34;red dragon.dat\u0026#34; \u0026#34;purple unicorn.dat\u0026#34; do head -n 100 \u0026#34;$filename\u0026#34; | tail -n 20 done\rNote: Do not enclose $filename in quotes inside the loop.\nExample: Echoing Numbers\nfor number in 0 1 2 3 4 5 6 7 8 9 do echo $number done\rExample : Copying files to new extension\nfor file in chap20 chap21 chap22 chap23; do cp $file ${file}.bak echo $file copied to $file.bak done\rThe list can consist of practically any of the expressions that the shell understands and processes.\nLists from Variables, Wildcards, Command Substitutions, Positional Parameters are few sources.\nList from Variables :\nA series of variables in the command line can be used, which will be evaluated before executing the loop.\nfor var in $PATH $HOME ; do echo \u0026#34;$var\u0026#34;; done\rList from Command Substitution :\nTo pick up the list from a file when the list is very large and the list can be changed without changing the script.\nfor file in `cat clist`\rLists from wildcards :\nWhen the list consists of wildcards, the shell interprets them as file names.\nPrinting each file individually.\nfor data in *.pdb do ls $data done\rfor file in *.htm *.html ; do sed \u0026#39;s/strong/STRONG/g s/img src/IMG SRC/g\u0026#39; $file \u0026gt; $$ mv $$ $file gzip $file done\rList from Positional Parameters :\nProcessing positional parameters that are assigned from command line argument, by using $@ to scan from command line to get all of the arguments.\nfor pat in \u0026#34;$@\u0026#34; ; do grep \u0026#34;$pat\u0026#34; emp.lst || echo \u0026#34;pattern $pat not found\u0026#34; done\rExample Scripts Filtering Files : To print only specific files: This prints files starting with c\nfor filename in c* # to print cubane.pdb do ls $filename done\rTo print files that contain c:\nfor filename in *c* do ls $filename done\rSaving Output to a File in a Loop: This appends the contents of all .pdb files into alkanes.pdb. Using \u0026gt; would overwrite the file each time.\nfor alkanes in *.pdb do echo $alkanes cat $alkanes \u0026gt;\u0026gt; alkanes.pdb done\rCombining commands using a pipe (|) : This outputs the last 20 lines from the first 100 lines of each .dat file. So gives lines from 81 to 100.\nfor filename in *.dat do echo $filename head -n 100 $filename | tail -n 20 done\rCopying Files into Multiple Files\nUsing a wildcard directly with cp may raise errors: This fails if there are multiple files or last argument is not a directory.\ncp *.dat original-*.dat\rUsing a loop:\nfor filename in *.dat do cp \u0026#34;$filename\u0026#34; \u0026#34;original-$filename\u0026#34; done\rThis copies each .dat file with a prefix of original-. Now each of .dat file come one by one and in the cp there will be only two files,\nso will be copied into the other.\nTo echo commands without executing them:\nfor datafile in *.dat do echo \u0026#34;cat $datafile \u0026gt;\u0026gt; all.pdb\u0026#34; done\rUsing quotes here prevents the command from executing immediately.\nFinding Unique Entries :\nTo find unique species in CSV files, where the species is the second data field, use a loop to process each file: This script loops through all provided filenames and extracts unique species from each.\nfor file in \u0026#34;$@\u0026#34; do echo \u0026#34;Unique species in $file:\u0026#34; # Extract species names cut -d , -f 2 \u0026#34;$file\u0026#34; | sort | uniq done\rNested Loops Nest loops can perform more complex tasks:\nfor species in cubane ethane methane do for temp in 25 30 37 40 do mkdir \u0026#34;$species-$temp\u0026#34; done done\rThis creates directories named after each species combined with the temperature.\nbasename : Changing Filename Extensions basename extracts the \u0026ldquo;base\u0026rdquo; filename from an absolute pathname:\n$ basename /home/john/project/data.p1 data.p1\rWhen basename is used with two arguments, it strips off the second argument from the first argument\n$ basename ux2nd.txt txt ux2nd. # txt was stripped off\rThis feature can be used to rename file name extensions.\nfor file in *.txt ; do leftname=`basename $file txt` mv $file ${leftname}doc done\rset and shift : Manipulating the Positional parameters The set statement assigns its arguments to positional parameters $1, $2 and so on. and also sets the $# and $*\nset 987 234 534 echo \u0026#34;\\$1 is $1, \\$2 is $2, \\$3 is $3\u0026#34; $1 is 987, $2 is 234, $3 is 534 echo \u0026#34;The $# arguments are $*\u0026#34; The 3 arguments are 987 234 534\rExtracting individual fields from the date output\nset `date` echo $* Mon Jan 6 05:05:05 IST 2025 echo \u0026#34;The date today is $2 $3, $6\u0026#34; The date today is Jan 6, 2025\rSet by default parses the arguments on the delimiters specified in the environment variable IFS, which is by default whitespace. This can be changed to make set work on different delimiters so any field can be extracted without using cut.\nshift : Shifting Arguments Left shift transfers the contents of a positional parameter to its immediate lower numbered one. This can be done as many times as the statement is called.\n$2 becomes $1 and so on.\nset `date` echo \u0026#34;$@\u0026#34; # $* and \u0026#34;$@\u0026#34; are interchangable Mon Jan 6 05:05:05 PM IST 2025 echo $1 $2 $3 Mon Jan 6 shift 2 # to shift 2 places echo $1 $2 $3 6 05:05:05 PM\rThe contents of the left most parameters $1 is lost everytime shift is invoked. so that value has to be saved in a variable before using shift.\nSave the first three and then use shift 3.\nIf there are 12 arguments, $10 can be accessed by first shifting it to $9\nThere will be issue when the string passed to set has letters starting with - which will get interpreted as options and cause error, or when the passed command returns null.\nBy using two hyphens -- after the set will make whatever comes after it to be treated as arguments only.\n\u0026laquo; Here Document Is used to pass a set of arguments to run a interactive program non interactively.\ntrap : Interrupting a Program Shell scripts terminate whenever the interrupt key is pressed. which is not a good way to end programs as it might leave lot of temporary files on disk.\nThe trap statement lets us do what we want to do when the script receives a signal.\nThe statement is normally placed at the beginning of a shell script and uses two lists:\ntrap \u0026#39;command_list\u0026#39; signal_list\rThe signal list can contain the integer values or names of one or more signals - the ones used with the kill command.\nSo instead of using 2 15 to represent the signal list, it can be INT TERM\ntrap \u0026#39;rm $$* ; echo \u0026#34;Program interrupted\u0026#34; ; exit \u0026#39; HUP INT TERM\rtrap is a signal handler. It first removes the files, echoes a message and finally terminates the script when the signals SIGHUP(1), SIGINT(2) or SIGTERM(15) are sent to the shell process running the script.\nWhen Interrupt key is pressed, it sends the number 2.\nScript can be made to ignore the signal and continue by passing a null command list.\ntrap \u0026#39;\u0026#39; 1 2 15 # script can\u0026#39;t be killed by normal means\r","date":"2024-12-29","id":156,"permalink":"/personal-site/docs/bash-linux/linux_bash/bash-18.2-shell-scripts-loops/","summary":"\u003cp\u003eLoops are programming constructs that allow us to repeat a command or set of commands for each item in a list.\u003cbr\u003e\nShell features three loops - \u003ccode\u003ewhile\u003c/code\u003e, \u003ccode\u003euntil\u003c/code\u003e and \u003ccode\u003efor\u003c/code\u003e. All of them repeat the instruction enclosed by certain keywords as often as their control command permits.\u003c/p\u003e","tags":[],"title":"Bash - 18.2 - Shell Scripts - Loops"},{"content":"","date":"2024-12-17","id":157,"permalink":"/personal-site/docs/python/1data-types/","summary":"","tags":[],"title":"Python Data Types"},{"content":"","date":"2023-09-07","id":158,"permalink":"/personal-site/docs/","summary":"","tags":[],"title":"All Notes Articles"},{"content":"An Operating System (OS) is software that manages computer hardware and serves as an intermediary between the user and the computer hardware. Its primary purpose is to provide an environment in which users can execute programs efficiently and conveniently.\nChapter 1 : Introduction An Operating System is a software that manages a computer\u0026rsquo;s hardware and is responsible for allocating resources (CPU, memory, I/O devices, storage) to various programs. It acts as an intermediary between the user and the hardware, aiming to make the user experience both convenient and efficient.\nMainframe OS: Designed to optimize hardware utilization. PC OS: Supports a variety of applications, from games to business tools. Mobile OS: Provides an easy-to-use environment for interface with computer and program execution. 1.1 Components of an Operating System\r1.1 What Operating Systems Do A computer system consists of the following four components:\nHardware: Includes the CPU, memory, and I/O devices which provide the system’s basic resources. Operating System: Controls the hardware and coordinates its use among different application programs and users. Application Programs: Software such as word processors, spreadsheets, and web browsers that help users solve problems by utilizing hardware resources. Users: Individuals interacting with the system, running applications, and using the hardware. The operating system itself does not perform any useful functions; it simply provides an environment where other programs can perform useful work.\n1.1.1 User View Personal Computers (PCs) A PC is optimized for use by a single person. It prioritizes ease of use and performance, with less concern for resource utilization or how hardware and software resources are shared.\nMainframe/Minicomputers Mainframes and minicomputers are designed to handle multiple users where resources and information is shared. These systems focus on maximizing resource utilization, ensuring that all resources (CPU, memory, I/O) are used efficiently and that no individual user monopolizes the resources.\nWorkstations Workstations are connected to networks of other workstations and servers. They may have dedicated resources while still sharing some with other systems. Their OS strikes a balance between individual usability and resource utilization.\n1.1.2 System View The OS functions as a Resource allocator and is directly involved with the computer hardware.\nIn multi-user environments (e.g., mainframes), efficient resource allocation is crucial, as the OS must determine how to distribute resources such as CPU time, memory space, file-storage space and I/O devices among programs and users when there are numerous or conflicting requests for resources.\nThe OS acts as a control program, managing the execution of user programs to prevent errors and ensure proper system use, particularly when managing I/O devices.\n1.1.3 Defining Operating Systems An OS is the core program running on a computer, often referred to as the Kernel. Along with the Kernel, there are system programs and application programs that provide the necessary functions and services to users.\nKernel: The central part of the OS that manages hardware and system resources. System Programs: Additional software that helps in managing and interacting with system hardware and resources. Application Programs: Programs used by the end user for specific tasks, such as word processors, web browsers, etc. In mobile operating systems, the OS includes not only the Kernel but also middleware, which provides additional services to application developers, such as support for databases, multimedia, and graphics. Examples of mobile OS include iOS and Android, both of which integrate Kernel and middleware for comprehensive functionality.\nCreation of OS Hardware are constructed to solve problems of users. Since bare hardware alone is not easy to use, application programs are developed. These programs require certain common operations (controlling I/O devices, allocating resources), which are brought together into one piece of software which is the OS. The OS was developed to provide a user-friendly layer between users and the hardware.\nAs hardware grew more complex, OS software evolved to manage the increasing variety of resources and user needs.\nEarly Uses of Computers: Initially used for tasks like code-breaking, trajectory plotting, and government calculations. Moore’s Law: First proposed in 1960, Moore\u0026rsquo;s Law predicted that the number of transistors on an integrated circuit would double every 18 months, a trend that continues today. ","date":"2025-01-12","id":159,"permalink":"/personal-site/docs/os/c01_introduction/os-1.01-operating-systems-introduction/","summary":"\u003cp\u003eAn \u003cstrong\u003eOperating System (OS)\u003c/strong\u003e is software that manages computer hardware and serves as an intermediary between the user and the computer hardware. Its primary purpose is to provide an environment in which users can execute programs efficiently and conveniently.\u003c/p\u003e","tags":[],"title":"OS 1.01 - Operating Systems Introduction"},{"content":"","date":"2025-01-12","id":160,"permalink":"/personal-site/docs/os/c01_introduction/","summary":"","tags":[],"title":"OS - 01 - Operating Systems Introduction"},{"content":"","date":"2025-01-12","id":161,"permalink":"/personal-site/docs/os/","summary":"","tags":[],"title":"Operating System Concepts"},{"content":"Interrupts, System Calls, and Modes of Operation\nInterrupt-Driven Systems Modern Operating Systems are interrupt-driven, meaning they rely on interrupts to perform tasks. If there are no I/O devices to service or no user requests, the OS remains idle, waiting for events to occur.\nAn interrupt is a signal to the processor indicating that an event has occurred, prompting the OS to take specific actions.\nA trap (or exception) is a software-generated interrupt triggered by errors (e.g., division by zero, invalid memory access) or by a user program requesting an operating system service.\nInterrupt vs. Trap Both traps and interrupts allow the operating system to take control of the processor but are triggered differently and serve distinct purposes:\nInterrupts are hardware-driven, typically caused by external events (e.g., I/O operations, timers), while traps are software-driven, usually caused by program errors or system service requests. 1. Interrupt: Cause: Hardware-driven events, such as I/O operations or timers. Function: Temporarily halts the processor to handle the event, after which execution resumes. Example: Keyboard press, network packet, disk I/O completion. 2. Trap (Exception): Cause: Software-generated, typically due to errors or system calls during program execution. Function: Signals the OS for special handling (e.g., error handling or service request). Example: Division by zero or invalid memory access. Interrupts are hardware-managed and often require privileged instructions, while traps can be triggered by user programs for system calls but cannot directly cause interrupts.\nFeature Interrupt Trap (Exception) Trigger Hardware event (asynchronous) Software event (synchronous) Cause External devices (I/O, timer, etc.) Program errors or system calls (e.g., divide by zero, invalid memory access) Control Flow OS takes control to handle the event OS takes control via a system call or error during program execution Handling Handled by service routines for hardware events Handled by error handling or system service routines Interrupt Service Routine For each type of interrupt, the OS contains specific code that determines the appropriate action. The OS uses an Interrupt Service Routine (ISR) to handle interrupts when they occur.\nSince both the OS and users share the hardware and software resources, any error in a user program should only affect that particular program, not the entire system. However, issues such as infinite loops or erroneous programs modifying data from other programs can cause system-wide problems.\nA properly designed OS ensures that a faulty or malicious program does not negatively affect other running programs or the OS itself.\n1.5.1 Dual-Mode and Multi-Mode Operation User Mode vs Kernel Mode To protect the OS from errant user programs and vice versa, the OS operates in two main modes: User Mode and Kernel Mode (also called system mode, privileged mode, or supervisor mode).\nUser Mode (1): The mode in which user applications run. Kernel Mode (0): The privileged mode in which the OS operates and can execute sensitive instructions. A mode bit is added to the CPU to indicate the current mode of operation. This dual-mode operation helps protect the OS by restricting certain instructions, called privileged instructions, to Kernel Mode.\nExamples of privileged instructions:\nSwitching between modes (User to Kernel or Kernel to User) I/O control Timer management Interrupt management 1.10 User Mode to Kernel Mode\rMulti-Mode Operation Some CPU\u0026rsquo;s support more than two modes of operation.\nFor example, systems supporting virtualization may have a mode for the Virtual Machine Manager (VMM) that has more privileges than user programs to create virtual machines and to change the state of CPU but fewer privileges than the Kernel.\nCPU\u0026rsquo;s like the Intel 64 family support privilege levels for virtualization, but they do not have a separate mode specifically for virtualization.\nMode Transition and Control Flow Boot time: The system starts in Kernel Mode. User applications: When the OS loads user applications, it switches to User Mode. System Call/Interrupt/Trap: When a user application requests OS services or an error occurs, the system switches to Kernel Mode to process the request or handle the issue. Return to User Mode: Once the OS has completed the task, it returns to User Mode to resume the user application. System Calls A System Call is a mechanism that allows a user program to request services from the OS to perform tasks on the user program\u0026rsquo;s behalf, typically involving privileged operations that are otherwise restricted.\nSystem calls are usually implemented as traps that transfer control to a specific location in the interrupt vector.\nExecution of a system call When a system call is executed, it is treated by the hardware as a software interrupt. The interrupt vector passes control to a service routine in the OS, and the system switches to Kernel Mode. (The system-call service routine is a part of the operating system. ) The kernel examines the interrupting instruction to determine what system call has occurred. A parameter indicates what type of service the user program is requesting. The OS then verifies the system call parameters to be legal. Executes the requested task, and returns control to the user program. Control Flow of a System call\nInterrupt / Trap Interrupt Vector OS Service routine (System-call service routine in OS) Kernel Example in MIPS: A specific syscall instruction is used to invoke a system call.\nPreventing Illegal Execution Once hardware protection like mode bit is in place, it detects errors that violate modes.\nWhen the system is in Kernel Mode, it can detect errors that violate the operating modes, such as illegal instruction execution or unauthorized memory access. These errors are handled by the OS:\nIf a user program attempts to execute an illegal instruction or access unauthorized memory which is not in the user\u0026rsquo;s address space, the hardware traps to the OS. The OS handles the error, typically terminating the program abnormally and providing an error message. The system may also generate a memory dump for debugging purposes, which is saved to a file for analysis. The absence of hardware-supported dual-mode operation can lead to serious issues. For instance, MS-DOS, which was designed for the Intel 8088 without a mode bit, allowed user programs to overwrite the OS and access hardware directly, resulting in potential system crashes.\n1.5.2 Timer Timer is a component that can interrupt the system after a fixed or variable period, preventing user programs from running indefinitely. It is a critical component in the OS to maintain control over execution.\nA fixed-rate clock and a counter are used to implement a variable timer. The OS initializes the counter, and each time the clock ticks, the counter is decremented. When the counter reaches zero, an interrupt occurs. Timer interrupts ensure that a program does not run too long or gets stuck in an infinite loop and never return control to OS. OS ensures that timer is set before transferring control to a user program. If the timer interrupts, control is passed back to the OS, which can either treat the interrupt as an error or extend the program\u0026rsquo;s time.\nInstructions that modify the content of the timer are privileged.\nTimer Usage Example A program with a 7-minute limit could have its timer initialized to 420 (7 minutes in seconds). Each second, the counter decrements by 1, and control returns to the user program as long as the counter is positive. If the counter reaches zero, the OS terminates the program for exceeding its time limit. Example Timer Configuration:\nA 10-bit counter with a 1-millisecond clock allows for interrupts at intervals ranging from 1 millisecond to 1,024 milliseconds (1 second).\n","date":"2025-01-12","id":162,"permalink":"/personal-site/docs/os/c01_introduction/os-1.05-os-operations/","summary":"\u003cp\u003eInterrupts, System Calls, and Modes of Operation\u003c/p\u003e\n\u003ch3 id=\"interrupt-driven-systems\"\u003e\u003cstrong\u003eInterrupt-Driven Systems\u003c/strong\u003e\u003c/h3\u003e\n\u003cp\u003eModern Operating Systems are \u003cstrong\u003einterrupt-driven\u003c/strong\u003e, meaning they rely on \u003cstrong\u003einterrupts\u003c/strong\u003e to perform tasks. If there are no I/O devices to service or no user requests, the OS remains idle, waiting for events to occur.\u003c/p\u003e","tags":[],"title":"OS 1.05 - OS Operations"},{"content":"1.11.1 Traditional Computing Traditional computing refers to the setup where computing resources, such as servers and workstations, are located locally in a company or institution. Web technologies and increasing WAN (Wide Area Network) bandwidth are expanding the boundaries of traditional computing.\nCompanies establish portals to provide web access to their internal servers, improving accessibility and collaboration. Network Computers (NCs) or Thin Clients are now used in place of traditional workstations. These terminals mainly handle web-based computing and have limited local processing power. NCs are ideal for environments where: More security is required. Easier maintenance and management are desired. This shift towards thin clients helps reduce the complexity and cost of maintaining individual workstations, as most tasks are handled on centralized servers.\n1.11.2 Mobile Computing Mobile computing refers to the use of portable computing devices (like smartphones, tablets, and laptops) that can connect to networks wirelessly.\nOS for mobile devices is designed to be lightweight and optimized for touch interfaces. Ex: iOS, Android, Windows Mobile Key features: Portability: Devices are highly portable, allowing users to stay connected anytime, anywhere. Battery Optimization: Mobile OSes are designed to conserve battery life while providing performance. Wireless Networking: Mobile devices depend on wireless technologies like Wi-Fi, Bluetooth, and cellular networks for connectivity. Mobile computing plays a crucial role in enabling personal and professional communication, productivity, and entertainment on the go.\n1.11.3 Distributed Systems A distributed system is a collection of independent computers that appear to the user as a single system. These systems are designed to distribute workloads across multiple machines, providing benefits in terms of reliability, scalability, and performance.\nExamples: Cloud services, large-scale web applications Key Features: Fault Tolerance: If one node fails, others can continue the task. Scalability: More machines can be added to increase computational power. Resource Sharing: Multiple devices can share resources like storage, processing power, and data. Distributed systems rely heavily on networked communication and require sophisticated OS management to ensure that the entire system functions efficiently.\n1.11.4 Client-Server Computing In client-server computing, tasks are divided between service providers (servers) and requesters (clients).\nClients: These are devices or programs that request services or resources from a server. Servers: These are machines or applications that provide services, data, or resources to clients over a network. Examples:\nA web browser (client) requesting a webpage from a web server. An email client (client) requesting and receiving emails from an email server. Key benefits of client-server architecture:\nCentralized data management and security. Efficient use of resources. The OS in client-server systems manages both the server-side and client-side processes, ensuring smooth communication and operation.\n1.11.5 Peer-to-Peer Computing Peer-to-peer (P2P) computing refers to a network model in which each participant (node) acts both as a client and a server, sharing resources with other nodes.\nDecentralization: There is no central server. All nodes are equal and share resources. File Sharing: Popular for file-sharing systems like BitTorrent, where files are distributed across multiple peers. Key Advantages:\nScalability and resilience due to the lack of a single point of failure. Direct communication between peers, reducing network congestion. However, P2P systems can be less secure compared to client-server models because data is directly exchanged between users.\n1.11.6 Virtualization Virtualization refers to the technology that enables running multiple virtual operating systems (VMs) on a single physical machine.\nEmulation: In emulation, the CPU architecture of the host machine is different from the guest machine. It allows programs written for one system to run on a completely different one (e.g., Apple\u0026rsquo;s Rosetta emulator enabling software built for IBM architecture to run on Intel processors). Interpretation: This involves running programs in a non-native format, often by translating high-level code into a language understood by the host machine (e.g., Java being interpreted by the Java Virtual Machine, or JVM). (Computer language is not compiled to native code but instead is either executed in its high-level form or translated to an intermediate form.) In contrast to full emulation, virtualization runs a guest OS natively on the host\u0026rsquo;s hardware, allowing for efficient resource utilization.\nKey Benefits:\nAllows multiple OS environments on a single machine. Facilitates better resource management and isolation. Enables testing and development of different OS setups without needing separate hardware. 1.20 Virtualization\rJava is always interpreted. Interpretation is a form of emulation, the high level language code is translated to native CPU instructions, emulating a theoretical virtual machine on which that language could run natively.\nJava programs are run on \u0026ldquo;Java virtual machines\u0026rdquo;, but technically those virtual machines are Java emulators.\n1.21 Java Virtual Machine\r1.11.7 Cloud Computing Cloud computing refers to the delivery of computing services—including storage, networking, databases, software applications, and processing power—over the internet. Rather than owning and maintaining physical servers and infrastructure, organizations and individuals can rent computing resources from cloud service providers on-demand.\nCloud computing allows users to access services remotely from any device with an internet connection, offering flexibility, scalability, and cost efficiency. Cloud services are typically offered under a subscription-based model.\nTypes of Clouds: Public Cloud: In a public cloud, the cloud resources (servers, storage, and applications) are owned and operated by a third-party provider and made available to the general public.\nExamples:\nAmazon Web Services (AWS): Offers cloud computing services, including EC2 (Elastic Compute Cloud) and S3 (Simple Storage Service), which provide virtual servers and scalable storage for businesses. Microsoft Azure: Provides services such as virtual machines, storage solutions, and cloud databases. Azure is widely used by enterprises for hosting applications and services. Google Cloud Platform (GCP): Offers infrastructure services such as Compute Engine and Cloud Storage. Pros:\nLower upfront costs, pay-as-you-go pricing model. Scalable resources that can be adjusted based on demand. Reduced management and maintenance overhead. Cons:\nData security concerns, as the data is stored off-site with a third-party provider. Limited customization options compared to private clouds. Private Cloud: In a private cloud, the cloud infrastructure is used exclusively by a single organization. The resources may be hosted on-premises or by a third-party provider.\nExamples:\nVMware vSphere: Offers virtualization technologies for building private clouds and managing virtual machines. OpenStack: An open-source platform for building and managing private clouds. Pros:\nEnhanced security and control over data. Customizable infrastructure to meet specific organizational needs. Typically better suited for businesses with compliance or regulatory requirements. Cons:\nHigher upfront cost for hardware and management. Limited scalability compared to public cloud services. Hybrid Cloud: A hybrid cloud combines both public and private clouds, allowing data and applications to be shared between them. This provides businesses with greater flexibility and optimization of existing infrastructure.\nExamples:\nA company might run sensitive workloads (such as financial data) in a private cloud for security and compliance, while using a public cloud for less sensitive workloads (like customer relationship management or backup storage). Microsoft Azure Hybrid Cloud: Allows seamless integration of on-premises infrastructure with Azure\u0026rsquo;s cloud services. Pros:\nFlexibility to scale and deploy workloads across multiple environments. Offers cost-efficiency by utilizing public cloud resources for less sensitive operations, while maintaining private cloud for more secure processes. Cons:\nComplexity in managing both private and public clouds simultaneously. Potential integration challenges between different cloud environments. Community Cloud: A community cloud is shared by several organizations with similar interests or requirements, typically in a specific industry or regulatory domain. It allows for shared infrastructure and resources, yet still maintains a level of privacy and security for each organization.\nExamples:\nA healthcare provider network might use a community cloud to store and manage patient data while ensuring HIPAA compliance. Government agencies with shared security protocols may opt for a community cloud to meet regulatory standards while sharing resources. Pros:\nCost-effective for organizations with similar needs or regulatory requirements. Offers higher control and privacy compared to public clouds. Cons:\nLimited customization compared to private clouds. May involve more complex governance compared to private or public clouds. Cloud Service Models: Cloud services are typically categorized into three primary service models, which differ in the level of control and responsibility retained by the user:\nInfrastructure as a Service (IaaS): IaaS provides virtualized computing resources over the internet, including virtual machines, storage, and networks. The user is responsible for managing the operating system, applications, and data, while the provider handles the physical infrastructure.\nExamples:\nAmazon EC2 (Elastic Compute Cloud): Offers scalable computing capacity and allows users to launch virtual servers to run applications. Microsoft Azure Virtual Machines: Allows users to deploy and manage virtual machines on the Azure cloud. Google Compute Engine: Provides virtual servers and storage solutions for building cloud applications. Pros:\nFlexible and scalable infrastructure. Users can scale resources up or down based on demand. Ideal for hosting websites, applications, and testing environments. Cons:\nRequires users to manage the operating system and applications, which may increase complexity. Security and compliance need to be managed by the user. Platform as a Service (PaaS): PaaS provides a platform that allows developers to build, deploy, and manage applications without dealing with the underlying hardware or operating systems. The provider handles the infrastructure, operating systems, and runtime environments.\nExamples:\nGoogle App Engine: Allows developers to build and deploy applications on Google\u0026rsquo;s infrastructure without worrying about hardware or OS management. Heroku: A cloud platform for building, running, and scaling applications, supporting several programming languages. Microsoft Azure App Services: Provides a platform for building web applications, APIs, and mobile backends. Pros:\nSimplifies development and deployment of applications. Scalable with built-in tools for monitoring and managing applications. Developers can focus on coding without worrying about infrastructure or hardware. Cons:\nLimited flexibility compared to IaaS. Can lead to vendor lock-in if relying heavily on a specific platform. Software as a Service (SaaS): SaaS delivers software applications over the internet on a subscription basis. Users access applications through a web browser, and the provider manages the underlying infrastructure, platform, and software updates.\nExamples:\nGoogle Workspace (formerly G Suite): A suite of productivity applications, including Gmail, Google Docs, Sheets, and Drive, all accessible via a web browser. Salesforce: A CRM (Customer Relationship Management) software that is fully hosted on the cloud and accessible from anywhere. Dropbox: A cloud-based file storage and sharing platform. Pros:\nNo need to manage infrastructure or software updates. Accessible from any device with an internet connection. Subscription-based, reducing upfront costs. Cons:\nLimited customization options for software features. Data security concerns, as the data is hosted on third-party servers. Function as a Service (FaaS): FaaS, or serverless computing, allows users to execute individual functions or code in response to events without managing the underlying infrastructure. The cloud provider automatically handles the scaling and resources needed for the execution.\nExamples:\nAWS Lambda: Enables users to run code in response to events such as file uploads or API calls, without managing servers. Azure Functions: Provides a serverless compute service for running event-driven functions. Pros:\nNo need to manage servers, reducing operational complexity. Cost-efficient, as users only pay for the execution time of the functions. Cons:\nLimited control over infrastructure. May not be suitable for long-running or stateful applications. Database as a Service (DBaaS): DBaaS allows users to host, manage, and scale databases without handling the underlying infrastructure. The cloud provider manages database performance, backups, and scalability.\nExamples:\nAmazon RDS (Relational Database Service): Allows users to host, manage, and scale relational databases such as MySQL, PostgreSQL, and Oracle. Google Cloud SQL: A fully-managed relational database service for MySQL, PostgreSQL, and SQL Server. Pros:\nManaged database services reduce administrative overhead. Automated backups, scaling, and performance optimization. Cons:\nLimited customization compared to on-premises databases. May involve data security and compliance challenges. Key Benefits of Cloud Computing: Scalable Resources on Demand: Cloud services allow businesses to scale their computing resources up or down based on demand. For example, an e-commerce website might require more resources during a holiday sale and scale back afterward. Pay-as-You-Go Pricing Models: With cloud computing, users only pay for the resources they use. This helps businesses avoid upfront infrastructure costs and scale efficiently. Accessibility: Cloud services can be accessed from any device with an internet connection, allowing for greater flexibility and mobility. Remote work and collaboration become more efficient, as users can access their data and applications from anywhere. 1.11.8 Real-Time Embedded Systems These are the most prevalent type of computers which are in all kinds of devices with very specific tasks. Their systems are limited, have little or no user interface. Mostly monitoring and managing hardware devices.\nEmbedded systems are specialized computing systems designed to perform dedicated functions with specific requirements. Many embedded systems are real-time systems.\nReal-Time Operating System (RTOS): An OS designed to handle real-time tasks with strict timing constraints. These systems must process inputs and produce outputs within a defined time period, or they will fail. Examples of Real-Time Systems:\nScientific Instruments: Used in laboratories to process experimental data in real-time. Medical Devices: Devices like pacemakers or MRI machines that need to operate under strict time constraints. Automobile Systems: Engine control units (ECUs) and safety systems that require immediate responses to sensor data. In home appliance controllers and weapon systems. Real-time embedded systems are commonly found in industries such as aerospace, healthcare, automotive, and industrial automation.\nKey Features:\nPredictable response time. High reliability and uptime. Low latency for critical operations. There are embedded systems with OS and special purpose applications to implement the functionality. Others are devices with special purpose OS providing just the desired functionality. Others are (ASICs) application-specific Integrated circuits that perform the tasks without an operating system.\nAreas of Real Time Embedded systems usage 1. Aerospace \u0026amp; Defense Flight Control Systems: ensure that the flight control systems (e.g., autopilot, navigation, and thrust management) respond promptly to inputs like altitude changes, turns, or environmental factors.\nMissile Guidance Systems: In missiles or drones perform real-time processing of sensor data (e.g., GPS, radar, infrared) to guide the missile to its target with precise timing for tracking and course corrections.\nRadar Systems: processing of signals and data from radars ensures immediate response to changing environmental conditions or threats.\nAir Traffic Control Radar Systems: Process the movement of aircraft in real-time to ensure safe air traffic management. 2. Automotive Anti-lock Braking System (ABS): Continuously monitors wheel speed sensors and adjusts brake pressure to prevent skidding during hard braking.\nAutonomous Vehicles: Used to process data from sensors (LIDAR, cameras, radar) to make split-second decisions for autonomous driving and braking.\nEngine Control Units (ECU): Manage engine performance, including fuel injection, ignition timing, and exhaust controls, ensuring optimal engine behavior, fuel efficiency and emissions.\n3. Healthcare \u0026amp; Medical Devices Pacemakers: Monitor heart activity and adjust pacing to maintain a regular heartbeat.\nInfusion Pumps: Control the rate at which drugs or fluids are administered to patients, responding instantly to changes in dosage or medical parameters.\nMedical Imaging Systems: Systems like MRI, CT scanners, and ultrasound machines rely on real-time embedded systems to process large amounts of imaging data in real-time.\nVital Signs Monitors: Embedded systems continuously monitor heart rate, oxygen saturation, and blood pressure in patients, providing immediate alerts for any abnormalities.\n4. Industrial Automation Robotic Arm Control: Embedded systems control robotic arms used in manufacturing and assembly lines, ensuring real-time precision and accuracy.\nProcess Control Systems: In industries like oil and gas, power generation, and chemicals, real-time embedded systems control and monitor critical processes (e.g., temperature, pressure, flow rate).\nPrecise control of chemical reactions or energy generation, responding immediately to sensor data to maintain system stability. Conveyor Systems: Real-time embedded systems manage the speed and direction of conveyor belts used in sorting or assembly lines.\n5. Consumer Electronics Smartphones: rely on real-time embedded systems to handle various functions like touch screen input, GPS navigation, and camera operation.\nSmart TVs: allow smart TVs to process streaming data, manage user interfaces, and synchronize audio and video streams.\nGame Consoles: manage processing power, network connections, and gameplay responses in real-time.\n6. Telecommunications Network Routers and Switches: manage network traffic, ensuring that data packets are transmitted efficiently and with minimal delay.\nBase Stations in Mobile Networks: cellular base stations process signals from mobile devices and handle real-time communication. Managing high-speed data transmission, adjusting frequencies and power levels for efficient communication.\n7. Energy Management Smart Grids: Monitor and control energy distribution in smart grids, responding to changes in demand and grid conditions to prevent outages.\nWind Turbine Control Systems: Adjust blade angles and motor speed to maximize energy generation while maintaining safe operation.\nSolar Panel Controllers: Manage the charging of batteries or the direct supply of power to the grid.\n8. Entertainment \u0026amp; Media Digital Cameras: Real-time embedded systems in digital cameras process images from sensors and adjust settings like exposure, focus, and white balance in real-time. Ensuring clear, high-quality photos are captured instantly.\nVirtual Reality (VR) and Augmented Reality (AR): Devices process real-time inputs from motion sensors, cameras, and external controllers to create immersive experiences.\n9. Security \u0026amp; Surveillance Surveillance Cameras: Process video feeds, detect motion, and trigger recording or alerts when necessary.\nBiometric Systems: Process inputs like fingerprints, retina scans, or facial recognition for immediate authentication.\n10. Real-Time Embedded Systems in Home Appliances Smart Thermostats Washing Machines Dishwashers Refrigerators Microwave Ovens Air Conditioners Smart Coffee Makers Smart Locks Smart Light Bulbs Vacuum Cleaners Smoke Detectors ","date":"2025-01-12","id":163,"permalink":"/personal-site/docs/os/c01_introduction/os-1.11-computing-environments/","summary":"\u003ch4 id=\"1111-traditional-computing\"\u003e1.11.1 Traditional Computing\u003c/h4\u003e\n\u003cp\u003eTraditional computing refers to the setup where computing resources, such as servers and workstations, are located locally in a company or institution. Web technologies and increasing WAN (Wide Area Network) bandwidth are expanding the boundaries of traditional computing.\u003c/p\u003e","tags":[],"title":"OS 1.11 - Computing Environments"},{"content":"The main three aspects of an OS are its Services, Interfaces, and Components.\nOS Components and Their Interconnection The OS is made up of several interconnected components that work together to provide the services required by both users and applications. These components include:\nKernel: The core part of the OS responsible for managing hardware resources and facilitating communication between hardware and software. The kernel interacts directly with the hardware, scheduling processes and managing memory.\nProcess Management: This component manages the creation, scheduling, and termination of processes. It also handles inter-process communication and synchronization.\nMemory Management: The memory manager allocates and deallocates memory for processes and ensures efficient use of available memory, including virtual memory management.\nFile System: This component handles the organization, storage, retrieval, and manipulation of data in files. It also manages file access permissions.\nI/O System: The I/O system facilitates communication between the OS and external devices, such as hard drives, printers, and displays.\nSecurity and Protection: The OS uses this component to enforce security policies and ensure that resources are protected from unauthorized access.\n2.1 Operating System Services\rOperating System Services An operating system provides various services that enable the proper functioning of applications, hardware, and system management.\nThese services are crucial for handling processes, input/output (I/O), memory management, and security.\n1. Program Execution The OS is responsible for loading a program into memory, executing it, and managing its life-cycle.\nThis includes terminating the program either normally or abnormally (e.g., due to an error or user request).\n2. I/O Operations I/O operations involve interacting with devices like storage drives, printers, or networks. e.g., reading data from a keyboard, writing data to a screen.\nThe OS acts as an intermediary to ensure that programs can perform I/O operations efficiently and securely.\n3. File-System Manipulation The OS allows programs to create, read, write, and delete files or directories.\nIt manages the storage and retrieval of data on disk and ensures file system integrity. Many operating systems also provide permissions management, which controls access to files and directories based on user roles and ownership.\n4. Communication Between Processes Operating systems provide mechanisms for communication between processes, both local and remote. This communication can be achieved via:\nShared Memory: Multiple processes access and modify the same region of memory. Message Passing: Processes exchange data in pre-defined formats, typically over a network. 5. Error Detection The OS continuously monitors the system for errors, such as hardware malfunctions or application issues and take corrective action, such as terminating a malfunctioning process or halting the entire system if necessary.\nAnother set of operating system functions exists not for helping the user but rather for ensuring the efﬁcient operation of the system itself.\n6. Resource Allocation When multiple users or processes are running simultaneously, the OS allocates resources such as CPU time, memory, and I/O devices.\nFor example, the OS uses scheduling algorithms to manage CPU cycles and prioritize processes. It also manages the allocation and release of peripheral devices like printers or network interfaces.\n7. Accounting The OS keeps track of resource usage by users and processes.\nThis can be used for billing purposes in multi-user environments or for analyzing system performance to optimize resource allocation.\n8. Protection and Security Protection involves ensuring that processes cannot interfere with one another or the OS itself. This is achieved through memory protection, process isolation, and access control mechanisms. Security is about protecting the system from external unauthorized access, by requiring user authentication (e.g., passwords) and monitoring external device access, recording all such connections for detection of break-in. The OS defends against external threats like malware and intrusions. User Interface (UI) The user interface of an OS allows interaction between the user and the system.\nCommon types of user interfaces include:\n1. Command-Line Interface (CLI) Users interact with the OS by typing text-based commands. The CLI offers fine-grained control over system operations but requires users to have knowledge of specific commands. Example: Linux Shell, Windows Command Prompt. 2. Batch Interface In a batch interface, commands and scripts are written into files, which are then executed by the OS without real-time user interaction. Example: Batch processing scripts in mainframe systems. 3. Graphical User Interface (GUI) A GUI uses windows, icons, menus, and pointers (WIMP) to provide a more user-friendly interface. Users interact with the system using pointing devices like a mouse or touchpad. Example: Microsoft Windows, macOS, Linux Desktop environments like GNOME or KDE. 4. Hybrid Interfaces Some OS provide combinations of these interfaces, allowing users to switch between CLI and GUI depending on their needs. System Calls System calls provide a way for programs to request services from the operating system. These calls act as the interface between a user program and the OS kernel.\nCommon system calls include:\nProcess control: Creating, scheduling, or terminating processes. File management: Opening, reading, writing, or closing files. Device management: Interacting with I/O devices (e.g., printers, disk drives). Memory management: Allocating and deallocating memory for processes. ","date":"2025-01-12","id":164,"permalink":"/personal-site/docs/os/c02_system_structure/os-2.01-os-services/","summary":"\u003cp\u003eThe main three aspects of an OS are its \u003cstrong\u003eServices\u003c/strong\u003e, \u003cstrong\u003eInterfaces\u003c/strong\u003e, and \u003cstrong\u003eComponents\u003c/strong\u003e.\u003c/p\u003e\n\u003chr\u003e\n\u003ch4 id=\"os-components-and-their-interconnection\"\u003e\u003cstrong\u003eOS Components and Their Interconnection\u003c/strong\u003e\u003c/h4\u003e\n\u003cp\u003eThe OS is made up of several interconnected components that work together to provide the services required by both users and applications. These components include:\u003c/p\u003e","tags":[],"title":"OS 2.01 - OS Services"},{"content":"","date":"2025-01-12","id":165,"permalink":"/personal-site/docs/os/c02_system_structure/","summary":"","tags":[],"title":"Chapter 02 - System Structure"},{"content":"The process of making a system call is essential for interaction between software and hardware components.\nSystem calls provide the essential interface between user-level programs and the operating system by allowing applications to request services, such as file manipulation, process control, and communication with I/O devices, from the OS kernel.\nSystem Calls: An Overview System calls are the fundamental interface between applications and the operating system. They are typically implemented as routines in C or C++, although assembly language might be used for low-level operations requiring direct hardware access. The OS can execute thousands of system calls per second, as they are used to manage resources and provide services to running applications. Applications are designed based on an Application Programming Interface (API).\nThe API outlines the available system services, set of functions, their parameters, and the return values that a programmer can expect when interacting with the operating system.\nSome common APIs include:\nWindows API: Used for applications running on Windows systems. POSIX API: Used in UNIX-based systems, including Linux and macOS. Java API: Used by applications that run on the Java Virtual Machine (JVM). For Linux and UNIX, the libc library provides a collection of standard APIs, enabling applications to interact with system calls.\nSystem Call Execution and API Invocation In practice, when an application calls a function provided by the API, that function typically invokes an underlying system call on behalf of the programmer. For example:\nIn Windows, a call to CreateProcess() triggers the system call NTCreateProcess(). In UNIX-like systems, functions such as open() or read() are API functions that, behind the scenes, call lower-level system calls such as sys_open() or sys_read(). The API abstracts the complexity of interacting with the OS kernel directly, making system calls easier to work with and providing greater portability across systems that support the same API.\nProgram Portability The use of an API ensures that applications designed on one platform can be easily ported to others, as long as the target system supports the same API. For instance, a program designed using the POSIX API can be compiled and run on any system that implements the POSIX standard, including UNIX, Linux, or macOS. This portability is a significant advantage for developers, as they can write applications that run on multiple platforms without modification.\nSystem-Call Interface The system-call interface acts as the intermediary between the user program and the operating system kernel.\nWhen an application invokes an API function, the system-call interface intercepts that call and translates it into the appropriate system call. The OS kernel then executes the request and returns any relevant data or status information back to the application via the system-call interface. Passing Parameters to the Operating System There are three general methods for passing parameters from user applications to the operating system during a system call. The choice of method depends on the OS and the number of parameters involved.\nPassing Parameters in Registers:\nThe simplest and fastest method, where parameters are passed directly in CPU registers. Suitable for system calls that require a small number of parameters. Example: If a system call has only one or two arguments, passing them via registers is most efficient. Using a Block or Table in Memory:\nWhen there are more parameters than available registers, the parameters are stored in a memory block (or table). The address of the block is then passed in a register to the OS. This method allows for more flexibility and is used by operating systems like Linux and Solaris. Example: A system call that requires many parameters, such as a file operation with multiple options, can use this method. Passing Parameters via the Stack:\nIn this method, the application pushes parameters onto the stack before making the system call. The OS then pops the parameters from the stack when the call is invoked. This method does not limit the number of parameters, making it flexible for system calls with a variable or large number of parameters. Summary System calls are essential for interaction between applications and the operating system. They are the mechanism by which programs request services such as I/O operations, memory management, and process control from the OS.\nAPIs provide a high-level interface to these system calls, making them easier for application developers to use.\nThe system-call interface serves as the link between the application and the OS, handling the translation of API function calls into actual system calls.\nAPIs abstract the complexity of making system calls directly. System-call interfaces enable user applications to invoke OS services. The passing of parameters to system calls can be done via registers, memory blocks, or the stack, depending on the number of parameters and the OS. ","date":"2025-01-12","id":166,"permalink":"/personal-site/docs/os/c02_system_structure/os-2.03-system-calls/","summary":"\u003cp\u003eThe process of making a system call is essential for interaction between software and hardware components.\u003c/p\u003e\n\u003cp\u003eSystem calls provide the essential interface between user-level programs and the operating system by allowing applications to request services, such as \u003cstrong\u003efile manipulation, process control, and communication\u003c/strong\u003e with I/O devices, from the OS kernel.\u003c/p\u003e","tags":[],"title":"OS 2.03 - System Calls"},{"content":"System calls are typically grouped into six major categories, each providing different functions necessary for operating system tasks.\nThese categories include process control, file management, device management, information maintenance, communications, and protection.\nBy organizing system calls into categories, operating systems allow developers to interact with the underlying hardware and system services efficiently.\n2.4.1 Process Control Process control system calls are used to manage the execution of processes in the operating system. These calls allow programs to create, terminate, and control other processes.\nCommon process control system calls include:\nend() and abort(): Terminate a running program either normally or due to an error. load() and execute(): Load a program into memory and begin its execution. create process and terminate process: Used to create a new process and terminate an existing one. get process attributes and set process attributes: Retrieve or modify the attributes of a process (e.g., priority). wait for time: Makes the process wait for a specific time or until a certain condition is met. wait event, signal event: Synchronize process execution by waiting for or signaling events (e.g., semaphores). allocate and free memory: Manage dynamic memory allocation for processes. Examples of Process Control System Calls:\nFunction Windows UNIX Process Creation CreateProcess() fork() Process Termination ExitProcess() exit() Process Waiting WaitingForSingleObject() wait() In an interactive system, if a program terminates abnormally, the OS usually handles the termination and outputs an error message. In GUI systems, a pop-up may alert the user. In batch systems, the job may be terminated and the next job executed.\n2.4.2 File Management File management system calls allow processes to manage files and directories. These calls are essential for operations like creating, reading, writing, and closing files.\nKey file management system calls include:\ncreate() and delete(): Create and delete files with specific attributes. open(): Open a file for reading, writing, or both. read(): Read data from a file into memory. write(): Write data from memory to a file. reposition(): Move the file pointer to a different position in the file (e.g., skip to the beginning or end). close(): Close a file once operations are complete. Function Windows UNIX File Creation CreateFile() open() File Reading ReadFile() read() File Writing WriteFile() write() File Closing CloseHandle() close() 2.4.3 Device Management Device management system calls allow processes to interact with hardware devices like printers, disk drives, and network devices. These calls are used for requesting and releasing device access, reading/writing data, and managing device attributes.\nCommon device management system calls include:\nrequest device and release device: Request or release control of a device. read(), write(), reposition(): Perform I/O operations on devices. get device attributes, set device attributes: Retrieve or set attributes of a device (e.g., device status). logically attach or detach devices: Attach or detach devices from the system for use. Function Windows UNIX Console Mode Control SetConsolMode() ioctl() Reading from Console ReadConsole() read() Writing to Console WriteConsole() write() 2.4.4 Information Maintenance Information maintenance system calls provide information about the system, process, file, or device attributes. These calls are crucial for system monitoring and configuration.\nKey information maintenance system calls include:\nget time or date and set time or date: Retrieve or modify the system\u0026rsquo;s date and time. get system data, set system data: Retrieve or modify various system settings or configuration data. get process/file/device attributes: Retrieve information about processes, files, or devices. set process/file/device attributes: Modify attributes of processes, files, or devices. Function Windows UNIX Get Process ID GetCurrentProcessID() getpid() System Sleep Sleep() sleep() 2.4.5 Communication Communication system calls enable processes to communicate with each other, either on the same machine or over a network. These calls manage the creation of communication channels, sending and receiving messages, and transferring status information.\nCommon communication system calls include:\ncreate communication connection and delete communication connection: Establish or remove communication channels between processes. send(), receive(): Transmit and receive messages between processes. transfer status information: Send status updates between communicating processes. attach or detach remote devices: Connect or disconnect remote devices for communication. Function Windows UNIX Create Pipe CreatePipe() pipe() Shared Memory Management CreateFileMapping() shm_open() Memory Mapping MapViewOfFile() mmap() 2.4.6 Protection Protection system calls manage access to system resources to ensure that unauthorized users or processes cannot access or interfere with protected data. They include functions for setting permissions, ensuring security, and managing access control.\nCommon protection system calls include:\nset file security: Set permissions for files to control who can access them. initialize security descriptor: Set up a security descriptor for managing access control. set security descriptor group: Assign security groups to resources for access control. change file permissions: Modify file access rights for users. Function Windows UNIX Set File Permissions SetFileSecurity() chmod() Modify File Ownership SetSecurityDescriptorGroup() chown() ","date":"2025-01-12","id":167,"permalink":"/personal-site/docs/os/c02_system_structure/os-2.04-types-of-system-calls/","summary":"\u003cp\u003eSystem calls are typically grouped into six major categories, each providing different functions necessary for operating system tasks.\u003c/p\u003e\n\u003cp\u003eThese categories include \u003cstrong\u003eprocess control\u003c/strong\u003e, \u003cstrong\u003efile management\u003c/strong\u003e, \u003cstrong\u003edevice management\u003c/strong\u003e, \u003cstrong\u003einformation maintenance\u003c/strong\u003e, \u003cstrong\u003ecommunications\u003c/strong\u003e, and \u003cstrong\u003eprotection\u003c/strong\u003e.\u003c/p\u003e","tags":[],"title":"OS 2.04 - Types Of System Calls"},{"content":"System programs, also known as system utilities, are essential components of an operating system that provide a convenient environment for the development, execution, and management of programs.\nThey offer a layer of functionality above the operating system\u0026rsquo;s core services, simplifying tasks for developers and users alike. Each serving specific functions that enhance system usability and manageability.\nThe view of the operating system seen by most users is deﬁned by the application and system programs, rather than by the actual system calls.\nCategories of System Programs File Management Programs These programs are designed to perform various operations on files and directories. They help in organizing, managing, and manipulating files within the system. Common tasks include:\nCreating and deleting files and directories. Copying and renaming files. Printing files or dumping their content. Listing files and directories. Modifying file permissions. Examples: cp, mv, rm, ls, mkdir, rmdir.\nStatus Information Programs Some system programs provide users with vital information about system performance, status, and resources. These programs query the system and present output related to:\nCurrent date and time. Available memory or disk space. System uptime or number of active users. Detailed system performance metrics and logs. These programs may format and print the output to the terminal, to a file, or in a GUI window. Some operating systems also include a registry that stores configuration information, which can be queried for system settings and software configuration.\nExamples: top, free, df, uptime, ps.\nFile Modification Programs These programs allow users to edit or modify the content of files stored on storage devices. Text editors fall into this category and are commonly used for creating and altering file content. Other related utilities may assist with searching through file contents or performing transformations on the text.\nExamples: vi, nano, sed, awk.\nProgramming Language Support Programs Operating systems provide tools for developers to create and manage software applications. These include:\nCompilers: Convert high-level programming languages into machine code. Assemblers: Convert assembly language programs into machine code. Debuggers: Help developers find and fix errors in code. Interpreters: Execute programs written in interpreted languages (e.g., Python, JavaScript). Examples: gcc, gdb, make, java.\nProgram Loading and Execution Programs These programs facilitate the loading and execution of compiled or assembled programs. After a program is created, it must be loaded into memory to run, and specialized programs handle this task, such as:\nLoaders: Load programs into memory. Linkers: Combine object files and libraries into a single executable. Debugging systems: Help in analyzing and troubleshooting both high-level and machine-level code. Examples: ld, loader, run.\nCommunication Programs Communication programs provide the means for processes, users, and systems to interact. These programs enable the transmission of data across the network or between different systems and processes. They include services for:\nSending messages between users. Browsing web pages. Sending and receiving emails. Logging in remotely. Transferring files. Examples: ssh, ftp, sendmail, telnet, wget, curl.\nBackground Services These are system programs that run in the background, often starting automatically when the system boots. Some of these services continue to run as long as the system is operational, while others may terminate once their tasks are completed. Background services are commonly referred to as:\nDaemons (in UNIX-like systems). Services (in Windows). Subsystems. Key examples include:\nNetwork daemons: Handle incoming network connections (e.g., httpd for web servers, sshd for SSH). Process schedulers: Schedule and manage processes according to pre-defined times (e.g., cron). Error monitoring services: Track system errors and report issues (e.g., syslogd). Print servers: Manage print jobs on a network (e.g., cupsd). Examples: systemd, cron, syslogd, apache2, networkd.\nApplication Programs In addition to system programs, operating systems typically provide a range of application programs that assist users in performing specific tasks. These applications are often designed to solve common problems or streamline everyday operations. Popular examples include:\nWeb browsers: Browsing the internet (e.g., Firefox, Chrome). Text processors: Creating and editing documents (e.g., Microsoft Word, LibreOffice). Spreadsheet programs: Performing calculations and managing data (e.g., Excel, Google Sheets). Database systems: Storing and querying data (e.g., MySQL, PostgreSQL). Compilers: Compiling code (e.g., gcc, clang). Statistical analysis software: Performing data analysis (e.g., R, SPSS). These programs typically provide a graphical user interface (GUI) that enables users to interact with the operating system more intuitively, but they can also offer command-line interfaces for more advanced users.\nSummary The operating system\u0026rsquo;s system programs and application programs define the user experience, providing essential tools for interaction, system management, and program execution.\nSystem programs include utilities for file management, status information, programming support, communication, and background services. While system calls form the core functionality of the OS, these system programs provide an accessible interface for users and developers to interact with the underlying system resources.\nFor most users, their interaction with the operating system is through application and system programs, rather than directly through system calls. This abstraction simplifies the use of the system and allows users to perform tasks without needing to interact with the lower-level components of the operating system directly.\n","date":"2025-01-12","id":168,"permalink":"/personal-site/docs/os/c02_system_structure/os-2.05-system-programs/","summary":"\u003cp\u003e\u003cstrong\u003eSystem programs\u003c/strong\u003e, also known as \u003cstrong\u003esystem utilities\u003c/strong\u003e, are essential components of an operating system that provide a convenient environment for the development, execution, and management of programs.\u003c/p\u003e","tags":[],"title":"OS 2.05 - System Programs"},{"content":"Operating-system structure refers to the organization of an operating system\u0026rsquo;s components and how they interact with each other. Over the years, operating system structures have evolved from simple designs to more modular, complex ones, each with trade-offs regarding performance, maintainability, and flexibility.\nThe design structure is often influenced by the target platform, goals of the OS (e.g., performance, security, extensibility), and the hardware it is designed to run on.\n2.7.1 Simple Structure In the early days of computing, many operating systems were designed with a simple and monolithic structure. These systems often lacked well-defined separation between system components, which led to limited functionality and poor security.\nExample: MS-DOS MS-DOS (Microsoft Disk Operating System) is an example of an operating system with a simple structure. MS-DOS had minimal separation between user programs and the operating system kernel. As a result, applications could directly access hardware resources, which was both a strength and a weakness:\nStrength: This provided fast access to hardware for programs. Weakness: There were few protections against user programs causing system crashes or corrupting the system, as there was little distinction between user space and kernel space. MS-DOS Layer Structure:\nThe system was a single layer, with no distinct separation between user-level processes and the kernel. Applications had direct access to I/O operations and hardware resources, making it easier to develop but prone to errors and system crashes when user programs failed. 2.7.2 Layered Approach To address the limitations of simple structures, the layered approach was introduced. In this design, the operating system is divided into layers or modules, each of which has a specific responsibility. This results in a more organized structure, improving maintainability and stability.\nBenefits:\nModularity: Layers can be developed and tested independently. Better Control: With appropriate hardware support, the OS can better control applications and system resources. Flexibility: The system is easier to maintain, and changes in one layer typically don\u0026rsquo;t affect others. Example: In a layered operating system:\nThe lowest layer might interact directly with hardware. Higher layers provide services like file management, user interface, and network communication. This approach, however, may have a slight performance overhead due to additional abstraction layers between hardware and user applications.\n2.7.3 Microkernels The microkernel architecture is a design where the operating system kernel is reduced to its minimal functionality. The kernel only handles essential services such as memory management, process scheduling, and communication between processes. Other services, like device drivers, file systems, and networking, are implemented in user space.\nBenefits:\nModularity: Non-essential services run as user-space processes, making it easier to update or replace them without modifying the core kernel. Stability and Security: If a user-space process crashes, it does not affect the kernel, which ensures better stability. Isolation: It provides a stronger isolation between services, leading to fewer security risks. Challenges:\nPerformance: The overhead of inter-process communication (IPC) between the kernel and user-space services can reduce system performance compared to monolithic kernels. Example: The Mach microkernel used in macOS and other systems is a popular implementation of the microkernel architecture. Mach provides essential services like memory management, thread scheduling, and IPC, while other system services (such as device drivers and file systems) run outside the kernel in user space.\n2.7.4 Modules The modular kernel design has become a popular approach, combining the advantages of microkernels and monolithic kernels. In this approach, the kernel consists of a small core with the ability to load additional modules or services dynamically during runtime.\nBenefits:\nFlexibility: New functionality can be added without recompiling the entire kernel. For example, you can load new drivers or features as modules when needed. Performance: Core kernel functions remain in a monolithic structure, which offers better performance compared to a microkernel, but additional services can be loaded dynamically to maintain modularity. Examples:\nLinux: The Linux kernel uses a modular approach where additional features, such as device drivers or filesystems, are implemented as loadable kernel modules. Windows: Windows also supports loadable kernel modules to extend its functionality without modifying the core kernel. 2.7.5 Hybrid System Hybrid systems combine features from different operating-system structures to balance performance, flexibility, and security. They might incorporate the efficiency of monolithic kernels with the modularity of microkernels, allowing for a more tailored solution depending on the operating system\u0026rsquo;s needs.\nBenefits:\nPerformance: The monolithic parts of the kernel provide high performance. Modularity and Extensibility: The modular aspects allow for dynamic extensions and flexibility. Examples of hybrid systems include:\nLinux: It is generally a monolithic kernel, but it supports loadable modules, making it hybrid in nature. Windows: Windows is primarily monolithic but also includes elements of microkernel-like subsystems that run in user mode, such as the Windows Subsystem for Linux (WSL). Structure of three hybrid systems: the Apple Mac OS X operating system and the two most prominent mobile operating systems—iOS and Android.\n2.7.5.1 Mac OS X Mac OS X uses a hybrid operating system structure, combining elements of the Mach microkernel and BSD UNIX kernel. The architecture includes several layers:\nUser Interface Layer: The Aqua graphical user interface (GUI) sits on top and includes the Cocoa environment for Objective-C programming. Kernel Layer: Mach: Handles memory management, thread scheduling, and communication between processes. BSD: Provides networking, file system, and POSIX APIs. Device Drivers: Managed by an I/O kit for device driver development. Dynamic Modules: The system supports dynamically loadable kernel extensions (e.g., device drivers). Mac OS X is an example of a hybrid system where the Mach microkernel and BSD components work together to offer a robust and flexible system. The combination allows for powerful, efficient kernel functionality while providing a user-friendly interface and modularity for extensibility.\n2.16 Structure of Mac OS X\r2.7.5.2 iOS iOS, like macOS, is based on a hybrid kernel architecture, leveraging the Darwin kernel (a derivative of BSD and Mach). However, it is specifically optimized for mobile devices:\niOS uses a monolithic kernel for better performance on limited mobile resources, while providing support for user-space components such as application services and device drivers. The kernel includes Mach for process management and memory, while BSD provides file system and network services. 2.7.5.3 Android Android is based on a hybrid operating system model that uses the Linux kernel as its core. Android combines elements of monolithic and modular design:\nThe Linux kernel provides basic services such as hardware abstraction, memory management, and process scheduling. Android adds higher-level services and APIs on top of the kernel, such as the Dalvik Virtual Machine (DVM) (now replaced by ART, Android Runtime) for running applications, and application frameworks that provide functionality like activity management, telephony services, and graphics. Android\u0026rsquo;s architecture uses a monolithic kernel for core services but builds a modular user-space layer for device management, apps, and communication with external hardware.\n2.18 Android Architecture\rConclusion The structure of operating systems has evolved significantly over the years, from simple, monolithic systems like MS-DOS to sophisticated hybrid structures that combine elements of microkernels, monolithic kernels, and modular components.\nThe design choices depend on the operating system\u0026rsquo;s target use cases, with trade-offs between performance, security, flexibility, and ease of maintenance.\nModern systems such as Linux, macOS, iOS, and Android combine different structural models to optimize performance and functionality, creating hybrid systems that balance efficiency and modularity.\n","date":"2025-01-12","id":169,"permalink":"/personal-site/docs/os/c02_system_structure/os-2.07-os-structure/","summary":"\u003cp\u003eOperating-system structure refers to the organization of an operating system\u0026rsquo;s components and how they interact with each other. Over the years, operating system structures have evolved from simple designs to more modular, complex ones, each with trade-offs regarding performance, maintainability, and flexibility.\u003c/p\u003e","tags":[],"title":"OS 2.07 - OS Structure"},{"content":"Booting a computer system refers to the process of starting it up by loading the kernel into memory and initiating its execution. This procedure is vital for initializing the operating system and setting up the system for user operations.\nThe process begins with a small piece of code called the bootstrap program or bootstrap loader. This program is responsible for finding and loading the operating system kernel into the main memory and starting its execution.\nSome computer systems, such as PCs, use a two-step process in which a simple bootstrap loader fetches a more complex boot program from disk, which in turn loads the kernel.\nSteps in the Boot Process Reset Event:\nWhen a computer is powered on or rebooted, the CPU receives a reset signal. The Instruction Register (IR) is loaded with a predefined memory location, and execution begins from that location. Initial Bootstrap Program:\nThe initial bootstrap program is stored in read-only memory (ROM) because at this stage, RAM is in an unknown state. ROM is used because it doesn\u0026rsquo;t need initialization and is not easily infected by viruses. The bootstrap program is typically stored in a small, non-volatile storage like ROM or firmware. Diagnostics and Initialization:\nThe bootstrap program usually runs system diagnostics to check the machine’s hardware and ensure that all components are functioning properly. If diagnostics pass, the program continues to initialize the system, including the CPU registers, device controllers, and memory contents. Eventually, the program begins loading the operating system (OS). Firmware and Read-Only Memory (ROM):\nAll forms of ROM are also known as ﬁrmware, since their characteristics fall somewhere between those of hardware and those of software.\nSome systems, especially simpler ones (like cell phones, tablets, or game consoles), may store the entire operating system in ROM. This is often done for simplicity and ruggedness.\nHowever, firmware (a combination of hardware and software) comes with limitations:\nSpeed: Executing code in ROM is slower than executing code in RAM. Flexibility: Changing the firmware requires replacing the ROM hardware, which can be costly. To address this, EPROM (Erasable Programmable Read-Only Memory) is used, allowing the code to be rewritten. While firmware is durable, it typically provides only small amounts of storage and slower execution compared to RAM.\nBootloader on Disk for Larger OS:\nFor larger or more dynamic operating systems (like Windows, macOS, or UNIX), the bootstrap loader is stored in firmware, but the operating system itself resides on a disk. The bootstrap program stored in the firmware runs diagnostics and reads a small boot block (often from the first block on disk). This boot block contains enough code to load the remaining bootstrap program into memory. The boot block itself is typically small and only contains instructions to load the remainder of the bootstrap program from a specific address on the disk.\nLoading the Operating System:\nOnce the bootstrap program has been loaded into memory, it traverses the file system on disk to find and load the kernel of the operating system. After locating the kernel, it is loaded into memory and execution starts, and the system begins to run the operating system. GRUB (Grand Unified Bootloader):\nOne of the most widely used bootstrap programs for Linux systems is GRUB, which helps manage the boot process and allows users to choose between different operating systems or kernel versions at startup.\nBoot Disk:\nThe disk that contains the boot partition and the operating system is often referred to as the boot disk or system disk.\nThis disk is critical for loading the operating system during the boot process.\nKey Concepts: Bootstrap Loader: A small program responsible for loading the operating system kernel into memory. ROM (Read-Only Memory): Non-volatile memory used for storing the initial bootstrap program. It is essential for starting the system because it doesn\u0026rsquo;t require initialization like RAM. Firmware: Code stored in ROM or EPROM that can control hardware and run basic system functions. Boot Block: A small, fixed location on the disk that contains the first part of the bootstrap program. Boot Disk/System Disk: The disk that holds the operating system and contains the boot partition necessary for system startup. GRUB (Grand Unified Bootloader): A popular bootloader used in Linux systems for loading and managing multiple operating systems. ","date":"2025-01-12","id":170,"permalink":"/personal-site/docs/os/c02_system_structure/os-2.10-system-boot/","summary":"\u003cp\u003eBooting a computer system refers to the process of starting it up by loading the kernel into memory and initiating its execution. This procedure is vital for initializing the operating system and setting up the system for user operations.\u003c/p\u003e","tags":[],"title":"OS 2.10 - System Boot"},{"content":"Contemporary computer systems allow multiple programs to be loaded into memory and executed concurrently. This requires tighter control and better compartmentalization of various programs. These needs led to the concept of a process, which is a program in execution.\nA process is a unit of work in a modern time-sharing system. In a batch system, jobs are executed. In a time-sharing system, there are user programs or tasks, which might involve running multiple programs for a single user. The operating system (OS) must also support its internal activities. All of these activities are referred to as processes.\nThe terms job and process can often be used interchangeably.\n3.1.1 The Process A process consists of more than just the program code (referred to as the text section). It also includes several other components:\nProgram Counter: Represents the current activity. Processor Registers: Contain the contents representing the state of the processor. Process Stack: Stores temporary data such as: Function parameters Return addresses Local variables Data Section: Contains global variables. Additionally, a process may have a heap, which is dynamically allocated memory during runtime.\nStructure of a Process in Memory: 3.01 A Process in Memory\rProgram vs. Process A program is not a process; it is a passive entity. It can be a file containing a list of instructions (e.g., an executable file) along with associated resources.\nA program becomes a process when it is loaded into memory.\nAlthough multiple processes may be associated with the same program, each process is considered a separate execution sequence. For example:\nSeveral users running different copies of the same program, or A single user using multiple instances of a program like a web browser. Each of these is a separate process, although their text sections (program code) are identical. The data, heap, and stack sections will differ.\nExecutable Environment for Code A process can act as an executable environment for other code. For example, in the Java programming environment, Java code is executed within the Java Virtual Machine (JVM). The JVM itself is a process that: Interprets the loaded Java code. Executes actions on behalf of the Java code via native machine instructions. 3.1.2 Process State As a process executes, it transitions through various states based on its current activity. The process can be in one of the following states:\nNew: The process is being created. Running: Instructions are being executed. Waiting: The process is waiting for some event to occur (e.g., I/O completion, reception of a signal). Ready: The process is waiting to be assigned to a processor. Terminated: The process has finished execution. Note:\nOnly one process can be running on a processor at any given moment. Many processes may be ready or waiting at the same time. 3.02 States Of Process\r3.1.3 Process Control Block (PCB) Each process in an operating system is represented by a Process Control Block (PCB), also known as a Task Control Block. The PCB contains various pieces of information associated with a specific process:\nProcess State: The current state of the process (e.g., Running, Waiting, Ready). Program Counter: Indicates the address of the next instruction to be executed for the process. CPU Registers: Varies in number and type depending on the architecture (e.g., accumulators, index registers, stack pointers, general-purpose registers). CPU Scheduling Information: Includes process priority, pointers to scheduling queues, and any other scheduling parameters. Memory Management Information: Includes values of base and limit registers, page tables, or segment tables, depending on the memory system. Accounting Information: Contains CPU and real time usage, time limits, account numbers, job or process numbers, and other metrics. I/O Status Information: Lists all I/O devices allocated to the process, open files, and other I/O-related data. 3.03 Process Control Block\rWhen an interrupt occurs, the program counter and state information must be saved to ensure the process can continue correctly afterward.\n3.04 Process Switching\r3.1.4 Threads Modern operating systems have extended the concept of a process to allow multiple threads of execution. This enables the process to perform more than one task simultaneously, which is especially beneficial in multi-core systems where multiple threads can run in parallel.\nThreads are smaller units of execution within a process, and they share the same resources like memory and I/O devices, but execute independently. PCB and Threads On systems that support threads, the Process Control Block (PCB) is expanded to include information for each thread. This allows the OS to manage and schedule threads within a single process efficiently.\nLinux OS and the Task Structure In Linux, the Process Control Block is represented by the C structure task_struct, which is found in the \u0026lt;linux/sched.h\u0026gt; header file within the kernel source code.\nThis structure contains all necessary information about a process, including:\nProcess state Scheduling and memory management information List of open files Pointers to the process\u0026rsquo;s parent, children, and siblings ","date":"2025-01-12","id":171,"permalink":"/personal-site/docs/os/c03_process_concept/os-3.01-process-concept/","summary":"\u003cp\u003eContemporary computer systems allow multiple programs to be loaded into memory and executed concurrently. This requires tighter control and better compartmentalization of various programs. These needs led to the concept of a \u003cstrong\u003eprocess\u003c/strong\u003e, which is a program in execution.\u003c/p\u003e","tags":[],"title":"OS 3.01 - Process Concept"},{"content":"","date":"2025-01-12","id":172,"permalink":"/personal-site/docs/os/c03_process_concept/","summary":"","tags":[],"title":"Chapter 03 - Process Concept"},{"content":"The objective of multiprogramming is to ensure that some process is always running, maximizing CPU utilization.\nThe goal of time-sharing systems is to switch the CPU between processes frequently enough that the user can interact with each program while it is running.\nTo achieve these objectives, the Process Scheduler selects an available process from a set of processes waiting for execution on the CPU. When there are more processes than available CPU time, some processes must wait until the processor is free to be rescheduled.\n3.2.1 Scheduling Queues When a process enters the system, it is placed in the job queue, which consists of all the processes in the system.\nReady Queue:\nThe processes residing in main memory, ready to execute, are placed in the ready queue, which is generally implemented as a linked list.\nThe ready queue header contains pointers to the first and last PCBs (Process Control Blocks). Each PCB contains a pointer to the next PCB in the queue. Device Queue:\nIf a process requests I/O (e.g., disk access) and the device is busy, the process is placed in the device queue for that specific I/O device. Each device has its own queue.\n3.06 Queueing Diagram Representing Process Scheduling\rProcess Lifecycle in Queues: New Process:\nA process is initially placed in the ready queue. It waits there until it is selected for execution, or dispatched. During Execution:\nThe process may: Issue an I/O request and move to the I/O queue. Create a child process and wait for the child’s termination. Be removed forcibly from the CPU due to an interrupt and moved back to the ready queue. Cycle Continuation:\nThe process moves from the waiting state to the ready state when I/O or other events complete and is placed back into the ready queue. This cycle continues until the process is terminated, at which point it is removed from all queues, and its PCB and resources are deallocated. 3.2.2 Schedulers A process moves between various scheduling queues throughout its lifetime, and the Operating System (OS) must select processes from these queues for execution.\nTypes of Schedulers: Long-Term Scheduler (Job Scheduler):\nSelects processes from a pool and loads them into memory for execution. Controls the degree of multiprogramming (the number of processes in memory). Short-Term Scheduler (CPU Scheduler):\nSelects from the ready queue and allocates CPU time to one of the processes. Frequency of execution: It is very fast as it must select a new process frequently due to the short time between executions. Types of Processes: I/O Bound Processes: Spend more time performing I/O operations than computations.\nCPU Bound Processes: Perform infrequent I/O operations and spend more time on computations.\nFor better system performance, a combination of I/O-bound and CPU-bound processes should be selected (Process Mix).\nDifferences Between Long-Term and Short-Term Schedulers: Short-Term Scheduler:\nHandles CPU-bound processes and performs scheduling frequently to ensure minimal wastage of CPU time. Long-Term Scheduler:\nManages the mix of CPU-bound and I/O-bound processes. A balance between these types ensures that the ready queue does not empty (if too many I/O-bound processes) and CPU scheduler will have nothing to do or the I/O waiting queues remain empty (if too many CPU-bound processes) causing the I/O devices to go unused. Medium-Term Scheduler: In time-sharing systems (like UNIX and Windows), there may be an additional medium-term scheduler.\nPurpose of Medium-Term Scheduling: It is sometimes advantageous to remove processes from memory to reduce the level of multiprogramming. The process can later be reintroduced into memory and resume from where it left off. This is called swapping. Swapping helps manage system load and memory usage, particularly when memory requirements exceed available resources.\n3.07 Medium Term Scheduling in Queueing Diagram\r3.2.3 Context Switch A context switch occurs when an interrupt happens, and the system must save the current process\u0026rsquo;s state and load the state of another process to resume its execution.\nProcess of a Context Switch: Context Saving:\nThe OS saves the current process\u0026rsquo;s context (e.g., CPU registers, process state, and memory management information) in its Process Control Block (PCB). Context Restore:\nThe OS loads the saved context of the next process to execute, restoring its state (e.g., CPU registers, program counter). Overhead: A context switch takes time and doesn\u0026rsquo;t perform useful work while switching, so adding overhead to the system.\nSpeed Variation: The time taken for a context switch can vary based on system factors, like memory speed and the number of registers involved.\nSwapping vs. Context Switching Swapping :\nSwapping is about managing memory by moving processes between RAM and disk. It\u0026rsquo;s done when the system runs out of memory or needs to adjust the number of processes in memory. The primary purpose of swapping is to manage memory and multiprogramming. It involves temporarily removing a process from main memory to free up space, and then later restoring it when needed. This is typically done when the system is overloaded or when the available memory is insufficient to handle all the running processes. Context Switching :\nContext Switching is about switching the CPU’s focus between processes. It occurs frequently as the CPU moves between tasks, saving and restoring the state of processes. The purpose of context switching is to switch between processes during execution, so that the CPU can allocate time to multiple processes in a time-sharing environment. It is a fundamental operation in multitasking systems, enabling the CPU to switch between processes without having to halt the system completely. Impact on the System Swapping:\nSwapping is a high-cost operation in terms of time and resources because it involves transferring a process between main memory and disk. It is relatively slower than context switching due to the slower speed of disk compared to RAM. Involves main memory and disk. A process is moved from RAM to disk and back to RAM when it needs to resume execution. Context Switching:\nContext switching is much faster than swapping, but still incurs overhead because the system has to save and load the process state (e.g., CPU registers, program counter, etc.) between switches. The overhead is minimal but significant when switching frequently. Involves CPU state (registers, program counter, etc.) but does not involve moving a process between memory and disk. The process remains in memory throughout the switch. ","date":"2025-01-12","id":173,"permalink":"/personal-site/docs/os/c03_process_concept/os-3.02-process-scheduling/","summary":"\u003cp\u003eThe objective of \u003cstrong\u003emultiprogramming\u003c/strong\u003e is to ensure that some process is always running, maximizing \u003cstrong\u003eCPU utilization\u003c/strong\u003e.\u003c/p\u003e\n\u003cp\u003eThe goal of \u003cstrong\u003etime-sharing\u003c/strong\u003e systems is to switch the CPU between processes frequently enough that the user can interact with each program while it is running.\u003c/p\u003e","tags":[],"title":"OS 3.02 - Process Scheduling"},{"content":"Processes executing concurrently in an operating system can be either independent or cooperating.\nIndependent Process:\nA process that cannot affect or be affected by other processes. These processes do not share data with others.\nCooperating Process:\nA process that can be affected by or affect other processes. These processes share data and require communication to synchronize and exchange information.\nReasons for Process Cooperation: Information Sharing:\nMultiple processes may need access to the same data (e.g., a shared file).\nComputation Speedup:\nLarge tasks can be broken into smaller sub-tasks to run in parallel, speeding up execution.\nModularity:\nA system can be constructed modularly by dividing functionality into separate processes or threads.\nConvenience:\nAllows multiple tasks to run concurrently, improving system efficiency.\nCooperating processes require an Inter-Process Communication (IPC) mechanism to exchange data and synchronize their operations. The two primary IPC models are Shared Memory and Message Passing.\n3.12 Communication Models\r3.4.1 Shared-Memory Systems In shared-memory systems, cooperating processes communicate by sharing a region of memory. This allows processes to exchange information by reading and writing data to the shared memory region.\nHow Shared Memory Works: A process creates a shared memory segment in its address space. Other processes that wish to communicate using this memory must attach the shared memory to their address space. These processes can then exchange data by reading and writing in the shared region. The OS does not control the data format or the memory location; this responsibility lies with the processes. Synchronization: Processes must ensure that they do not write to the same memory location simultaneously. One common problem in cooperative processes is the Producer-Consumer problem.\nProducer Process: Produces data. Consumer Process: Consumes data produced by the producer. To allow both processes to run concurrently, they need a shared buffer a region of memory where the producer can place data, and the consumer can retrieve it.\nThere are two types of buffers used:\nUnbounded Buffer:\nNo limit on the buffer size. The producer can continue producing items even if the consumer is slower in consuming. The consumer may need to wait for new items, but the producer is not blocked.\nBounded Buffer:\nThe buffer has a fixed size. The producer must wait if the buffer is full, and the consumer must wait if the buffer is empty.\nThe shared buffer is often implemented as a circular array with two logical pointers:\nIn Pointer: Points to the next available position in the buffer. Out Pointer: Points to the next item to be consumed. Synchronization Mechanism: To ensure the producer and consumer operate efficiently, synchronization mechanisms such as mutexes or semaphores are often used to avoid race conditions and ensure mutual exclusion.\n3.4.2 Message Passing Systems Message passing allows processes to communicate and synchronize without sharing the same address space, making it especially useful in distributed systems where processes may reside on different computers connected by a network.\nMessage Passing Operations Message passing typically provides at least two operations:\nsend(message): Send a message to another process. receive(message): Receive a message from another process. Messages can be fixed or variable in size:\nFixed-sized messages: Easier system implementation, but harder to program. Variable-sized messages: More complex system-level implementation, but simpler for the programmer. Message Passing Implementation Models Message passing systems can be implemented using different methods, including:\nDirect or Indirect Communication Synchronous or Asynchronous Communication Automatic or Explicit Buffering 3.4.2.1 Naming Processes communicating via message passing must refer to each other. This can be done via direct or indirect communication.\nDirect Communication Each process explicitly names the sender or receiver. send(P, message): Send a message to process P. receive(Q, message): Receive a message from process Q. Properties of direct communication:\nA communication link is automatically established between every pair of processes that wish to communicate. Each pair of processes has exactly one link. Symmetric addressing: Both processes must name each other. A variant is asymmetric addressing, where only the sender names the recipient; the recipient is not required to name the sender. :\nsend(P, message): Send a message to process P. receive(id, message): Receive a message from any process, with id set to the name of the sender. The disadvantage of both symmetric and asymmetric communication schemes is the limited modularity of the resulting process definitions.\nThese schemes rely on hard-coding techniques, where identifiers must be explicitly stated, which reduces flexibility and makes the system less modular. Such hard-coding is generally less desirable than using techniques that involve indirection, where the identities of communicating processes are more dynamically determined.\nIndirect Communication With indirect communication, processes communicate via mailboxes (or ports), which are abstract objects where messages are placed and retrieved.\nsend(A, message): Send a message to mailbox A. receive(A, message): Receive a message from mailbox A. Properties of indirect communication:\nCommunication only happens between processes with a shared mailbox. A link can involve more than two processes, as multiple processes can communicate through a single mailbox. There are two types of mailbox ownership:\nProcess-owned mailbox: A process can only receive messages through its mailbox, and it disappears when the process terminates. OS-owned mailbox: A mailbox exists independently of any process, and the OS manages its creation, deletion, and message passing. 3.4.2.2 Synchronization Synchronization determines how send and receive operations block or proceed.\nBlocking Send: The sender is blocked until the message is received or placed in the mailbox. Non-blocking Send: The sender sends the message and continues execution without waiting. Blocking Receive: The receiver is blocked until a message is available. Non-blocking Receive: The receiver retrieves either a valid message or a null. For example, in a Producer-Consumer problem:\nThe producer sends a message using a blocking send and waits until the message is received. The consumer receives a message via a blocking receive, waiting until a message is available. 3.4.2.3 Buffering Messages exchanged between processes are held in temporary queues. These queues can be implemented in three ways:\nZero-capacity Queue:\nNo messages can be stored. The sender is blocked until the receiver retrieves the message. This type of queue is sometimes referred to as a message system with no buffering.\nBounded-capacity Queue: The queue has a finite size. The sender is blocked if the queue is full. The queue has a finite size (e.g., at most n messages can reside in it). If the queue is not full when a new message is sent, the message is placed in the queue (either the message is copied or a pointer to the message is kept), and the sender can continue execution without waiting. If the queue is full, the sender is blocked until space becomes available.\nUnbounded-capacity Queue:\nThe queue can hold an unlimited number of messages. The sender never blocks, regardless of the queue’s size.\nSystems with bounded or unbounded queues are referred to as automatic buffering systems, while a zero-capacity queue system is referred to as having no buffering.\nSummary for IPC Direct vs Indirect Communication:\nDirect communication requires processes to explicitly name each other, whereas indirect communication uses mailboxes that can hold messages from multiple processes.\nSynchronous vs Asynchronous:\nSynchronous (blocking) communication blocks the sender or receiver until the operation completes, while asynchronous (non-blocking) communication allows the sender or receiver to continue without waiting.\nBuffering Types:\nMessage queues can be zero-capacity (no buffering), bounded-capacity (limited storage), or unbounded-capacity (unlimited storage), each with different performance trade-offs.\nMessage passing is particularly advantageous in distributed systems and when small data exchanges between processes are needed. It is generally slower than shared memory communication because it requires kernel intervention, but it provides easier implementation and avoids synchronization issues.\nSummary of Process Chapter *Process Concept: A process is a program in execution and changes state during its lifetime. The states include: New: The process is being created. Ready: The process is ready to execute, waiting for the CPU. Running: The process is currently executing. Waiting: The process is waiting for an event (like I/O completion). Terminated: The process has finished execution. Process Control Block (PCB):\nEach process is represented by its own Process Control Block (PCB) in the OS. A process that is not executing is placed in a waiting queue, which can be either an I/O request queue or a ready queue. The ready queue holds processes that are ready to execute and waiting for the CPU. Scheduling:\nLong-term (Job) Scheduling: Selects processes to contend for the CPU, influenced by resource allocation, especially memory management. Short-term (CPU) Scheduling: Selects one process from the ready queue to execute. Parent-Child Process Relationships:\nParent processes can create child processes. The parent can either wait for the child to terminate before proceeding or allow them to execute concurrently. Reasons for concurrent execution include: Information sharing Computation speedup Modularity Convenience Types of Processes:\nIndependent Processes: These processes do not affect or share data with other processes. Cooperating Processes: These processes interact with each other and require an Interprocess Communication (IPC) mechanism. Interprocess Communication (IPC):\nShared Memory: Processes communicate by reading/writing to shared memory regions. The OS provides the memory, but application programmers manage the communication. Message Passing: Processes exchange messages. The OS typically provides the communication mechanism. Both schemes (shared memory and message passing) can be used simultaneously in an OS.\nCommunication Methods in Client-Server Systems:\nSockets: An endpoint for communication, forming a connection between applications. Remote Procedure Calls (RPCs): A process calls a procedure on a remote application. Pipes: Provide simple communication between processes. Ordinary pipes: Used between parent and child processes. Named pipes: Allow communication between unrelated processes. Summary for Threads Definition:\nA thread is a single sequence of instructions within a process. Each thread within a process shares the same memory space, but they can execute independently. A multithreaded process contains multiple threads running concurrently within the same process. This allows for parallelism, enabling efficient use of CPU resources. Benefits of Multithreading:\nIncreased Responsiveness: When an application uses multiple threads, one thread can handle user inputs (such as clicking or typing) while other threads perform background tasks. This results in a smoother user experience, as the program does not freeze while executing other tasks. Resource Sharing: Threads within the same process share the same memory space, which means they can directly access shared data (variables, structures) without the need for complex inter-process communication (IPC). This resource sharing simplifies data management and improves efficiency. Economy: Threads are lighter-weight compared to processes. Creating and managing threads generally involves less overhead than managing processes because threads share the same address space and resources within a process. This makes context switching faster compared to processes. Scalability: Multithreaded programs can be optimized to use multiple CPU cores. On multi-core systems, threads can run concurrently on different cores, significantly improving performance for CPU-bound tasks and enabling the application to scale effectively. Types of Threads:\nUser-Level Threads: These threads are created and managed by the user-level thread library (e.g., POSIX Pthreads), not by the operating system. The kernel is unaware of their existence, meaning it cannot schedule or manage them directly. Since no kernel intervention is needed, user-level threads are faster to create, destroy, and manage. However, if a user-level thread is blocked (for example, waiting for I/O), the entire process can be blocked because the kernel doesn\u0026rsquo;t recognize the other threads in the process. Kernel-Level Threads: These threads are created and managed by the operating system kernel. The kernel schedules these threads and is aware of their existence. If one kernel thread is blocked, the operating system can schedule another thread from the same process. Kernel-level threads are slower to create and manage compared to user-level threads due to kernel intervention, but they provide better concurrency and responsiveness because the kernel manages the threads. Thread Models:\nMany-to-One Model: In this model, multiple user-level threads are mapped to a single kernel thread. This model allows multiple threads within a process to run concurrently from the user’s perspective, but the operating system can only schedule one kernel thread at a time. If one user thread blocks, the entire process may be blocked. This model is less efficient for multitasking because it does not utilize multiple CPUs effectively. One-to-One Model: In this model, each user-level thread corresponds to a kernel thread. This allows each thread to be scheduled independently by the operating system. If a thread is blocked, others in the same process can still run. The one-to-one model can take full advantage of multi-core systems, making it more scalable, but it requires more resources because each thread needs its own kernel thread. Many-to-Many Model: This model multiplexes many user threads onto a smaller or equal number of kernel threads. This allows a process to use multiple kernel threads while still managing many user threads. This model provides a good balance between user-level and kernel-level management, allowing efficient use of resources while preventing some of the limitations of the many-to-one model. Operating System Support for Threads:\nModern operating systems, such as Windows, Mac OS X, Linux, and Solaris, provide support for kernel-level threading. They provide mechanisms to create, manage, and schedule threads. In these systems, the kernel is responsible for managing thread execution, synchronization, and scheduling, which allows for efficient multitasking and resource management. Thread Libraries:\nThread libraries offer an Application Programming Interface (API) that helps developers create and manage threads. Three primary thread libraries include: POSIX Pthreads: A popular threading library for Unix-like operating systems. It provides a set of functions for creating and managing threads. Windows threads: The threading API provided by Microsoft Windows. It allows developers to create, manage, and synchronize threads on Windows-based systems. Java threads: The Java programming language has built-in support for multithreading. It provides the Thread class and Runnable interface to create and manage threads in Java applications. Implicit Threading:\nIn implicit threading, the creation and management of threads are handled by compilers and runtime libraries, rather than the application programmer. This allows developers to focus on writing code without worrying about the details of thread management. Thread Pools: A collection of pre-created threads that can be reused to execute tasks. Thread pools manage the lifecycle of threads automatically, reducing the overhead of creating and destroying threads. OpenMP: A set of compiler directives that allow developers to parallelize their code using threads without explicitly creating them. OpenMP is widely used in scientific computing. Grand Central Dispatch (GCD): A threading API used by Apple in Mac OS X and iOS to manage concurrency. GCD handles the creation, scheduling, and execution of threads automatically, allowing developers to write parallel programs with ease. Challenges in Multithreading:\nMultithreaded programs introduce several challenges for developers, including: Semantics of fork() and exec() system calls: The behavior of these system calls can change in a multithreaded environment. For example, fork() creates a new process, but it only copies the calling thread in some systems, not all threads, which can lead to unexpected behavior. Signal Handling: In a multithreaded program, signals can be delivered to any thread, making signal handling more complex. This can cause issues in terms of which thread should handle specific signals (e.g., termination signals). Thread Cancellation: Threads may need to be canceled in response to certain conditions. Proper cancellation handling is required to prevent resource leaks or inconsistent states. Thread-local Storage (TLS): TLS allows each thread to have its own private data. Managing TLS can be tricky when using multiple threads that need access to specific data. Scheduler Activations: In some systems, threads are scheduled by the kernel, but the user-level thread library must also be activated to schedule threads. This complex interaction between kernel scheduling and user-level management requires careful design. ","date":"2025-01-12","id":174,"permalink":"/personal-site/docs/os/c03_process_concept/os-3.04-inter-process-communication/","summary":"\u003cp\u003eProcesses executing concurrently in an operating system can be either \u003cstrong\u003eindependent\u003c/strong\u003e or \u003cstrong\u003ecooperating\u003c/strong\u003e.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003eIndependent Process:\u003c/strong\u003e\u003cbr\u003e\nA process that cannot affect or be affected by other processes. These processes do not share data with others.\u003c/p\u003e","tags":[],"title":"OS 3.04 - Inter-Process Communication"},{"content":"","date":"2025-01-12","id":175,"permalink":"/personal-site/docs/os/c05_process_scheduling/","summary":"","tags":[],"title":"Chapter 05 - Process Scheduling"},{"content":"In multiprogrammed OS, the aim of CPU scheduling is to maximize CPU utilization by switching between processes and have some process running all the time.\nThe operating system allocates the CPU to processes, allowing for multiple processes to be in memory. When one process has to wait, the operating system takes the CPU away from that process and gives the CPU to another process. thus improving efficiency.\nAlmost all computer resources are scheduled before use.\n5.1.1 CPU-I/O Burst Cycle CPU-I/O Cycle: Process execution alternates between CPU bursts and I/O waits till the program terminates. This alternating cycle is crucial in choosing the right CPU scheduling algorithm.\nI/O-bound programs: Short CPU bursts with frequent I/O operations. CPU-bound programs: Few, long CPU bursts. 5.1.2 CPU Scheduler CPU Scheduler or Short-term Scheduler: Whenever the CPU becomes idle, a short-term scheduler selects processes from the ready queue and allocates the CPU to one of them. Ready Queue: Stores processes in memory that are ready to execute, usually represented by Process Control Blocks (PCBs). 5.1.3 Preemptive Scheduling CPU scheduling occurs in the following situations:\nRunning → Waiting: Process requests I/O or another resource. Running → Ready: An interrupt causes the process to move back to the ready state. Waiting → Ready: Process completes I/O. Process Termination: When a process ends. Nonpreemptive Scheduling: Once a process gets the CPU, it holds it until it terminates or switches to waiting. Preemptive Scheduling: CPU allocation can be interrupted, which may lead to race conditions if processes share data. 5.1.4 Dispatcher The dispatcher is responsible for transferring control of the CPU to the process selected by the short-term scheduler. Its functions include:\nSwitching context: Saving and loading the process states. Switching to user mode: Transitioning from kernel to user mode. Jumping to the process location: Restarting the process at the correct point in its code. Dispatch Latency: The time it takes to switch from one process to another (time it takes for the dispatcher to stop one process and start another).\nThe dispatcher should be as fast as possible, as it is invoked during every process switch.\n5.2 Scheduling Criteria CPU-scheduling algorithms vary in performance, and the choice of algorithm depends on process characteristics. Key criteria for comparing these algorithms include:\nCPU Utilization: Maximize CPU usage. In real systems, it should range from 40% (light load) to 90% (heavy load). Throughput: Measure of work done, defined as the number of processes completed per unit of time. Turnaround Time: Total time from process submission to completion, including waiting in memory, ready queue, CPU execution, and I/O operations. Waiting Time: Time spent waiting in the ready queue, not during execution or I/O. Response Time: Time from process submission to the first response, important in interactive systems where quick feedback is needed. Optimization Goals:\nMaximize: CPU utilization and throughput. Minimize: Turnaround time, waiting time, and response time. Performance Optimization In most cases, average values are optimized, like minimizing average waiting or response time.\nIn some cases (e.g., user fairness), it’s important to minimize the maximum waiting time or response time.\n","date":"2025-01-12","id":176,"permalink":"/personal-site/docs/os/c05_process_scheduling/os-5.01-process-scheduling/","summary":"\u003cp\u003eIn multiprogrammed OS, the aim of CPU scheduling is to maximize CPU utilization by switching between processes and have some process running all the time.\u003c/p\u003e","tags":[],"title":"OS 5.01 - Process Scheduling"},{"content":"CPU scheduling deals with the problem of deciding which of the processes in the ready queue is to be allocated the CPU. There are many different CPU-scheduling algorithms.\n5.3.1 First-Come, First-Served Scheduling (FCFS) The First-Come, First-Served (FCFS) scheduling algorithm allocates the CPU to processes in the order they request it, using a FIFO queue. The process at the head of the queue is given the CPU, and once it completes, it is removed.\nThe average waiting time varies significantly with process order.\nExample: For processes with burst times:\nP1: 24ms P2: 3ms P3: 3ms If they arrive in the order P1 → P2 → P3, the Gantt chart would be:\n| P1 | P2 | P3 | 0 24 27 30\rWaiting time: P1: 0ms P2: 24ms P3: 27ms Average waiting time = (0 + 24 + 27) / 3 = 17ms If the arrival order is changed to P2 → P3 → P1, the Gantt chart is:\n| P2 | P3 | P1 | 0 3 6 30\rAverage waiting time = (6 + 0 + 3) / 3 = 3ms Drawbacks of FCFS Monopolization of CPU:\nThe CPU-bound process consumes the CPU, while I/O-bound processes finish their I/O and enter the ready queue. During this time, I/O devices remain idle, which is inefficient. Transition and Idle CPU:\nOnce the CPU-bound process completes its CPU burst, it moves to the I/O queue. The I/O-bound processes, with shorter CPU bursts, execute quickly and return to the I/O queue, causing the CPU to remain idle. Convoy Effect:\nWhen a CPU-bound process is allocated the CPU, causing I/O-bound processes to wait. This convoy effect results in a situation where short processes are delayed by the long CPU-bound process, leading to inefficient CPU and device utilization. Non-preemptive Scheduling:\nOnce a process is allocated the CPU, it keeps it until it either terminates or requests I/O. This behavior is problematic in time-sharing systems, where it’s crucial for each process to get regular CPU time. ","date":"2025-01-12","id":177,"permalink":"/personal-site/docs/os/c05_process_scheduling/os-5.03-scheduling-algorithms/","summary":"\u003cp\u003eCPU scheduling deals with the problem of deciding which of the processes in the ready queue is to be allocated the CPU. There are many different CPU-scheduling algorithms.\u003c/p\u003e","tags":[],"title":"OS 5.03 - Scheduling Algorithms"},{"content":"The Shortest Job First (SJF) scheduling algorithm assigns the CPU to the process with the shortest next CPU burst. The process with the smallest next burst time is given priority when the CPU becomes available.\nIf two processes have the same next CPU burst, FCFS (First-Come, First-Served) is used to break the tie.\nA more appropriate term for this algorithm would be Shortest-Next-CPU-Burst scheduling, as it relies on the length of the next CPU burst of a process, rather than its total CPU burst time. Optimality:\nThe SJF algorithm is provably optimal, meaning it minimizes the average waiting time for a given set of processes. Moving shorter processes ahead of longer ones reduces the waiting time of short processes more than it increases the waiting time of long processes, leading to a decrease in average waiting time. Preemptive vs Nonpreemptive SJF: Nonpreemptive SJF: Once a process starts executing, it continues until it finishes its CPU burst, even if a new process arrives with a shorter burst.\nPreemptive SJF: If a new process arrives with a shorter CPU burst than the remaining burst of the currently running process, the CPU is preempted and allocated to the new process.\nPreemptive SJF is also known as Shortest-Remaining-Time-First (SRTF) scheduling. Example 1 : Preemptive SJF (SRTF) Processes:\nP1: Arrival Time = 0 ms, Burst Time = 8 ms P2: Arrival Time = 1 ms, Burst Time = 4 ms P3: Arrival Time = 2 ms, Burst Time = 3 ms P4: Arrival Time = 3 ms, Burst Time = 2 ms Step-by-Step Execution: Time Process Running Remaining Burst Time Notes 0 P1 8 P1 arrives, starts execution. 1 P2 4 P2 arrives; P1 has 7 ms left, P2 has 4 ms; P2 preempts P1. 2 P3 3 P3 arrives; P2 has 3 ms left, P3 has 3 ms; P3 preempts P2. 3 P4 2 P4 arrives; P3 has 2 ms left, P4 has 2 ms; P4 preempts P3. 4 P4 1 P4 completes 1 ms of its burst. 5 P4 0 P4 finishes its burst. 6 P3 2 P3 resumes, has 2 ms remaining. 7 P3 1 P3 runs for 1 ms. 8 P3 0 P3 finishes its burst. 9 P2 3 P2 resumes and runs for 3 ms. 12 P1 7 P1 resumes with 7 ms left. 13 P1 6 P1 runs for 1 ms. 14 P1 5 P1 runs for 1 ms. 15 P1 4 P1 runs for 1 ms. 16 P1 3 P1 runs for 1 ms. 17 P1 2 P1 runs for 1 ms. 18 P1 1 P1 runs for 1 ms. 19 P1 0 P1 finishes its burst. Gantt Chart: | P1 | P2 | P3 | P4 | P4 | P3 | P3 | P2 | P1 | P1 | P1 | P1 | P1 | P1 | 0 1 2 3 4 5 6 7 8 9 10 11 12 13\rExample 2 : Preemptive SJF (SRTF) Scenario Processes:\nP1: Arrival Time = 0 ms, Burst Time = 6 ms P2: Arrival Time = 1 ms, Burst Time = 2 ms P3: Arrival Time = 2 ms, Burst Time = 8 ms Step-by-Step Execution: Time Process Running Remaining Burst Time Notes 0 P1 6 P1 starts execution. 1 P2 2 P2 arrives and preempts P1, since P2 has the shortest burst time. 2 P2 1 P2 runs for 1 ms. 3 P2 0 P2 finishes execution. 4 P1 5 P1 resumes with 5 ms left. 5 P1 4 P1 runs for 1 ms. 6 P1 3 P1 runs for 1 ms. 7 P1 2 P1 runs for 1 ms. 8 P1 1 P1 runs for 1 ms. 9 P1 0 P1 finishes. 10 P3 8 P3 starts execution. 11 P3 7 P3 runs for 1 ms. 12 P3 6 P3 runs for 1 ms. 13 P3 5 P3 runs for 1 ms. 14 P3 4 P3 runs for 1 ms. 15 P3 3 P3 runs for 1 ms. 16 P3 2 P3 runs for 1 ms. 17 P3 1 P3 runs for 1 ms. 18 P3 0 P3 finishes. Gantt Chart: | P1 | P2 | P2 | P1 | P1 | P1 | P1 | P1 | P3 | P3 | P3 | P3 | P3 | P3 | P3 | P3 | 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15\rChallenges with Implementation: While SJF is optimal, it is not directly implementable in short-term CPU scheduling since the next CPU burst is unknown. We can approximate the next CPU burst by predicting its length based on previous bursts. Predicting the Next CPU Burst:\nThe next CPU burst is generally predicted as an exponential average of the lengths of previous CPU bursts. The formula for the prediction is:\nT(n+1) = α * Tn + (1 - α) * Tn\rWhere:\nTn = length of the nth CPU burst T(n+1) = predicted value for the next CPU burst α = weighting factor (0 ≤ α ≤ 1) Interpretation of α:\nIf α = 0, then T(n+1) = Tn, meaning only the most recent CPU burst is considered. If α = 1, then T(n+1) = Tn, meaning only the most recent burst is considered, with no weight given to past history. Typically, α = 0.5, meaning recent and past bursts are equally weighted. The initial value of T0 can be set as a constant or as the system\u0026rsquo;s overall average.\n","date":"2025-01-12","id":178,"permalink":"/personal-site/docs/os/c05_process_scheduling/os-5.03.02-shortest-job-first/","summary":"\u003cp\u003eThe \u003cstrong\u003eShortest Job First (SJF)\u003c/strong\u003e scheduling algorithm assigns the CPU to the process with the shortest next CPU burst. The process with the smallest next burst time is given priority when the CPU becomes available.\u003cbr\u003e\nIf two processes have the same next CPU burst, \u003cstrong\u003eFCFS (First-Come, First-Served)\u003c/strong\u003e is used to break the tie.\u003c/p\u003e","tags":[],"title":"OS 5.03.02 - Shortest Job First"},{"content":"The Priority Scheduling algorithm assigns a priority to each process, and the CPU is allocated to the process with the highest priority. If two processes have the same priority, First-Come, First-Served (FCFS) scheduling is used to break the tie.\nSJF (Shortest Job First) is a special case of the priority scheduling algorithm, where the priority is the inverse of the predicted next CPU burst. This means that the process with the shortest burst time has the highest priority. Priority Types: Internally Defined Priorities: These are calculated based on measurable factors such as:\nTime limits Memory requirements Number of open files The ratio of average I/O burst to average CPU burst Externally Defined Priorities: These are set by external factors such as:\nThe importance of the process Funds being paid for computer use The sponsoring department or other external criteria (sometimes political) Preemptive vs Nonpreemptive Priority Scheduling: Preemptive Priority Scheduling: If a new process arrives in the ready queue with a higher priority than the currently running process, it will preempt the CPU and start execution immediately.\nNonpreemptive Priority Scheduling: If a new process arrives with a higher priority than the currently running process, the new process is placed at the head of the ready queue. The CPU is not preempted; instead, the currently running process continues until it completes or blocks, and then the new process is scheduled.\nMajor Issues: Indefinite Blocking (Starvation): Low-priority processes may never get a chance to run because higher-priority processes always take precedence.\nAging is used to address starvation. Aging involves gradually increasing the priority of processes that have been waiting in the system for a long time. Over time, even low-priority processes will eventually have high enough priority to be executed.\n","date":"2025-01-12","id":179,"permalink":"/personal-site/docs/os/c05_process_scheduling/os-5.03.03-priority-scheduling/","summary":"\u003cp\u003eThe \u003cstrong\u003ePriority Scheduling\u003c/strong\u003e algorithm assigns a priority to each process, and the CPU is allocated to the process with the highest priority. If two processes have the same priority, \u003cstrong\u003eFirst-Come, First-Served (FCFS)\u003c/strong\u003e scheduling is used to break the tie.\u003c/p\u003e","tags":[],"title":"OS 5.03.03 - Priority Scheduling"},{"content":"The Round-Robin (RR) scheduling algorithm is similar to FCFS (First-Come, First-Served) scheduling, with the key difference being preemption, which allows the system to switch between processes. Primarily designed for time-sharing systems.\nTime Quantum (or Time Slice): A small unit of time (typically between 10 to 100 milliseconds) that is defined to allocate CPU time to each process. Preemption: No process is allocated the CPU for more than 1 time quantum in a row (unless it is the only runnable process). RR Scheduling Process: The Ready Queue is treated as a circular queue. The CPU scheduler goes around the ready queue, allocating the CPU to each process for a time interval of up to 1 time quantum. The ready queue operates as a FIFO (First-In-First-Out) queue: New processes are added to the tail of the queue. The CPU scheduler selects the first process from the queue. The CPU scheduler sets a timer to interrupt after 1 time quantum and dispatches the process. If CPU Burst \u0026lt; 1 Time Quantum: The process releases the CPU voluntarily. The scheduler moves to the next process in the queue. If CPU Burst \u0026gt; 1 Time Quantum: The timer interrupts, causing a context switch. The process is preempted and placed back at the tail of the ready queue. The scheduler then selects the next process. Performance and Time Quantum: Impact of Time Quantum Size:\nIf the time quantum is too large, RR scheduling becomes equivalent to FCFS scheduling. If the time quantum is too small (e.g., 1 millisecond), it can result in a large number of context switches, leading to inefficiency. Ideal Time Quantum:\nThe time quantum should be large relative to the context-switch time. For example, if the context-switch time is about 10% of the time quantum, then approximately 10% of the CPU time will be spent on context switching. A rule of thumb is that 80% of CPU bursts should be shorter than the time quantum to optimize performance. Average Waiting Time: The average waiting time under RR scheduling is typically longer compared to other scheduling algorithms.\nThe average turnaround time can improve if most processes finish their CPU burst within a single time quantum.\nFairness: If there are n processes in the ready queue and the time quantum is q, then each process gets 1/n of the CPU time in chunks of up to q time units.\nMaximum Wait Time: Each process must wait no longer than (n - 1) × q time units until its next time quantum. Example:\nWith 5 processes and a time quantum of 20 milliseconds, each process will get up to 20 milliseconds every 100 milliseconds.\nExample 1: Different CPU Burst Times Assumptions:\n4 processes: P1, P2, P3, P4 Time quantum = 3 milliseconds CPU bursts: P1: 5 ms P2: 2 ms P3: 6 ms P4: 4 ms Ready Queue: P1 → P2 → P3 → P4\nStep-by-Step Execution: Time Process Running Event Ready Queue 0 P1 P1 runs for 3 ms P2 → P3 → P4 3 P2 P1 preempted, P2 runs for 2 ms P3 → P4 → P1 5 P3 P2 finishes, P3 runs for 3 ms P4 → P1 8 P4 P3 preempted, P4 runs for 3 ms P1 → P3 11 P1 P4 preempted, P1 runs for 2 ms P3 → P4 13 P3 P1 finishes, P3 runs for 3 ms P4 → P1 16 P4 P3 finishes, P4 runs for 1 ms P1 → P3 17 P1 P4 finishes, P1 runs for 3 ms P3 20 P3 P1 finishes, P3 finishes Processes are rotated based on the time quantum, and processes that need more CPU time are repeatedly preempted and moved back to the end of the queue until they complete.\nExample 2: Time Quantum Too Large (Degenerating to FCFS) Assumptions:\n3 processes: P1, P2, P3 Time quantum = 10 milliseconds (larger than the CPU bursts) Ready Queue: P1 → P2 → P3\nStep-by-Step Execution: Time Process Running Event Ready Queue 0 P1 P1 runs for 10 ms P2 → P3 10 P2 P1 finishes, P2 runs for 10 ms P3 20 P3 P2 finishes, P3 runs for 10 ms 30 P3 finishes In this case, the time quantum is larger than the CPU bursts of the processes (which could be around 5 ms each). Therefore, each process runs to completion without being preempted, making the Round-Robin algorithm essentially behave like FCFS scheduling.\n","date":"2025-01-12","id":180,"permalink":"/personal-site/docs/os/c05_process_scheduling/os-5.03.04-round-robin-scheduling/","summary":"\u003cp\u003eThe \u003cstrong\u003eRound-Robin (RR)\u003c/strong\u003e scheduling algorithm is similar to \u003cstrong\u003eFCFS (First-Come, First-Served)\u003c/strong\u003e scheduling, with the key difference being \u003cstrong\u003epreemption\u003c/strong\u003e, which allows the system to switch between processes. Primarily designed for time-sharing systems.\u003c/p\u003e","tags":[],"title":"OS 5.03.04 - Round-Robin Scheduling"},{"content":"Multilevel Queue Scheduling is used in situations where processes can be easily classified into different groups.\nA common division is made between foreground (interactive) processes and background (batch) processes. These two types of processes have different response-time requirements and, therefore, may have different scheduling needs. Additionally, foreground processes may have higher priority (externally defined) over background processes.\nThe ready queue is partitioned into several separate queues. Each queue is dedicated to a specific type of process, such as based on memory size, process priority, or process type. Each queue has its own scheduling algorithm. For example, the foreground queue might use Round-Robin (RR) scheduling, while the background queue could use First-Come, First-Served (FCFS) scheduling. Scheduling Among Queues: Scheduling between the different queues is usually implemented as fixed-priority preemptive scheduling. Higher-priority queues always take precedence over lower-priority queues. For example, the foreground queue may have absolute priority over the background queue. Example list in order of priority:\nSystem processes Interactive processes Interactive editing processes Batch processes Student processes In this system:\nProcesses in the system queue have the highest priority and will run before any other processes. A batch process (lowest priority) can only run when the queues for system, interactive, and interactive editing processes are empty. If a process from a higher-priority queue enters the ready queue, it will preempt processes from lower-priority queues. Time-Slicing Among Queues: Another possibility is to allocate CPU time slices among the queues:\nEach queue receives a certain portion of the CPU time, which it can then schedule among its individual processes. Example:\nThe foreground queue may receive 80% of the CPU time and use Round-Robin (RR) scheduling to allocate time to its processes. The background queue may receive 20% of the CPU time and use First-Come, First-Served (FCFS) scheduling for its processes. In traditional multilevel queue scheduling, processes are permanently assigned to a specific queue when they enter the system. For example, if separate queues are used for foreground and background processes, the processes do not move from one queue to another. This setup is efficient with low scheduling overhead, but it is inflexible.\n5.3.5 Multilevel Feedback Queue Scheduling: Unlike the traditional approach, the multilevel feedback queue scheduling algorithm allows processes to move between queues. The primary idea is to separate processes based on the characteristics of their CPU bursts:\nIf a process consumes too much CPU time, it is moved to a lower-priority queue. This allows I/O-bound and interactive processes (which tend to use less CPU time) to remain in the higher-priority queues. Processes that have been waiting too long in a lower-priority queue are upgraded to a higher-priority queue. This mechanism, known as aging, helps to prevent starvation. A multilevel feedback queue scheduler is defined by the following parameters:\nNumber of Queues: The total number of queues in the system. Scheduling Algorithm for Each Queue: The algorithm used for scheduling processes within each individual queue (e.g., Round-Robin, FCFS). Method for Upgrading Processes: The criteria or mechanism used to determine when a process should be moved to a higher-priority queue. Method for Demoting Processes: The criteria or mechanism used to determine when a process should be moved to a lower-priority queue. Method for Assigning Processes to Queues: The criteria used to decide which queue a process will enter when it first arrives in the system or requires service. Advantages: Flexibility: Unlike fixed multilevel queues, this algorithm adapts to the behavior of processes, allowing better handling of varying workloads. Prevents Starvation: The aging mechanism ensures that processes in lower-priority queues will eventually be promoted to avoid indefinite waiting. The multilevel feedback queue scheduler is the most general CPU-scheduling algorithm, offering high configurability to match the specific requirements of a given system design.\n","date":"2025-01-12","id":181,"permalink":"/personal-site/docs/os/c05_process_scheduling/os-5.03.05-multi-level-queue-scheduling/","summary":"\u003cp\u003eMultilevel Queue Scheduling is used in situations where processes can be easily classified into different groups.\u003c/p\u003e\n\u003cp\u003eA common division is made between \u003cstrong\u003eforeground (interactive)\u003c/strong\u003e processes and \u003cstrong\u003ebackground (batch)\u003c/strong\u003e processes. These two types of processes have different response-time requirements and, therefore, may have different scheduling needs. Additionally, \u003cstrong\u003eforeground processes\u003c/strong\u003e may have higher priority (externally defined) over \u003cstrong\u003ebackground processes\u003c/strong\u003e.\u003c/p\u003e","tags":[],"title":"OS 5.03.05 - Multi-Level Queue Scheduling"},{"content":"Process synchronization refers to various mechanisms used to ensure the orderly execution of cooperating processes that share a logical address space, ensuring data consistency is maintained.\n6.1 Background Concurrent vs. Parallel Execution:\nConcurrent execution occurs when processes share CPU time and are executed in overlapping time periods. While a process may not be executing at every moment, it appears to be progressing due to rapid switching between processes by the CPU scheduler. Parallel execution, on the other hand, involves two or more processes executing simultaneously on separate processing cores. Context of Process Execution:\nWhen processes execute concurrently or in parallel, one process may only partially complete execution before another process is scheduled. In concurrent execution, a process can be interrupted at any point in its instruction stream, and another process might begin execution immediately, potentially causing issues when both processes manipulate shared data. Parallel execution involves multiple processes running at the same time on different processors or cores, which may lead to similar data integrity issues when accessing shared data. Problems Arising from Concurrent Execution Race Condition:\nA race condition occurs when multiple processes or threads concurrently access and manipulate shared data, and the outcome depends on the order or timing of the execution of these processes. For example, if two processes simultaneously attempt to increment a shared counter variable, the outcome can vary based on the order in which the increments occur, leading to inconsistent or incorrect results. Example:\nConsider two processes, P1 and P2, both incrementing the shared variable counter: P1 reads the value of counter. P2 also reads the same value of counter before P1 has a chance to update it. P1 increments the counter and writes back the value. P2 increments the old value and writes it back, overwriting P1\u0026rsquo;s update. This results in lost updates or incorrect values, which is a classic race condition.\nImportance of Process Synchronization Guarding Against Race Conditions:\nTo prevent issues like race conditions, it is necessary to ensure that only one process can manipulate shared data at a time. Process synchronization mechanisms are required to control access to shared resources. Goal:\nSynchronization guarantees that processes are executed in such a way that shared data is protected from conflicting updates, ensuring correctness and data consistency. The Impact of Multicore Systems Multithreading and Data Sharing:\nThe rise of multicore systems has led to an increase in multithreaded applications, where multiple threads run in parallel on different processing cores. Shared Data: In multithreaded programs, multiple threads may access and modify the same shared data, further emphasizing the need for synchronization. Potential for Conflict: Without synchronization, concurrent updates to shared data could result in race conditions, even in parallel execution environments. Challenges:\nSynchronizing processes across multiple cores can be more complex due to the simultaneous execution of threads. Effective synchronization ensures that updates from threads running on different cores do not interfere with each other and guarantees data integrity. ","date":"2025-01-12","id":182,"permalink":"/personal-site/docs/os/c06_synchronization/os-6.01-process-synchronization/","summary":"\u003cp\u003e\u003cstrong\u003eProcess synchronization\u003c/strong\u003e refers to various mechanisms used to ensure the orderly execution of cooperating processes that share a \u003cstrong\u003elogical address space\u003c/strong\u003e, ensuring \u003cstrong\u003edata consistency\u003c/strong\u003e is maintained.\u003c/p\u003e","tags":[],"title":"OS 6.01 - Process Synchronization"},{"content":"","date":"2025-01-12","id":183,"permalink":"/personal-site/docs/os/c06_synchronization/","summary":"","tags":[],"title":"Chapter 6 -  Process Synchronization"},{"content":"Consider a system with n processes: {P0, P1, \u0026hellip;, Pn-1}. Each process has a critical section, a segment of code where the process manipulates shared resources (such as common variables, a table, or a file).\nThe key requirement is that no two processes can be executing in their critical sections at the same time. In other words, if one process is in its critical section, no other process can enter its critical section simultaneously. The challenge is to design a protocol that coordinates access to the critical section.\nEach process must request permission to enter its critical section, and this request is handled in the entry section of the code.\nThe exit section follows the critical section, and any remaining code is called the remainder section.\nRequirements for a Solution: A solution to the critical-section problem must meet the following three conditions:\nMutual Exclusion:\nIf process Pi is executing in its critical section, no other process can execute in its critical section. Progress:\nIf no process is executing in its critical section and some processes wish to enter their critical sections, then the processes that are not in their remainder sections should participate in selecting which process will enter the critical section next. This selection cannot be postponed indefinitely. Bounded Waiting:\nThere is a bound (limit) on the number of times other processes are allowed to enter their critical sections after a process has requested to enter its critical section, but before that request is granted. Race Conditions in Operating Systems: At any given time, many kernel-mode processes might be active in the operating system, and kernel code is prone to race conditions.\nExample:\nA kernel data structure that maintains a list of all open files in the system. When a file is opened or closed, the list must be modified (adding or removing the file). If two processes try to open files simultaneously, their updates to the list could conflict, resulting in a race condition. Other kernel data structures that are vulnerable to race conditions include:\nMemory allocation structures Process lists Interrupt handling mechanisms Approaches to Handling Critical Sections: Preemptive Kernels:\nIn a preemptive kernel, a process can be preempted (interrupted) while it is running in kernel mode. Preemptive kernels are more complex because they need to handle race conditions in shared kernel data, especially on multiprocessor (SMP) architectures, where multiple kernel processes can run concurrently on different processors. Nonpreemptive Kernels:\nIn a nonpreemptive kernel, a process running in kernel mode cannot be preempted. The process will continue running until it exits kernel mode, blocks, or voluntarily yields control of the CPU. Nonpreemptive kernels are effectively free from race conditions since only one process can be executing in kernel mode at any time. Why Choose a Preemptive Kernel? A preemptive kernel may be preferred because it ensures that no process can run for an arbitrarily long period, improving system responsiveness. It is particularly beneficial in real-time systems, where a real-time process may need to preempt a kernel-mode process. The main benefit of a preemptive kernel is that it prevents any kernel-mode process from monopolizing the CPU, which can lead to better responsiveness and suitability for real-time programming. ","date":"2025-01-12","id":184,"permalink":"/personal-site/docs/os/c06_synchronization/os-6.02-critical-section-problem/","summary":"\u003cp\u003eConsider a system with \u003cstrong\u003en processes\u003c/strong\u003e: {P0, P1, \u0026hellip;, Pn-1}. Each process has a \u003cstrong\u003ecritical section\u003c/strong\u003e, a segment of code where the process manipulates shared resources (such as common variables, a table, or a file).\u003c/p\u003e","tags":[],"title":"OS 6.02 - Critical-Section Problem"},{"content":"Operating system designers use software tools to address the critical-section problem, and one of the simplest tools used is the mutex lock.\nThe term mutex is short for mutual exclusion, and its purpose is to protect critical regions of code to prevent race conditions.\nPurpose of Mutex Locks: A mutex lock ensures that only one process can access a critical section at a time. A process must acquire the lock before entering a critical section and must release the lock when it exits the critical section. Functions: acquire(): This function is used to acquire the mutex lock before entering the critical section. release(): This function is used to release the lock once the process exits the critical section. Mechanism: A mutex lock uses a boolean variable called available to track whether the lock is available or not. If available is true, the lock is available, and the process can acquire it. If available is false, the lock is unavailable, and the process trying to acquire the lock will be blocked until the lock is released. acquire() Function: The definition of the acquire() function is as follows:\nacquire() { while (!available) ; /* busy wait */ available = false; }\rThe acquire() function checks if the lock is available by evaluating the available variable. If the lock is unavailable (available == false), the process enters a busy wait, meaning it continuously checks if the lock becomes available. Once the lock is available, the process acquires it by setting available to false, making the lock unavailable for other processes. release() Function: The definition of the release() function is as follows:\nrelease() { available = true; }\rThe release() function simply sets available to true, indicating that the lock is now available for other processes to acquire.\nAtomicity: Calls to acquire() and release() must be atomic to avoid race conditions during the process of acquiring and releasing the lock.\nExample of Mutex Lock Usage: do { acquire(); // Acquire the lock critical_section(); // Execute the critical section release(); // Release the lock remainder_section(); // Execute the remainder section } while (true);\rDisadvantages of Mutex Locks: Busy Waiting:\nThe primary drawback of the above mutex lock implementation is busy waiting. While a process is in its critical section, any other process trying to enter its critical section must loop continuously in the acquire() function. This results in inefficient use of CPU resources, especially in a multiprogramming system, where a single CPU is shared among many processes. The CPU is occupied by the spinning process instead of being used by other processes. Spinlock:\nA mutex lock with busy waiting is often referred to as a spinlock because the process \u0026ldquo;spins\u0026rdquo; in a loop while waiting for the lock to become available. This spinning wastes CPU cycles that could be used by other processes. Advantages of Spinlocks: No Context Switching:\nSpinlocks have the advantage of avoiding context switching when a process waits for the lock. A context switch can be time-consuming, and by using a spinlock, the overhead of a context switch is eliminated. This makes spinlocks useful when locks are held for short durations, as the process will spend minimal time waiting and will not need a context switch. Useful in Multiprocessor Systems:\nSpinlocks are particularly beneficial in multiprocessor systems, where one thread can \u0026ldquo;spin\u0026rdquo; on one processor while another thread executes its critical section on a separate processor. In this case, one processor is available to handle the spinning process, while the other processor executes the critical section, leading to more efficient resource utilization. Conclusion: Mutex locks are essential tools for protecting critical sections and preventing race conditions in concurrent systems. While the busy-waiting nature of mutex locks (spinlocks) has drawbacks in terms of CPU resource usage, they offer benefits such as avoiding context switching and are suitable for situations where locks are held for short durations or in multiprocessor environments. ","date":"2025-01-12","id":185,"permalink":"/personal-site/docs/os/c06_synchronization/os-6.05-mutex-locks/","summary":"\u003cp\u003eOperating system designers use software tools to address the \u003cstrong\u003ecritical-section problem\u003c/strong\u003e, and one of the simplest tools used is the \u003cstrong\u003emutex lock\u003c/strong\u003e.\u003c/p\u003e","tags":[],"title":"OS 6.05 - Mutex Locks"},{"content":"Semaphores are a more advanced and flexible synchronization mechanism compared to mutex locks. They allow processes to synchronize their actions in more sophisticated ways.\nA semaphore is an integer variable that controls access to a shared resource. Apart from being initialized, the semaphore can only be accessed using two operations: wait() and signal(), both of which are atomic (indivisible) operations.\nThe wait() and signal() Operations The wait() operation checks the value of the semaphore. If the value is greater than 0, it decrements the value and allows the process to proceed. If the value is 0 or less, the process will wait (i.e., it will keep checking the value until it can proceed). This prevents the process from proceeding if resources are unavailable. wait(S) { while (S \u0026lt;= 0) ; // busy wait S--; }\rThe signal() operation increments the semaphore value, signaling that a resource has been released or an event has occurred. This operation allows waiting processes to continue if necessary. signal(S) { S++; }\rBoth the wait() and signal() operations modify the semaphore’s value. These operations must be executed atomically—meaning no other process can change the semaphore’s value while it’s being modified. This ensures that the operation is performed correctly and without interruption. (in the case of wait(S), both the testing of the semaphore’s value (S ≤ 0) and its modification (S--) must be executed without interruption.)\n6.6.1 Semaphore Usage in Synchronization Types of Semaphores Semaphores are typically divided into two types:\nCounting semaphores: These semaphores can have any non-negative integer value, making them useful for managing multiple instances of a resource (e.g., a pool of identical resources). They are commonly used in scenarios where multiple resources are available, and each process needs to track how many resources are in use.\nBinary semaphores: These semaphores can only have two values: 0 or 1. This behavior makes them similar to mutex locks, where the semaphore can either be in a locked (0) or unlocked (1) state.\nCounting semaphores are particularly useful when controlling access to resources that have a limited number of instances.\nFor example, in a system with a finite number of identical resources. A semaphore is initialized with the number of available resources.\nEach process that wants to use a resource must perform a wait() operation, which decreases the semaphore’s value.\nWhen the process is done using the resource, it performs a signal() operation to increase the semaphore’s value, making the resource available again.\nIf the semaphore’s value is 0, it indicates that no resources are available, and any process attempting to use a resource will block (wait) until a resource is freed.\nExample: Process Synchronization with Semaphores Consider two processes, P1 and P2, running concurrently. Let’s say we want to ensure that process P2 executes its statement S2 only after process P1 has executed its statement S1.\nWe can achieve this synchronization using a common semaphore, synch, initialized to 0.\nIn P1:\nS1; // Execute some operation signal(synch); // Signal that S1 is complete In P2:\nwait(synch); // Wait until P1 signals S2; // Execute the operation only after S1 is done Since synch is initialized to 0, process P2 will be blocked at wait(synch) until process P1 executes signal(synch) after completing S1. Only then can process P2 proceed with S2.\n6.6.2 Semaphore Implementation The wait() and signal() operations have a busy-waiting issue similar to that of mutex locks.\nTo avoid this inefficiency, we can modify these operations so that processes do not repeatedly check the semaphore value in a busy-wait loop.\nWhen a process executes the wait() operation and finds the semaphore value is not positive, it does not engage in busy waiting. Instead, the process blocks itself, placing it in a waiting queue associated with the semaphore. The process state is switched to the waiting state, and control is transferred to the CPU scheduler, which selects another process to execute.\nWhen another process executes the signal() operation, the blocked process is restarted by the wakeup() operation, which transitions it from the waiting state to the ready state and places it in the ready queue allowing it ti resume execution.\nTo implement this, a semaphore is defined as:\ntypedef struct { int value; // Semaphore\u0026#39;s value (integer) struct process *list; // List of processes waiting on the semaphore } semaphore;\rEach semaphore has:\nAn integer value to track the available resources (or events). A list of processes that are currently waiting for the semaphore. The signal() operation removes a process from the list and awakens it. The wait() operation is now defined as:\nwait(semaphore *S) { S-\u0026gt;value--; // Decrement the semaphore value if (S-\u0026gt;value \u0026lt; 0) { // If the value is negative, the process must wait add this process to S-\u0026gt;list; // Add the process to the waiting list block(); // Block the process (move it to the waiting state) } }\rThe signal() operation is defined as:\nsignal(semaphore *S) { S-\u0026gt;value++; // Increment the semaphore value if (S-\u0026gt;value \u0026lt;= 0) { // If there are processes waiting remove a process P from S-\u0026gt;list; // Remove a process from the waiting list wakeup(P); // Wake up the process and move it to the ready state } }\rblock(): This operation suspends the invoking process and places it in the waiting state. wakeup(P): This operation resumes the execution of a blocked process P, moving it to the ready state, where it can be scheduled by the CPU. These operations are handled by the operating system as system calls.\nEnsuring Atomicity It is essential that semaphore operations (wait() and signal()) are atomic. This means that no two processes should be able to execute wait() or signal() on the same semaphore at the same time. If this atomicity is not ensured, it could lead to incorrect behavior and synchronization problems.\nTo achieve atomicity, we need to prevent context switching during the execution of the semaphore operations. One way to do this is by disabling interrupts temporarily during the execution of wait() and signal(). While this guarantees atomicity, it comes with a performance cost, as it reduces the system\u0026rsquo;s responsiveness.\nIn Symmetric Multiprocessing (SMP) systems, where multiple processors might be involved, alternative locking mechanisms such as compare and swap() or spinlocks can be used to ensure that semaphore operations are atomic.\nHowever, while these mechanisms solve the atomicity issue, they do not completely eliminate busy waiting—they only move the busy waiting from the entry section (where processes wait to enter a critical section) to the critical sections of application programs.\n6.6.3 Deadlock and Starvation Deadlock occurs when two or more processes are stuck, each waiting indefinitely for an event (such as a signal() operation) that can only be triggered by one of the processes in the group.\nIn other words, a set of processes is deadlocked when every process is waiting for an event that can only be caused by another process in the same set, creating a circular dependency.\nExample of Deadlock Consider two processes, P0 and P1, each trying to access two semaphores, S and Q, which are both initialized to 1:\nP0:\nwait(S); wait(Q); ... signal(S); signal(Q);\rP1:\nwait(Q); wait(S); ... signal(Q); signal(S);\rP0 executes wait(S) and successfully acquires semaphore S. P1 then executes wait(Q) and successfully acquires semaphore Q. Next, P0 tries to execute wait(Q), but it must wait because P1 holds Q. Meanwhile, P1 tries to execute wait(S), but it must wait because P0 holds S. At this point, P0 is waiting for P1 to release Q, and P1 is waiting for P0 to release S. Neither process can proceed because they are waiting for each other to signal the other. This creates a deadlock, where both processes are stuck in a cycle of waiting.\nStarvation (Indefinite Blocking) Another issue related to deadlock is starvation, or indefinite blocking, which happens when a process is perpetually delayed because other processes keep taking priority.\nThis can occur if processes are removed from the semaphore’s waiting list in a LIFO (Last-In, First-Out) order, meaning that newer processes are always allowed to proceed before older ones. As a result, processes at the front of the list may be blocked indefinitely while newer processes keep getting executed.\n","date":"2025-01-12","id":186,"permalink":"/personal-site/docs/os/c06_synchronization/os-6.06-semaphores/","summary":"\u003cp\u003eSemaphores are a more advanced and flexible synchronization mechanism compared to mutex locks. They allow processes to synchronize their actions in more sophisticated ways.\u003c/p\u003e","tags":[],"title":"OS 6.06 - Semaphores"},{"content":"Synchronization problems as examples of a large class of concurrency-control problems. These problems are used for testing nearly every newly proposed synchronization scheme.\n6.7.2 Reader-Writers Problem The Reader-Writers problem is a classic synchronization issue that arises when multiple processes share access to a database. Some processes may need only read access (readers), while others require both read and write access (writers).\nReading: If two readers access the shared database simultaneously, no conflicts occur. Writing: If a writer and any other process (whether a reader or another writer) attempt to access the database at the same time, conflicts and inconsistencies may arise. To prevent this, writers must have exclusive access to the database when writing. The goal of the Reader-Writers problem is to manage access to the shared resource (the database) in a way that ensures no conflicts occur, while also balancing fairness between readers and writers.\nVariants of the Reader-Writers Problem First Readers-Writers Problem:\nRequirement: No reader should be kept waiting for access unless a writer has already been granted permission to access the database. Goal: Ensure that readers can access the database concurrently without having to wait for other readers, even if a writer is waiting. Second Readers-Writers Problem:\nRequirement: Once a writer is ready, the writer should be able to access the database as soon as possible. Goal: If a writer is waiting, no new readers should begin reading until the writer has finished. Both problems have the potential for starvation:\nIn the first case, writers may starve if readers continue to gain access. In the second case, readers may starve if writers continuously prevent new readers from starting. Solution to the First Readers-Writers Problem The solution to the first readers-writers problem involves the following key data structures shared by reader and writer processes:\nsemaphore rw_mutex = 1; // Mutex for writer semaphore mutex = 1; // Mutex for readers int read_count = 0; // Tracks number of readers currently accessing the database rw_mutex and mutex are initialized to 1. read_count is initialized to 0 to track the number of active readers. A writer process follows this structure:\ndo { wait(rw_mutex); // Acquire exclusive access for writing // Writing is performed signal(rw_mutex); // Release exclusive access } while (true);\rrw_mutex ensures that only one writer can access the database at a time. A reader process follows this structure:\ndo { wait(mutex); // Ensure mutual exclusion when updating read_count read_count++; // Increment number of active readers if (read_count == 1) wait(rw_mutex); // First reader locks the writer mutex signal(mutex); // Release mutex after updating read_count // Reading is performed wait(mutex); // Ensure mutual exclusion when updating read_count read_count--; // Decrement number of active readers if (read_count == 0) signal(rw_mutex); // Last reader unlocks the writer mutex signal(mutex); // Release mutex after updating read_count } while (true);\rmutex ensures mutual exclusion when modifying read_count.\nrw_mutex ensures exclusive access for writers. It is locked by the first reader and unlocked by the last reader.\nKey Points:\nIf a writer is in the critical section and there are n readers waiting, then 1 reader waits on rw_mutex, and the remaining n-1 readers wait on mutex. When signal(rw_mutex) is executed, the scheduler decides whether to resume a waiting reader or a waiting writer. Reader-Writer Locks The Reader-Writers problem and its solutions have been extended into reader-writer locks, which are implemented in some systems to simplify synchronization. A reader-writer lock can be acquired in one of two modes:\nRead Mode: For processes that only need to read shared data. Write Mode: For processes that need to both read and write shared data. Multiple processes can acquire the lock in read mode concurrently. Only one process can acquire the lock in write mode at a time, ensuring exclusive access to the shared data. Reader-writer locks are most useful in situations where:\nProcesses can be clearly identified as readers or writers, making it easy to distinguish between those that only need to read data and those that need to modify the data. There are more readers than writers, as allowing multiple readers to access the data concurrently significantly improves performance. While the overhead of establishing a reader-writer lock is higher than using semaphores or mutual-exclusion locks, the increased concurrency of multiple readers justifies the overhead. 6.7.3 Dining-Philosophers Problem Consider five philosophers who spend their lives thinking and eating. These philosophers share a circular table with five chairs, each belonging to one philosopher. In the center of the table is a bowl of rice, and five chopsticks are laid out for use.\nProblem Setup: When a philosopher is thinking, she does not interact with her neighbors. From time to time, a philosopher gets hungry and tries to pick up the two chopsticks closest to her: one between her and the philosopher on her left, and the other between her and the philosopher on her right. A philosopher can only pick up one chopstick at a time. She cannot pick up a chopstick that is already in use by a neighboring philosopher. Once a philosopher has both chopsticks, she eats and does not release them until she is done. After eating, the philosopher puts down both chopsticks and returns to thinking. This scenario is a simple model for the problem of allocating resources (chopsticks) among competing processes (philosophers) in a deadlock-free and starvation-free manner.\nSolution Using Semaphores One straightforward solution involves representing each chopstick with a semaphore. The philosopher attempts to grab a chopstick by executing a wait() operation on the corresponding semaphore. When finished eating, she releases the chopsticks by executing the signal() operation on the respective semaphores.\nShared Data: semaphore chopstick[5]; // Array of semaphores for chopsticks All elements of chopstick are initialized to 1, representing that each chopstick is available. Philosopher Process: do { wait(chopstick[i]); // Pick up left chopstick wait(chopstick[(i+1) % 5]); // Pick up right chopstick /* Eat for a while */ signal(chopstick[i]); // Put down left chopstick signal(chopstick[(i+1) % 5]); // Put down right chopstick /* Think for a while */ } while (true);\rEach philosopher executes this loop, trying to pick up chopsticks, eat, and then think. Problems with the Simple Solution Although this solution ensures that no two neighboring philosophers eat at the same time, it has the potential to lead to deadlock.\nDeadlock Scenario: Suppose all five philosophers become hungry at the same time. Each philosopher picks up her left chopstick (the one between her and her left neighbor). Now, all chopsticks are in use (value = 0), and when each philosopher tries to pick up her right chopstick, she will be blocked, waiting forever. This leads to a deadlock where no philosopher can proceed. Possible Remedies for Deadlock Several solutions can be applied to avoid the deadlock problem:\nLimit the number of philosophers: Allow at most four philosophers to sit at the table at any one time. This guarantees that at least one philosopher can always pick up both chopsticks.\nCritical Section for Picking Chopsticks:\nEnsure that a philosopher can only pick up both chopsticks if both are available. This means the philosopher must acquire both chopsticks within a critical section to avoid conflicts. Asymmetric Solution:\nIntroduce an asymmetric rule to the philosophers: Odd-numbered philosophers pick up their left chopstick first, then their right chopstick. Even-numbered philosophers pick up their right chopstick first, then their left chopstick. This solution prevents the circular wait condition and reduces the likelihood of deadlock. ","date":"2025-01-12","id":187,"permalink":"/personal-site/docs/os/c06_synchronization/os-6.07-classic-problems/","summary":"\u003cp\u003eSynchronization problems as examples of a large class of concurrency-control problems. These problems are used for testing nearly every newly proposed synchronization scheme.\u003c/p\u003e","tags":[],"title":"OS 6.07 - Classic Problems"},{"content":"","date":"2024-10-07","id":188,"permalink":"/personal-site/","summary":"","tags":[],"title":"Sujith's Library"},{"content":"Surprised!! Why are you even here?? ","date":"2023-09-07","id":189,"permalink":"/personal-site/privacy/","summary":"\u003ch1 id=\"surprised\"\u003eSurprised!!\u003c/h1\u003e\n\u003ch2 id=\"why-are-you-even-here\"\u003eWhy are you even here??\u003c/h2\u003e","tags":[],"title":"Privacy Policy"},{"content":"","date":"0001-01-01","id":190,"permalink":"/personal-site/categories/","summary":"","tags":[],"title":"Categories"},{"content":"","date":"0001-01-01","id":191,"permalink":"/personal-site/contributors/","summary":"","tags":[],"title":"Contributors"},{"content":"","date":"0001-01-01","id":192,"permalink":"/personal-site/tags/","summary":"","tags":[],"title":"Tags"}]